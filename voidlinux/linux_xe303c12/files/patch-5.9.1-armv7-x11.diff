diff --git a/Documentation/devicetree/bindings/power/pwrseq/pwrseq-generic.txt b/Documentation/devicetree/bindings/power/pwrseq/pwrseq-generic.txt
new file mode 100644
index 000000000000..ebf0d477b688
--- /dev/null
+++ b/Documentation/devicetree/bindings/power/pwrseq/pwrseq-generic.txt
@@ -0,0 +1,48 @@
+The generic power sequence library
+
+Some hard-wired devices (eg USB/MMC) need to do power sequence before
+the device can be enumerated on the bus, the typical power sequence
+like: enable USB PHY clock, toggle reset pin, etc. But current
+Linux device driver lacks of such code to do it, it may cause some
+hard-wired devices works abnormal or can't be recognized by
+controller at all. The power sequence will be done before this device
+can be found at the bus.
+
+The power sequence properties is under the device node.
+
+Optional properties:
+- clocks: the input clocks for device.
+- reset-gpios: Should specify the GPIO for reset.
+- reset-duration-us: the duration in microsecond for assert reset signal.
+
+Below is the example of USB power sequence properties on USB device
+nodes which have two level USB hubs.
+
+&usbotg1 {
+	vbus-supply = <&reg_usb_otg1_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usb_otg1_id>;
+	status = "okay";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+	genesys: hub@1 {
+		compatible = "usb5e3,608";
+		reg = <1>;
+
+		clocks = <&clks IMX6SX_CLK_CKO>;
+		reset-gpios = <&gpio4 5 GPIO_ACTIVE_LOW>; /* hub reset pin */
+		reset-duration-us = <10>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+		asix: ethernet@1 {
+			compatible = "usbb95,1708";
+			reg = <1>;
+
+			clocks = <&clks IMX6SX_CLK_IPG>;
+			reset-gpios = <&gpio4 6 GPIO_ACTIVE_LOW>; /* ethernet_rst */
+			reset-duration-us = <15>;
+		};
+	};
+};
diff --git a/Documentation/devicetree/bindings/usb/usb-device.txt b/Documentation/devicetree/bindings/usb/usb-device.txt
index 036be172b1ae..cb85f82a12bb 100644
--- a/Documentation/devicetree/bindings/usb/usb-device.txt
+++ b/Documentation/devicetree/bindings/usb/usb-device.txt
@@ -65,6 +65,9 @@ Required properties for host-controller nodes with device nodes:
 - #address-cells: shall be 1
 - #size-cells: shall be 0
 
+Optional properties:
+power sequence properties, see
+Documentation/devicetree/bindings/power/pwrseq/pwrseq-generic.txt for detail
 
 Example:
 
@@ -72,9 +75,13 @@ Example:
 	#address-cells = <1>;
 	#size-cells = <0>;
 
-	hub@1 {		/* hub connected to port 1 */
+	genesys: hub@1 {	/* hub connected to port 1 */
 		compatible = "usb5e3,608";
 		reg = <1>;
+
+		clocks = <&clks IMX6SX_CLK_CKO>;
+		reset-gpios = <&gpio4 5 GPIO_ACTIVE_LOW>; /* hub reset pin */
+		reset-duration-us = <10>;
 	};
 
 	device@2 {	/* device connected to port 2 */
diff --git a/Documentation/power/power-sequence/design.rst b/Documentation/power/power-sequence/design.rst
new file mode 100644
index 000000000000..554608e5f3b6
--- /dev/null
+++ b/Documentation/power/power-sequence/design.rst
@@ -0,0 +1,54 @@
+====================================
+Power Sequence Library
+====================================
+
+:Date: Feb, 2017
+:Author: Peter Chen <peter.chen@nxp.com>
+
+
+Introduction
+============
+
+We have an well-known problem that the device needs to do a power
+sequence before it can be recognized by related host, the typical
+examples are hard-wired mmc devices and usb devices. The host controller
+can't know what kinds of this device is in its bus if the power
+sequence has not done, since the related devices driver's probe calling
+is determined by runtime according to eunumeration results. Besides,
+the devices may have custom power sequence, so the power sequence library
+which is independent with the devices is needed.
+
+Design
+============
+
+The power sequence library includes the core file and customer power
+sequence library. The core file exports interfaces are called by
+host controller driver for power sequence and customer power sequence
+library files to register its power sequence instance to global
+power sequence list. The custom power sequence library creates power
+sequence instance and implement custom power sequence.
+
+Since the power sequence describes hardware design, the description is
+located at board description file, eg, device tree dts file. And
+a specific power sequence belongs to device, so its description
+is under the device node, please refer to:
+Documentation/devicetree/bindings/power/pwrseq/pwrseq-generic.txt
+
+Custom power sequence library allocates one power sequence instance at
+bootup periods using postcore_initcall, this static allocated instance is
+used to compare with device-tree (DT) node to see if this library can be
+used for the node or not. When the result is matched, the core API will
+try to get resourses (->get, implemented at each library) for power
+sequence, if all resources are got, it will try to allocate another
+instance for next possible request from host driver.
+
+Then, the host controller driver can carry out power sequence on for this
+DT node, the library will do corresponding operations, like open clocks,
+toggle gpio, etc. The power sequence off routine will close and free the
+resources, and is called when the parent is removed. And the power
+sequence suspend and resume routine can be called at host driver's
+suspend and resume routine if needed.
+
+The exported interfaces
+.. kernel-doc:: drivers/power/pwrseq/core.c
+   :export:
diff --git a/MAINTAINERS b/MAINTAINERS
index 867157311dc8..29fc387d0f72 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -13890,6 +13890,15 @@ F:	drivers/firmware/psci/
 F:	include/linux/psci.h
 F:	include/uapi/linux/psci.h
 
+POWER SEQUENCE LIBRARY
+M:	Peter Chen <Peter.Chen@nxp.com>
+T:	git git://git.kernel.org/pub/scm/linux/kernel/git/peter.chen/usb.git
+L:	linux-pm@vger.kernel.org
+S:	Maintained
+F:	Documentation/devicetree/bindings/power/pwrseq/
+F:	drivers/power/pwrseq/
+F:	include/linux/power/pwrseq.h
+
 POWER SUPPLY CLASS/SUBSYSTEM and DRIVERS
 M:	Sebastian Reichel <sre@kernel.org>
 L:	linux-pm@vger.kernel.org
diff --git a/arch/arm/boot/Makefile b/arch/arm/boot/Makefile
index 0b3cd7a33a26..87a8b8db3411 100644
--- a/arch/arm/boot/Makefile
+++ b/arch/arm/boot/Makefile
@@ -29,6 +29,10 @@ export ZRELADDR INITRD_PHYS PARAMS_PHYS
 
 targets := Image zImage xipImage bootpImage uImage
 
+ifeq ($(CONFIG_OF_OVERLAY),y)
+DTC_FLAGS += -@
+endif
+
 ifeq ($(CONFIG_XIP_KERNEL),y)
 
 cmd_deflate_xip_data = $(CONFIG_SHELL) -c \
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 4572db3fa5ae..f5fe7b7cd4c2 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -1,4 +1,9 @@
 # SPDX-License-Identifier: GPL-2.0
+
+ifeq ($(CONFIG_OF_OVERLAY),y)
+DTC_FLAGS += -@
+endif
+
 dtb-$(CONFIG_ARCH_ALPINE) += \
 	alpine-db.dtb
 dtb-$(CONFIG_MACH_ARTPEC6) += \
diff --git a/arch/arm/boot/dts/imx6q-evi.dts b/arch/arm/boot/dts/imx6q-evi.dts
index c63f371ede8b..546d9d4e8ca1 100644
--- a/arch/arm/boot/dts/imx6q-evi.dts
+++ b/arch/arm/boot/dts/imx6q-evi.dts
@@ -55,18 +55,6 @@ memory@10000000 {
 		reg = <0x10000000 0x40000000>;
 	};
 
-	reg_usbh1_vbus: regulator-usbhubreset {
-		compatible = "regulator-fixed";
-		regulator-name = "usbh1_vbus";
-		regulator-min-microvolt = <5000000>;
-		regulator-max-microvolt = <5000000>;
-		enable-active-high;
-		startup-delay-us = <2>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_usbh1_hubreset>;
-		gpio = <&gpio7 12 GPIO_ACTIVE_HIGH>;
-	};
-
 	reg_usb_otg_vbus: regulator-usbotgvbus {
 		compatible = "regulator-fixed";
 		regulator-name = "usb_otg_vbus";
@@ -214,12 +202,18 @@ &uart2 {
 };
 
 &usbh1 {
-	vbus-supply = <&reg_usbh1_vbus>;
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_usbh1>;
 	dr_mode = "host";
 	disable-over-current;
 	status = "okay";
+
+	usb2415host: hub@1 {
+		compatible = "usb424,2513";
+		reg = <1>;
+		reset-gpios = <&gpio7 12 GPIO_ACTIVE_LOW>;
+		reset-duration-us = <3000>;
+	};
 };
 
 &usbotg {
@@ -482,11 +476,6 @@ pinctrl_usbh1: usbh1grp {
 			MX6QDL_PAD_GPIO_3__USB_H1_OC 0x1b0b0
 			/* usbh1_b OC */
 			MX6QDL_PAD_GPIO_0__GPIO1_IO00 0x1b0b0
-		>;
-	};
-
-	pinctrl_usbh1_hubreset: usbh1hubresetgrp {
-		fsl,pins = <
 			MX6QDL_PAD_GPIO_17__GPIO7_IO12 0x1b0b0
 		>;
 	};
diff --git a/arch/arm/boot/dts/imx6qdl-udoo.dtsi b/arch/arm/boot/dts/imx6qdl-udoo.dtsi
index 828dd20cd27d..a6cf7c92548d 100644
--- a/arch/arm/boot/dts/imx6qdl-udoo.dtsi
+++ b/arch/arm/boot/dts/imx6qdl-udoo.dtsi
@@ -5,6 +5,8 @@
  * Author: Fabio Estevam <fabio.estevam@freescale.com>
  */
 
+#include <dt-bindings/gpio/gpio.h>
+
 / {
 	aliases {
 		backlight = &backlight;
@@ -62,17 +64,6 @@ regulators {
 		#address-cells = <1>;
 		#size-cells = <0>;
 
-		reg_usb_h1_vbus: regulator@0 {
-			compatible = "regulator-fixed";
-			reg = <0>;
-			regulator-name = "usb_h1_vbus";
-			regulator-min-microvolt = <5000000>;
-			regulator-max-microvolt = <5000000>;
-			enable-active-high;
-			startup-delay-us = <2>; /* USB2415 requires a POR of 1 us minimum */
-			gpio = <&gpio7 12 0>;
-		};
-
 		reg_panel: regulator@1 {
 			compatible = "regulator-fixed";
 			reg = <1>;
@@ -93,6 +84,17 @@ sound {
 		mux-int-port = <1>;
 		mux-ext-port = <6>;
 	};
+
+	udoo_ard: udoo_ard_manager {
+		compatible = "udoo,imx6q-udoo-ard";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_udooard>;
+		bossac-clk-gpio   = <&gpio6 3 0>;
+		bossac-dat-gpio   = <&gpio5 18 0>;
+		bossac-erase-gpio = <&gpio4 21 0>;
+		bossac-reset-gpio = <&gpio1 0 0>;
+		status = "okay";
+	};
 };
 
 &fec {
@@ -205,7 +207,7 @@ MX6QDL_PAD_KEY_ROW0__UART4_RX_DATA	0x1b0b1
 
 		pinctrl_usbh: usbhgrp {
 			fsl,pins = <
-				MX6QDL_PAD_GPIO_17__GPIO7_IO12 0x80000000
+				MX6QDL_PAD_GPIO_17__GPIO7_IO12	0x1b0b0
 				MX6QDL_PAD_NANDF_CS2__CCM_CLKO2 0x130b0
 			>;
 		};
@@ -218,6 +220,15 @@ MX6QDL_PAD_EIM_D21__USB_OTG_OC 0x17059
 			>;
 		};
 
+		pinctrl_udooard: udooardgrp {
+			fsl,pins = <
+			MX6QDL_PAD_DISP0_DAT0__GPIO4_IO21       0x80000000
+			MX6QDL_PAD_CSI0_DAT17__GPIO6_IO03       0x80000000
+			MX6QDL_PAD_CSI0_PIXCLK__GPIO5_IO18      0x80000000
+			MX6QDL_PAD_GPIO_0__GPIO1_IO00           0x80000000
+			>;
+		};
+
 		pinctrl_usdhc3: usdhc3grp {
 			fsl,pins = <
 				MX6QDL_PAD_SD3_CMD__SD3_CMD		0x17059
@@ -290,9 +301,16 @@ &uart4 {
 &usbh1 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_usbh>;
-	vbus-supply = <&reg_usb_h1_vbus>;
-	clocks = <&clks IMX6QDL_CLK_CKO>;
 	status = "okay";
+
+	usb2415: hub@1 {
+		compatible = "usb424,2514";
+		reg = <1>;
+
+		clocks = <&clks IMX6QDL_CLK_CKO>;
+		reset-gpios = <&gpio7 12 GPIO_ACTIVE_LOW>;
+		reset-duration-us = <3000>;
+	};
 };
 
 &usbotg {
diff --git a/arch/arm/boot/dts/imx6qdl-wandboard-revb1.dtsi b/arch/arm/boot/dts/imx6qdl-wandboard-revb1.dtsi
index e781a45785ed..68daf5570ef2 100644
--- a/arch/arm/boot/dts/imx6qdl-wandboard-revb1.dtsi
+++ b/arch/arm/boot/dts/imx6qdl-wandboard-revb1.dtsi
@@ -6,6 +6,24 @@
 
 #include "imx6qdl-wandboard.dtsi"
 
+/ {
+	rfkill {
+		compatible = "wand,imx6qdl-wandboard-rfkill";
+		pinctrl-names = "default";
+		pinctrl-0 = <>;
+
+		bluetooth-on = <&gpio3 13 0>;
+		bluetooth-wake = <&gpio3 14 0>;
+		bluetooth-host-wake = <&gpio3 15 0>;
+
+		wifi-ref-on = <&gpio2 29 0>;
+		wifi-rst-n = <&gpio5 2 0>;
+		wifi-reg-on = <&gpio1 26 0>;
+		wifi-host-wake = <&gpio1 29 0>;
+		wifi-wake = <&gpio1 30 0>;
+	};
+};
+
 &iomuxc {
 	pinctrl-0 = <&pinctrl_hog>;
 
@@ -31,6 +49,5 @@ MX6QDL_PAD_EIM_DA15__GPIO3_IO15		0x80000000	/* BT_HOST_WAKE */
 &usdhc2 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_usdhc2>;
-	non-removable;
 	status = "okay";
 };
diff --git a/arch/arm/boot/dts/imx6qdl-wandboard-revc1.dtsi b/arch/arm/boot/dts/imx6qdl-wandboard-revc1.dtsi
index 3874e74703f0..be5445d3fe99 100644
--- a/arch/arm/boot/dts/imx6qdl-wandboard-revc1.dtsi
+++ b/arch/arm/boot/dts/imx6qdl-wandboard-revc1.dtsi
@@ -6,6 +6,24 @@
 
 #include "imx6qdl-wandboard.dtsi"
 
+/ {
+	rfkill {
+		compatible = "wand,imx6qdl-wandboard-rfkill";
+		pinctrl-names = "default";
+		pinctrl-0 = <>;
+
+		bluetooth-on = <&gpio5 21 0>;
+		bluetooth-wake = <&gpio5 30 0>;
+		bluetooth-host-wake = <&gpio5 20 0>;
+
+		wifi-ref-on = <&gpio5 31 0>; /* Wifi Power Enable */
+		wifi-rst-n = <&gpio6 0 0>; /* WIFI_ON reset */
+		wifi-reg-on = <&gpio1 26 0>; /* WL_REG_ON */
+		wifi-host-wake = <&gpio1 29 0>; /* WL_HOST_WAKE */
+		wifi-wake = <&gpio1 30 0>; /* WL_WAKE */
+	};
+};
+
 &iomuxc {
 	pinctrl-0 = <&pinctrl_hog>;
 
diff --git a/arch/arm/boot/dts/imx6qdl-wandboard-revd1.dtsi b/arch/arm/boot/dts/imx6qdl-wandboard-revd1.dtsi
index 93909796885a..d595f4e2358d 100644
--- a/arch/arm/boot/dts/imx6qdl-wandboard-revd1.dtsi
+++ b/arch/arm/boot/dts/imx6qdl-wandboard-revd1.dtsi
@@ -7,6 +7,26 @@
 #include "imx6qdl-wandboard.dtsi"
 
 / {
+	rfkill {
+		compatible = "wand,imx6qdl-wandboard-rfkill";
+		pinctrl-names = "default";
+		pinctrl-0 = <>;
+
+		bluetooth-on = <&gpio5 30 0>;		/* BT_RST_N */
+		bluetooth-wake = <&gpio5 21 0>;		/* BT_WAKE */
+		bluetooth-host-wake = <&gpio5 20 0>;	/* BT_HOST_WAKE */
+
+		wifi-ref-on = <&gpio6 0 0>;		/* WIFI_ON: M4: CSI0_DAT14 */
+		wifi-reg-on = <&gpio1 26 0>;		/* WL_REG_ON: W22: ENET_RXD1 */
+		wifi-host-wake = <&gpio1 29 0>;		/* WL_HOST_WAKE: W20: ENET_TXD1 */
+
+		//HACK: use un-populated pins for missing rfkill pins, dont want to fix the driver...
+		//GPIO6_IO17 - SD3_DAT7
+		//GPIO6_IO18 - SD3_DAT6
+		wifi-rst-n = <&gpio6 17 0>;	/* NOT POPULATED */
+		wifi-wake = <&gpio6 18 0>;	/* NOT POPULATED */
+	};
+
 	reg_eth_phy: regulator-eth-phy {
 		compatible = "regulator-fixed";
 		regulator-name = "ETH_PHY";
diff --git a/arch/arm/boot/dts/imx6qdl.dtsi b/arch/arm/boot/dts/imx6qdl.dtsi
index 43edbf1156c7..b7e1e6291923 100644
--- a/arch/arm/boot/dts/imx6qdl.dtsi
+++ b/arch/arm/boot/dts/imx6qdl.dtsi
@@ -986,6 +986,8 @@ usbotg: usb@2184000 {
 
 			usbh1: usb@2184200 {
 				compatible = "fsl,imx6q-usb", "fsl,imx27-usb";
+				#address-cells = <1>;
+				#size-cells = <0>;
 				reg = <0x02184200 0x200>;
 				interrupts = <0 40 IRQ_TYPE_LEVEL_HIGH>;
 				clocks = <&clks IMX6QDL_CLK_USBOH3>;
@@ -1000,6 +1002,8 @@ usbh1: usb@2184200 {
 
 			usbh2: usb@2184400 {
 				compatible = "fsl,imx6q-usb", "fsl,imx27-usb";
+				#address-cells = <1>;
+				#size-cells = <0>;
 				reg = <0x02184400 0x200>;
 				interrupts = <0 41 IRQ_TYPE_LEVEL_HIGH>;
 				clocks = <&clks IMX6QDL_CLK_USBOH3>;
@@ -1015,6 +1019,8 @@ usbh2: usb@2184400 {
 
 			usbh3: usb@2184600 {
 				compatible = "fsl,imx6q-usb", "fsl,imx27-usb";
+				#address-cells = <1>;
+				#size-cells = <0>;
 				reg = <0x02184600 0x200>;
 				interrupts = <0 42 IRQ_TYPE_LEVEL_HIGH>;
 				clocks = <&clks IMX6QDL_CLK_USBOH3>;
diff --git a/arch/arm/boot/dts/imx7d-pico-pi.dts b/arch/arm/boot/dts/imx7d-pico-pi.dts
index 70bea95c06d8..a50edba80c3c 100644
--- a/arch/arm/boot/dts/imx7d-pico-pi.dts
+++ b/arch/arm/boot/dts/imx7d-pico-pi.dts
@@ -8,6 +8,10 @@ / {
 	model = "TechNexion PICO-IMX7D Board and PI baseboard";
 	compatible = "technexion,imx7d-pico-pi", "fsl,imx7d";
 
+	chosen {
+		stdout-path = "serial4:115200n8";
+	};
+
 	leds {
 		compatible = "gpio-leds";
 		pinctrl-names = "default";
diff --git a/arch/arm/configs/rcn-ee_defconfig b/arch/arm/configs/rcn-ee_defconfig
new file mode 100644
index 000000000000..1b0c7749dfff
--- /dev/null
+++ b/arch/arm/configs/rcn-ee_defconfig
@@ -0,0 +1,2788 @@
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_KERNEL_LZO=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_PSI=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_IKHEADERS=m
+CONFIG_MEMCG=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_RDMA=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_BPF=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_SYSFS_SYSCALL is not set
+CONFIG_BPF_SYSCALL=y
+CONFIG_USERFAULTFD=y
+CONFIG_EMBEDDED=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB_FREELIST_RANDOM=y
+CONFIG_SLAB_FREELIST_HARDENED=y
+CONFIG_PROFILING=y
+CONFIG_ARCH_MXC=y
+CONFIG_SOC_IMX50=y
+CONFIG_SOC_IMX51=y
+CONFIG_SOC_IMX53=y
+CONFIG_SOC_IMX6Q=y
+CONFIG_SOC_IMX6SL=y
+CONFIG_SOC_IMX6SLL=y
+CONFIG_SOC_IMX6SX=y
+CONFIG_SOC_IMX6UL=y
+CONFIG_WAND_RFKILL=y
+CONFIG_POWER_AVS_OMAP=y
+CONFIG_POWER_AVS_OMAP_CLASS3=y
+CONFIG_OMAP_RESET_CLOCKS=y
+CONFIG_ARCH_OMAP3=y
+CONFIG_ARCH_OMAP4=y
+CONFIG_SOC_OMAP5=y
+CONFIG_SOC_AM33XX=y
+CONFIG_SOC_AM43XX=y
+CONFIG_SOC_DRA7XX=y
+# CONFIG_MACH_OMAP3517EVM is not set
+# CONFIG_MACH_OMAP3_PANDORA is not set
+CONFIG_OMAP5_ERRATA_801819=y
+CONFIG_ARCH_SUNXI=y
+CONFIG_ARM_THUMBEE=y
+CONFIG_PL310_ERRATA_753970=y
+CONFIG_ARM_ERRATA_754327=y
+CONFIG_ARM_ERRATA_773022=y
+CONFIG_SMP=y
+CONFIG_MCPM=y
+CONFIG_NR_CPUS=8
+CONFIG_HZ_250=y
+CONFIG_THUMB2_KERNEL=y
+CONFIG_SECCOMP=y
+# CONFIG_ATAGS is not set
+CONFIG_EFI=y
+# CONFIG_DMI is not set
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=m
+CONFIG_CPU_FREQ_GOV_USERSPACE=m
+CONFIG_CPU_FREQ_GOV_ONDEMAND=m
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
+CONFIG_CPUFREQ_DT=y
+CONFIG_ARM_IMX6Q_CPUFREQ=y
+# CONFIG_ARM_OMAP2PLUS_CPUFREQ is not set
+CONFIG_CPU_IDLE=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+CONFIG_KERNEL_MODE_NEON=y
+CONFIG_HIBERNATION=y
+CONFIG_PM_AUTOSLEEP=y
+CONFIG_PM_WAKELOCKS=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+CONFIG_APM_EMULATION=y
+CONFIG_ENERGY_MODEL=y
+CONFIG_CRYPTO_SHA1_ARM_NEON=m
+CONFIG_CRYPTO_SHA256_ARM=m
+CONFIG_CRYPTO_SHA512_ARM=m
+CONFIG_CRYPTO_AES_ARM=m
+CONFIG_CRYPTO_AES_ARM_BS=m
+CONFIG_CRYPTO_NHPOLY1305_NEON=m
+CONFIG_OPROFILE=m
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_COMPRESS=y
+CONFIG_MODULE_COMPRESS_XZ=y
+CONFIG_BLK_DEV_ZONED=y
+CONFIG_BLK_DEV_THROTTLING=y
+CONFIG_BLK_WBT=y
+CONFIG_BLK_SED_OPAL=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_MQ_IOSCHED_KYBER=m
+CONFIG_IOSCHED_BFQ=m
+CONFIG_BFQ_GROUP_IOSCHED=y
+CONFIG_BINFMT_MISC=m
+CONFIG_KSM=y
+CONFIG_FRONTSWAP=y
+CONFIG_ZSWAP=y
+CONFIG_Z3FOLD=m
+CONFIG_ZSMALLOC=m
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=m
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=m
+CONFIG_XFRM_USER=m
+CONFIG_XFRM_INTERFACE=m
+CONFIG_XFRM_SUB_POLICY=y
+CONFIG_XFRM_STATISTICS=y
+CONFIG_NET_KEY=m
+CONFIG_NET_KEY_MIGRATE=y
+CONFIG_XDP_SOCKETS=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_FIB_TRIE_STATS=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE_DEMUX=m
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_NET_IPVTI=m
+CONFIG_NET_FOU_IP_TUNNELS=y
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_ESP_OFFLOAD=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_DIAG=m
+CONFIG_INET_UDP_DIAG=m
+CONFIG_INET_RAW_DIAG=m
+CONFIG_INET_DIAG_DESTROY=y
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_TCP_CONG_HSTCP=m
+CONFIG_TCP_CONG_HYBLA=m
+CONFIG_TCP_CONG_NV=m
+CONFIG_TCP_CONG_SCALABLE=m
+CONFIG_TCP_CONG_LP=m
+CONFIG_TCP_CONG_VENO=m
+CONFIG_TCP_CONG_YEAH=m
+CONFIG_TCP_CONG_ILLINOIS=m
+CONFIG_TCP_CONG_DCTCP=m
+CONFIG_TCP_CONG_CDG=m
+CONFIG_TCP_CONG_BBR=m
+CONFIG_TCP_MD5SIG=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_ESP_OFFLOAD=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_IPV6_MIP6=y
+CONFIG_IPV6_ILA=m
+CONFIG_IPV6_VTI=m
+CONFIG_IPV6_SIT=m
+CONFIG_IPV6_SIT_6RD=y
+CONFIG_IPV6_GRE=m
+CONFIG_IPV6_SUBTREES=y
+CONFIG_IPV6_MROUTE=y
+CONFIG_IPV6_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IPV6_PIMSM_V2=y
+CONFIG_IPV6_SEG6_LWTUNNEL=y
+CONFIG_IPV6_SEG6_HMAC=y
+CONFIG_NETLABEL=y
+CONFIG_NETFILTER=y
+CONFIG_BRIDGE_NETFILTER=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_LOG_NETDEV=m
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_ZONES=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CONNTRACK_TIMEOUT=y
+CONFIG_NF_CONNTRACK_TIMESTAMP=y
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+CONFIG_NF_CONNTRACK_SNMP=m
+CONFIG_NF_CONNTRACK_PPTP=m
+CONFIG_NF_CONNTRACK_SANE=m
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NF_CT_NETLINK_TIMEOUT=m
+CONFIG_NF_CT_NETLINK_HELPER=m
+CONFIG_NETFILTER_NETLINK_GLUE_CT=y
+CONFIG_NF_TABLES=m
+CONFIG_NF_TABLES_INET=y
+CONFIG_NF_TABLES_NETDEV=y
+CONFIG_NFT_NUMGEN=m
+CONFIG_NFT_CT=m
+CONFIG_NFT_FLOW_OFFLOAD=m
+CONFIG_NFT_COUNTER=m
+CONFIG_NFT_CONNLIMIT=m
+CONFIG_NFT_LOG=m
+CONFIG_NFT_LIMIT=m
+CONFIG_NFT_MASQ=m
+CONFIG_NFT_REDIR=m
+CONFIG_NFT_NAT=m
+CONFIG_NFT_TUNNEL=m
+CONFIG_NFT_OBJREF=m
+CONFIG_NFT_QUEUE=m
+CONFIG_NFT_QUOTA=m
+CONFIG_NFT_REJECT=m
+CONFIG_NFT_COMPAT=m
+CONFIG_NFT_HASH=m
+CONFIG_NFT_FIB_INET=m
+CONFIG_NFT_SOCKET=m
+CONFIG_NFT_OSF=m
+CONFIG_NFT_TPROXY=m
+CONFIG_NFT_DUP_NETDEV=m
+CONFIG_NFT_FWD_NETDEV=m
+CONFIG_NFT_FIB_NETDEV=m
+CONFIG_NF_FLOW_TABLE_INET=m
+CONFIG_NF_FLOW_TABLE=m
+CONFIG_NETFILTER_XT_SET=m
+CONFIG_NETFILTER_XT_TARGET_AUDIT=m
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=m
+CONFIG_NETFILTER_XT_TARGET_CT=m
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_NETFILTER_XT_TARGET_HMARK=m
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=m
+CONFIG_NETFILTER_XT_TARGET_LED=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NETFILTER_XT_TARGET_TEE=m
+CONFIG_NETFILTER_XT_TARGET_TPROXY=m
+CONFIG_NETFILTER_XT_TARGET_TRACE=m
+CONFIG_NETFILTER_XT_TARGET_SECMARK=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=m
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_BPF=m
+CONFIG_NETFILTER_XT_MATCH_CGROUP=m
+CONFIG_NETFILTER_XT_MATCH_CLUSTER=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNLABEL=m
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_CPU=m
+CONFIG_NETFILTER_XT_MATCH_DEVGROUP=m
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_IPCOMP=m
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+CONFIG_NETFILTER_XT_MATCH_IPVS=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_NFACCT=m
+CONFIG_NETFILTER_XT_MATCH_OSF=m
+CONFIG_NETFILTER_XT_MATCH_OWNER=m
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+CONFIG_NETFILTER_XT_MATCH_PHYSDEV=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_RATEEST=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+CONFIG_NETFILTER_XT_MATCH_SOCKET=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NETFILTER_XT_MATCH_U32=m
+CONFIG_IP_SET=m
+CONFIG_IP_SET_BITMAP_IP=m
+CONFIG_IP_SET_BITMAP_IPMAC=m
+CONFIG_IP_SET_BITMAP_PORT=m
+CONFIG_IP_SET_HASH_IP=m
+CONFIG_IP_SET_HASH_IPMARK=m
+CONFIG_IP_SET_HASH_IPPORT=m
+CONFIG_IP_SET_HASH_IPPORTIP=m
+CONFIG_IP_SET_HASH_IPPORTNET=m
+CONFIG_IP_SET_HASH_IPMAC=m
+CONFIG_IP_SET_HASH_MAC=m
+CONFIG_IP_SET_HASH_NETPORTNET=m
+CONFIG_IP_SET_HASH_NET=m
+CONFIG_IP_SET_HASH_NETNET=m
+CONFIG_IP_SET_HASH_NETPORT=m
+CONFIG_IP_SET_HASH_NETIFACE=m
+CONFIG_IP_SET_LIST_SET=m
+CONFIG_IP_VS=m
+CONFIG_IP_VS_IPV6=y
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_PROTO_ESP=y
+CONFIG_IP_VS_PROTO_AH=y
+CONFIG_IP_VS_PROTO_SCTP=y
+CONFIG_IP_VS_RR=m
+CONFIG_IP_VS_WRR=m
+CONFIG_IP_VS_LC=m
+CONFIG_IP_VS_WLC=m
+CONFIG_IP_VS_FO=m
+CONFIG_IP_VS_OVF=m
+CONFIG_IP_VS_LBLC=m
+CONFIG_IP_VS_LBLCR=m
+CONFIG_IP_VS_DH=m
+CONFIG_IP_VS_SH=m
+CONFIG_IP_VS_MH=m
+CONFIG_IP_VS_SED=m
+CONFIG_IP_VS_NQ=m
+CONFIG_IP_VS_FTP=m
+CONFIG_IP_VS_PE_SIP=m
+CONFIG_NFT_DUP_IPV4=m
+CONFIG_NFT_FIB_IPV4=m
+CONFIG_NF_TABLES_ARP=y
+CONFIG_NF_FLOW_TABLE_IPV4=m
+CONFIG_NF_LOG_ARP=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_RPFILTER=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_SYNPROXY=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_SECURITY=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+CONFIG_NFT_DUP_IPV6=m
+CONFIG_NFT_FIB_IPV6=m
+CONFIG_NF_FLOW_TABLE_IPV6=m
+CONFIG_IP6_NF_MATCH_AH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_MH=m
+CONFIG_IP6_NF_MATCH_RPFILTER=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_TARGET_SYNPROXY=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_IP6_NF_SECURITY=m
+CONFIG_IP6_NF_NAT=m
+CONFIG_IP6_NF_TARGET_MASQUERADE=m
+CONFIG_IP6_NF_TARGET_NPT=m
+CONFIG_NF_TABLES_BRIDGE=m
+CONFIG_NFT_BRIDGE_REJECT=m
+CONFIG_NF_LOG_BRIDGE=m
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_BRIDGE_EBT_BROUTE=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_BRIDGE_EBT_T_NAT=m
+CONFIG_BRIDGE_EBT_802_3=m
+CONFIG_BRIDGE_EBT_AMONG=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_BRIDGE_EBT_IP=m
+CONFIG_BRIDGE_EBT_IP6=m
+CONFIG_BRIDGE_EBT_LIMIT=m
+CONFIG_BRIDGE_EBT_MARK=m
+CONFIG_BRIDGE_EBT_PKTTYPE=m
+CONFIG_BRIDGE_EBT_STP=m
+CONFIG_BRIDGE_EBT_VLAN=m
+CONFIG_BRIDGE_EBT_ARPREPLY=m
+CONFIG_BRIDGE_EBT_DNAT=m
+CONFIG_BRIDGE_EBT_MARK_T=m
+CONFIG_BRIDGE_EBT_REDIRECT=m
+CONFIG_BRIDGE_EBT_SNAT=m
+CONFIG_BRIDGE_EBT_LOG=m
+CONFIG_BRIDGE_EBT_NFLOG=m
+CONFIG_IP_DCCP=m
+CONFIG_SCTP_COOKIE_HMAC_SHA1=y
+CONFIG_RDS=m
+CONFIG_RDS_TCP=m
+CONFIG_TIPC=m
+CONFIG_ATM=m
+CONFIG_ATM_CLIP=m
+CONFIG_ATM_LANE=m
+CONFIG_ATM_MPOA=m
+CONFIG_ATM_BR2684=m
+CONFIG_L2TP=m
+CONFIG_L2TP_DEBUGFS=m
+CONFIG_L2TP_V3=y
+CONFIG_L2TP_IP=m
+CONFIG_L2TP_ETH=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_VLAN_FILTERING=y
+CONFIG_VLAN_8021Q=m
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_VLAN_8021Q_MVRP=y
+CONFIG_LLC2=m
+CONFIG_ATALK=m
+CONFIG_DEV_APPLETALK=m
+CONFIG_IPDDP=m
+CONFIG_IPDDP_ENCAP=y
+CONFIG_PHONET=m
+CONFIG_6LOWPAN=m
+CONFIG_6LOWPAN_GHC_EXT_HDR_HOP=m
+CONFIG_6LOWPAN_GHC_UDP=m
+CONFIG_6LOWPAN_GHC_ICMPV6=m
+CONFIG_6LOWPAN_GHC_EXT_HDR_DEST=m
+CONFIG_6LOWPAN_GHC_EXT_HDR_FRAG=m
+CONFIG_6LOWPAN_GHC_EXT_HDR_ROUTE=m
+CONFIG_IEEE802154=m
+CONFIG_IEEE802154_6LOWPAN=m
+CONFIG_MAC802154=m
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_ATM=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_MULTIQ=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFB=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_CBS=m
+CONFIG_NET_SCH_ETF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_DRR=m
+CONFIG_NET_SCH_MQPRIO=m
+CONFIG_NET_SCH_SKBPRIO=m
+CONFIG_NET_SCH_CHOKE=m
+CONFIG_NET_SCH_QFQ=m
+CONFIG_NET_SCH_CODEL=m
+CONFIG_NET_SCH_FQ_CODEL=m
+CONFIG_NET_SCH_CAKE=m
+CONFIG_NET_SCH_FQ=m
+CONFIG_NET_SCH_HHF=m
+CONFIG_NET_SCH_PIE=m
+CONFIG_NET_SCH_INGRESS=m
+CONFIG_NET_SCH_PLUG=m
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+CONFIG_CLS_U32_PERF=y
+CONFIG_CLS_U32_MARK=y
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+CONFIG_NET_CLS_FLOW=m
+CONFIG_NET_CLS_CGROUP=m
+CONFIG_NET_CLS_BPF=m
+CONFIG_NET_CLS_FLOWER=m
+CONFIG_NET_CLS_MATCHALL=m
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_CMP=m
+CONFIG_NET_EMATCH_NBYTE=m
+CONFIG_NET_EMATCH_U32=m
+CONFIG_NET_EMATCH_META=m
+CONFIG_NET_EMATCH_TEXT=m
+CONFIG_NET_EMATCH_CANID=m
+CONFIG_NET_EMATCH_IPSET=m
+CONFIG_NET_EMATCH_IPT=m
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=m
+CONFIG_NET_ACT_GACT=m
+CONFIG_GACT_PROB=y
+CONFIG_NET_ACT_MIRRED=m
+CONFIG_NET_ACT_SAMPLE=m
+CONFIG_NET_ACT_IPT=m
+CONFIG_NET_ACT_NAT=m
+CONFIG_NET_ACT_PEDIT=m
+CONFIG_NET_ACT_SIMP=m
+CONFIG_NET_ACT_SKBEDIT=m
+CONFIG_NET_ACT_CSUM=m
+CONFIG_NET_ACT_VLAN=m
+CONFIG_NET_ACT_BPF=m
+CONFIG_NET_ACT_CONNMARK=m
+CONFIG_NET_ACT_SKBMOD=m
+CONFIG_NET_ACT_IFE=m
+CONFIG_NET_ACT_TUNNEL_KEY=m
+CONFIG_NET_IFE_SKBMARK=m
+CONFIG_NET_IFE_SKBPRIO=m
+CONFIG_NET_IFE_SKBTCINDEX=m
+CONFIG_DCB=y
+CONFIG_BATMAN_ADV=m
+# CONFIG_BATMAN_ADV_BATMAN_V is not set
+CONFIG_BATMAN_ADV_NC=y
+CONFIG_BATMAN_ADV_DEBUGFS=y
+CONFIG_BATMAN_ADV_SYSFS=y
+CONFIG_OPENVSWITCH=m
+CONFIG_VSOCKETS=m
+CONFIG_VIRTIO_VSOCKETS=m
+CONFIG_NETLINK_DIAG=m
+CONFIG_NET_MPLS_GSO=y
+CONFIG_MPLS_ROUTING=m
+CONFIG_MPLS_IPTUNNEL=m
+CONFIG_NET_SWITCHDEV=y
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_BPF_JIT=y
+CONFIG_BPF_STREAM_PARSER=y
+CONFIG_NET_PKTGEN=m
+CONFIG_NET_DROP_MONITOR=y
+CONFIG_HAMRADIO=y
+CONFIG_AX25=m
+CONFIG_NETROM=m
+CONFIG_ROSE=m
+CONFIG_MKISS=m
+CONFIG_6PACK=m
+CONFIG_BPQETHER=m
+CONFIG_BAYCOM_SER_FDX=m
+CONFIG_BAYCOM_SER_HDX=m
+CONFIG_YAM=m
+CONFIG_CAN=m
+CONFIG_CAN_J1939=m
+CONFIG_CAN_VCAN=m
+CONFIG_CAN_VXCAN=m
+CONFIG_CAN_SLCAN=m
+CONFIG_CAN_FLEXCAN=m
+CONFIG_CAN_SUN4I=m
+CONFIG_CAN_C_CAN=m
+CONFIG_CAN_C_CAN_PLATFORM=m
+CONFIG_CAN_HI311X=m
+CONFIG_CAN_MCP251X=m
+CONFIG_CAN_8DEV_USB=m
+CONFIG_CAN_EMS_USB=m
+CONFIG_CAN_ESD_USB2=m
+CONFIG_CAN_GS_USB=m
+CONFIG_CAN_KVASER_USB=m
+CONFIG_CAN_MCBA_USB=m
+CONFIG_CAN_PEAK_USB=m
+CONFIG_CAN_UCAN=m
+CONFIG_BT=m
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=m
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=m
+CONFIG_BT_6LOWPAN=m
+CONFIG_BT_LEDS=y
+CONFIG_BT_HCIBTUSB=m
+CONFIG_BT_HCIBTSDIO=m
+CONFIG_BT_HCIUART=m
+CONFIG_BT_HCIUART_ATH3K=y
+CONFIG_BT_HCIUART_LL=y
+CONFIG_BT_HCIUART_3WIRE=y
+CONFIG_BT_HCIBCM203X=m
+CONFIG_BT_HCIBPA10X=m
+CONFIG_BT_HCIBFUSB=m
+CONFIG_BT_HCIVHCI=m
+CONFIG_BT_MRVL=m
+CONFIG_BT_MRVL_SDIO=m
+CONFIG_BT_ATH3K=m
+CONFIG_BT_MTKUART=m
+CONFIG_AF_RXRPC_IPV6=y
+CONFIG_RXKAD=y
+CONFIG_CFG80211=m
+# CONFIG_CFG80211_DEFAULT_PS is not set
+CONFIG_CFG80211_WEXT=y
+CONFIG_MAC80211=m
+CONFIG_MAC80211_MESH=y
+CONFIG_WIMAX=m
+CONFIG_RFKILL_INPUT=y
+CONFIG_NET_9P=m
+CONFIG_NET_9P_VIRTIO=m
+CONFIG_NFC=m
+CONFIG_NFC_DIGITAL=m
+CONFIG_NFC_NCI=m
+CONFIG_NFC_TRF7970A=m
+CONFIG_NFC_SIM=m
+CONFIG_NFC_PORT100=m
+CONFIG_NFC_PN533_USB=m
+CONFIG_NFC_PN533_I2C=m
+CONFIG_NFC_ST_NCI_I2C=m
+CONFIG_NFC_ST_NCI_SPI=m
+CONFIG_NFC_NXP_NCI=m
+CONFIG_NFC_NXP_NCI_I2C=m
+CONFIG_NFC_ST95HF=m
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_EXTRA_FIRMWARE="am335x-pm-firmware.elf am335x-bone-scale-data.bin am335x-evm-scale-data.bin am43x-evm-scale-data.bin"
+CONFIG_EXTRA_FIRMWARE_DIR="firmware"
+CONFIG_IMX_WEIM=y
+CONFIG_OMAP_OCP2SCP=y
+CONFIG_SIMPLE_PM_BUS=y
+CONFIG_CONNECTOR=y
+CONFIG_GNSS=m
+CONFIG_GNSS_MTK_SERIAL=m
+CONFIG_GNSS_SIRF_SERIAL=m
+CONFIG_GNSS_UBX_SERIAL=m
+CONFIG_MTD=y
+CONFIG_MTD_AR7_PARTS=m
+CONFIG_MTD_OF_PARTS=m
+CONFIG_MTD_BLOCK=m
+CONFIG_MTD_BLOCK_RO=m
+CONFIG_RFD_FTL=m
+CONFIG_SSFDC=m
+CONFIG_MTD_OOPS=m
+CONFIG_MTD_SWAP=m
+CONFIG_MTD_PHYSMAP=m
+CONFIG_MTD_PLATRAM=m
+CONFIG_MTD_DATAFLASH=m
+CONFIG_MTD_SST25L=m
+CONFIG_MTD_ONENAND=y
+CONFIG_MTD_ONENAND_VERIFY_WRITE=y
+CONFIG_MTD_ONENAND_OMAP2=m
+CONFIG_MTD_ONENAND_2X_PROGRAM=y
+CONFIG_MTD_RAW_NAND=y
+CONFIG_MTD_NAND_ECC_SW_BCH=y
+CONFIG_MTD_NAND_OMAP2=m
+CONFIG_MTD_NAND_GPMI_NAND=m
+CONFIG_MTD_NAND_MXC=m
+CONFIG_MTD_NAND_SUNXI=m
+CONFIG_MTD_NAND_NANDSIM=m
+CONFIG_MTD_LPDDR=m
+CONFIG_MTD_SPI_NOR=m
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_BLOCK=y
+CONFIG_OF_OVERLAY=y
+CONFIG_BLK_DEV_NULL_BLK=m
+CONFIG_ZRAM=m
+CONFIG_ZRAM_WRITEBACK=y
+CONFIG_ZRAM_MEMORY_TRACKING=y
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_DRBD=m
+CONFIG_BLK_DEV_NBD=m
+CONFIG_BLK_DEV_RAM=m
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_ATA_OVER_ETH=m
+CONFIG_VIRTIO_BLK=m
+CONFIG_BLK_DEV_RBD=m
+CONFIG_AD525X_DPOT=m
+CONFIG_AD525X_DPOT_I2C=m
+CONFIG_AD525X_DPOT_SPI=m
+CONFIG_ICS932S401=m
+CONFIG_APDS9802ALS=m
+CONFIG_ISL29003=m
+CONFIG_ISL29020=m
+CONFIG_SENSORS_TSL2550=m
+CONFIG_SENSORS_BH1770=m
+CONFIG_SENSORS_APDS990X=m
+CONFIG_HMC6352=m
+CONFIG_DS1682=m
+CONFIG_UDOO_ARD=m
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_AT25=y
+CONFIG_EEPROM_LEGACY=m
+CONFIG_EEPROM_MAX6875=m
+CONFIG_TI_ST=m
+CONFIG_MIKROBUS=y
+CONFIG_RAID_ATTRS=m
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_ST=m
+CONFIG_BLK_DEV_SR=m
+CONFIG_CHR_DEV_SG=m
+CONFIG_CHR_DEV_SCH=m
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_SCSI_SPI_ATTRS=m
+CONFIG_SCSI_FC_ATTRS=m
+CONFIG_SCSI_SAS_LIBSAS=m
+CONFIG_SCSI_SAS_ATA=y
+CONFIG_SCSI_SRP_ATTRS=m
+CONFIG_ISCSI_TCP=m
+CONFIG_ISCSI_BOOT_SYSFS=m
+CONFIG_SCSI_UFSHCD=m
+CONFIG_LIBFC=m
+CONFIG_LIBFCOE=m
+CONFIG_SCSI_VIRTIO=m
+CONFIG_SCSI_DH=y
+CONFIG_SCSI_DH_RDAC=m
+CONFIG_SCSI_DH_HP_SW=m
+CONFIG_SCSI_DH_EMC=m
+CONFIG_SCSI_DH_ALUA=m
+CONFIG_ATA=y
+# CONFIG_ATA_FORCE is not set
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_AHCI_IMX=y
+CONFIG_AHCI_SUNXI=y
+CONFIG_PATA_IMX=y
+CONFIG_PATA_PLATFORM=y
+CONFIG_PATA_OF_PLATFORM=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=m
+CONFIG_MD_LINEAR=m
+CONFIG_MD_RAID0=m
+CONFIG_MD_RAID1=m
+CONFIG_MD_RAID10=m
+CONFIG_MD_MULTIPATH=m
+CONFIG_MD_FAULTY=m
+CONFIG_BCACHE=m
+CONFIG_BLK_DEV_DM=m
+CONFIG_DM_UNSTRIPED=m
+CONFIG_DM_CRYPT=m
+CONFIG_DM_SNAPSHOT=m
+CONFIG_DM_THIN_PROVISIONING=m
+CONFIG_DM_CACHE=m
+CONFIG_DM_WRITECACHE=m
+CONFIG_DM_ERA=m
+CONFIG_DM_MIRROR=m
+CONFIG_DM_LOG_USERSPACE=m
+CONFIG_DM_ZERO=m
+CONFIG_DM_MULTIPATH=m
+CONFIG_DM_MULTIPATH_QL=m
+CONFIG_DM_MULTIPATH_ST=m
+CONFIG_DM_DELAY=m
+CONFIG_DM_UEVENT=y
+CONFIG_DM_FLAKEY=m
+CONFIG_DM_VERITY=m
+CONFIG_DM_SWITCH=m
+CONFIG_DM_LOG_WRITES=m
+CONFIG_DM_INTEGRITY=m
+CONFIG_DM_ZONED=m
+CONFIG_TARGET_CORE=m
+CONFIG_TCM_IBLOCK=m
+CONFIG_TCM_FILEIO=m
+CONFIG_TCM_PSCSI=m
+CONFIG_TCM_USER2=m
+CONFIG_LOOPBACK_TARGET=m
+CONFIG_TCM_FC=m
+CONFIG_ISCSI_TARGET=m
+CONFIG_NETDEVICES=y
+CONFIG_BONDING=m
+CONFIG_DUMMY=m
+CONFIG_WIREGUARD=m
+CONFIG_EQUALIZER=m
+CONFIG_IFB=m
+CONFIG_NET_TEAM=m
+CONFIG_NET_TEAM_MODE_BROADCAST=m
+CONFIG_NET_TEAM_MODE_ROUNDROBIN=m
+CONFIG_NET_TEAM_MODE_RANDOM=m
+CONFIG_NET_TEAM_MODE_ACTIVEBACKUP=m
+CONFIG_NET_TEAM_MODE_LOADBALANCE=m
+CONFIG_MACVLAN=m
+CONFIG_MACVTAP=m
+CONFIG_IPVLAN=m
+CONFIG_IPVTAP=m
+CONFIG_VXLAN=m
+CONFIG_GENEVE=m
+CONFIG_GTP=m
+CONFIG_MACSEC=m
+CONFIG_NETCONSOLE=m
+CONFIG_NETCONSOLE_DYNAMIC=y
+CONFIG_TUN=m
+CONFIG_VETH=m
+CONFIG_VIRTIO_NET=m
+CONFIG_NLMON=m
+CONFIG_NET_VRF=m
+CONFIG_ATM_DUMMY=m
+# CONFIG_NET_VENDOR_ALACRITECH is not set
+CONFIG_SUN4I_EMAC=y
+# CONFIG_NET_VENDOR_AMAZON is not set
+# CONFIG_NET_VENDOR_AQUANTIA is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_NET_VENDOR_CORTINA is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_GOOGLE is not set
+# CONFIG_NET_VENDOR_HISILICON is not set
+# CONFIG_NET_VENDOR_HUAWEI is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+CONFIG_KS8851=m
+CONFIG_ENC28J60=y
+CONFIG_ENCX24J600=y
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+# CONFIG_NET_VENDOR_NI is not set
+# CONFIG_NET_VENDOR_PENSANDO is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SOLARFLARE is not set
+CONFIG_SMC91X=m
+CONFIG_SMC911X=m
+CONFIG_SMSC911X=m
+# CONFIG_NET_VENDOR_SOCIONEXT is not set
+CONFIG_STMMAC_ETH=y
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+CONFIG_TI_DAVINCI_EMAC=y
+CONFIG_TI_CPSW_PHY_SEL=y
+CONFIG_TI_CPSW=y
+CONFIG_TI_CPTS=y
+# CONFIG_NET_VENDOR_VIA is not set
+CONFIG_WIZNET_W5100=y
+CONFIG_WIZNET_W5100_SPI=y
+# CONFIG_NET_VENDOR_XILINX is not set
+CONFIG_MDIO_BCM_UNIMAC=m
+CONFIG_LED_TRIGGER_PHY=y
+CONFIG_MICREL_PHY=y
+CONFIG_MICROCHIP_PHY=y
+CONFIG_MICROSEMI_PHY=m
+CONFIG_AT803X_PHY=y
+CONFIG_SMSC_PHY=y
+CONFIG_VITESSE_PHY=y
+CONFIG_PPP=m
+CONFIG_PPP_BSDCOMP=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=m
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOATM=m
+CONFIG_PPPOE=m
+CONFIG_PPTP=m
+CONFIG_PPPOL2TP=m
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_SLIP=m
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_SLIP_SMART=y
+CONFIG_SLIP_MODE_SLIP6=y
+CONFIG_USB_NET_DRIVERS=m
+CONFIG_USB_CATC=m
+CONFIG_USB_KAWETH=m
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_RTL8152=m
+CONFIG_USB_LAN78XX=m
+CONFIG_USB_NET_CDC_EEM=m
+CONFIG_USB_NET_HUAWEI_CDC_NCM=m
+CONFIG_USB_NET_CDC_MBIM=m
+CONFIG_USB_NET_DM9601=m
+CONFIG_USB_NET_SR9700=m
+CONFIG_USB_NET_SR9800=m
+CONFIG_USB_NET_SMSC75XX=m
+CONFIG_USB_NET_SMSC95XX=m
+CONFIG_USB_NET_GL620A=m
+CONFIG_USB_NET_PLUSB=m
+CONFIG_USB_NET_MCS7830=m
+CONFIG_USB_ALI_M5632=y
+CONFIG_USB_AN2720=y
+CONFIG_USB_EPSON2888=y
+CONFIG_USB_KC2190=y
+CONFIG_USB_NET_CX82310_ETH=m
+CONFIG_USB_NET_KALMIA=m
+CONFIG_USB_NET_QMI_WWAN=m
+CONFIG_USB_HSO=m
+CONFIG_USB_NET_INT51X1=m
+CONFIG_USB_CDC_PHONET=m
+CONFIG_USB_IPHETH=m
+CONFIG_USB_SIERRA_NET=m
+CONFIG_USB_VL600=m
+CONFIG_USB_NET_CH9200=m
+CONFIG_ATH9K=m
+CONFIG_ATH9K_CHANNEL_CONTEXT=y
+CONFIG_ATH9K_HTC=m
+CONFIG_ATH9K_HWRNG=y
+CONFIG_CARL9170=m
+CONFIG_ATH6KL=m
+CONFIG_ATH6KL_SDIO=m
+CONFIG_ATH6KL_USB=m
+CONFIG_AR5523=m
+CONFIG_ATH10K=m
+CONFIG_ATH10K_USB=m
+CONFIG_AT76C50X_USB=m
+CONFIG_BRCMFMAC=m
+CONFIG_BRCMFMAC_USB=y
+CONFIG_HOSTAP=m
+CONFIG_HOSTAP_FIRMWARE=y
+CONFIG_P54_COMMON=m
+CONFIG_P54_USB=m
+CONFIG_LIBERTAS=m
+CONFIG_LIBERTAS_USB=m
+CONFIG_LIBERTAS_SDIO=m
+CONFIG_LIBERTAS_MESH=y
+CONFIG_LIBERTAS_THINFIRM=m
+CONFIG_LIBERTAS_THINFIRM_USB=m
+CONFIG_MT7601U=m
+CONFIG_MT76x0U=m
+CONFIG_MT76x2U=m
+CONFIG_RT2X00=m
+CONFIG_RT2500USB=m
+CONFIG_RT73USB=m
+CONFIG_RT2800USB=m
+CONFIG_RT2800USB_RT3573=y
+CONFIG_RT2800USB_RT53XX=y
+CONFIG_RT2800USB_RT55XX=y
+CONFIG_RTL8187=m
+CONFIG_RTL8192CU=m
+# CONFIG_RTLWIFI_DEBUG is not set
+CONFIG_RTL8XXXU=m
+CONFIG_RTW88=m
+CONFIG_RSI_91X=m
+# CONFIG_RSI_SDIO is not set
+CONFIG_WL1251=m
+CONFIG_WL1251_SPI=m
+CONFIG_WL1251_SDIO=m
+CONFIG_WL12XX=m
+CONFIG_WL18XX=m
+CONFIG_WLCORE_SPI=m
+CONFIG_WLCORE_SDIO=m
+CONFIG_ZD1211RW=m
+CONFIG_MAC80211_HWSIM=m
+CONFIG_USB_NET_RNDIS_WLAN=m
+CONFIG_WIMAX_I2400M_USB=m
+CONFIG_IEEE802154_AT86RF230=m
+CONFIG_IEEE802154_MRF24J40=m
+CONFIG_IEEE802154_CC2520=m
+CONFIG_IEEE802154_ATUSB=m
+CONFIG_IEEE802154_ADF7242=m
+CONFIG_IEEE802154_CA8210=m
+CONFIG_IEEE802154_MCR20A=m
+CONFIG_IEEE802154_HWSIM=m
+CONFIG_INPUT_POLLDEV=y
+CONFIG_INPUT_SPARSEKMAP=m
+CONFIG_INPUT_JOYDEV=m
+CONFIG_INPUT_EVDEV=m
+CONFIG_KEYBOARD_ADP5588=m
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_QT2160=m
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_LM8323=m
+CONFIG_KEYBOARD_MAX7359=m
+CONFIG_KEYBOARD_IMX=m
+CONFIG_KEYBOARD_STOWAWAY=m
+CONFIG_KEYBOARD_SUN4I_LRADC=m
+# CONFIG_MOUSE_PS2 is not set
+CONFIG_MOUSE_APPLETOUCH=m
+CONFIG_MOUSE_ELAN_I2C=m
+CONFIG_MOUSE_SYNAPTICS_I2C=m
+CONFIG_MOUSE_SYNAPTICS_USB=m
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_IFORCE=m
+CONFIG_JOYSTICK_IFORCE_USB=m
+CONFIG_JOYSTICK_IFORCE_232=m
+CONFIG_JOYSTICK_WARRIOR=m
+CONFIG_JOYSTICK_MAGELLAN=m
+CONFIG_JOYSTICK_SPACEORB=m
+CONFIG_JOYSTICK_SPACEBALL=m
+CONFIG_JOYSTICK_STINGER=m
+CONFIG_JOYSTICK_TWIDJOY=m
+CONFIG_JOYSTICK_ZHENHUA=m
+CONFIG_JOYSTICK_AS5011=m
+CONFIG_JOYSTICK_XPAD=m
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_JOYSTICK_XPAD_LEDS=y
+CONFIG_JOYSTICK_PSXPAD_SPI=y
+CONFIG_JOYSTICK_PSXPAD_SPI_FF=y
+CONFIG_JOYSTICK_PXRC=m
+CONFIG_JOYSTICK_FSIA6B=m
+CONFIG_INPUT_TABLET=y
+CONFIG_TABLET_USB_ACECAD=m
+CONFIG_TABLET_USB_AIPTEK=m
+CONFIG_TABLET_USB_GTCO=m
+CONFIG_TABLET_USB_HANWANG=m
+CONFIG_TABLET_USB_KBTAB=m
+CONFIG_TABLET_USB_PEGASUS=m
+CONFIG_TABLET_SERIAL_WACOM4=m
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ADS7846=m
+CONFIG_TOUCHSCREEN_AD7877=m
+CONFIG_TOUCHSCREEN_AD7879=m
+CONFIG_TOUCHSCREEN_AD7879_I2C=m
+CONFIG_TOUCHSCREEN_AR1021_I2C=m
+CONFIG_TOUCHSCREEN_ATMEL_MXT=m
+CONFIG_TOUCHSCREEN_DYNAPRO=m
+CONFIG_TOUCHSCREEN_HAMPSHIRE=m
+CONFIG_TOUCHSCREEN_FUJITSU=m
+CONFIG_TOUCHSCREEN_GOODIX=m
+CONFIG_TOUCHSCREEN_GUNZE=m
+CONFIG_TOUCHSCREEN_ELO=m
+CONFIG_TOUCHSCREEN_WACOM_W8001=m
+CONFIG_TOUCHSCREEN_MCS5000=m
+CONFIG_TOUCHSCREEN_MTOUCH=m
+CONFIG_TOUCHSCREEN_INEXIO=m
+CONFIG_TOUCHSCREEN_MK712=m
+CONFIG_TOUCHSCREEN_PENMOUNT=m
+CONFIG_TOUCHSCREEN_EDT_FT5X06=m
+CONFIG_TOUCHSCREEN_TOUCHRIGHT=m
+CONFIG_TOUCHSCREEN_TOUCHWIN=m
+CONFIG_TOUCHSCREEN_TI_AM335X_TSC=m
+CONFIG_TOUCHSCREEN_USB_COMPOSITE=m
+CONFIG_TOUCHSCREEN_MC13783=m
+CONFIG_TOUCHSCREEN_TSC2005=m
+CONFIG_TOUCHSCREEN_TSC2007=m
+CONFIG_TOUCHSCREEN_SILEAD=m
+CONFIG_TOUCHSCREEN_STMPE=m
+CONFIG_TOUCHSCREEN_SUN4I=m
+CONFIG_TOUCHSCREEN_TPS6507X=m
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_MMA8450=m
+CONFIG_INPUT_ATI_REMOTE2=m
+CONFIG_INPUT_KEYSPAN_REMOTE=m
+CONFIG_INPUT_POWERMATE=m
+CONFIG_INPUT_YEALINK=m
+CONFIG_INPUT_CM109=m
+CONFIG_INPUT_TPS65218_PWRBUTTON=y
+CONFIG_INPUT_AXP20X_PEK=m
+CONFIG_INPUT_TWL4030_PWRBUTTON=m
+CONFIG_INPUT_TWL4030_VIBRA=m
+CONFIG_INPUT_TWL6040_VIBRA=m
+CONFIG_INPUT_UINPUT=m
+CONFIG_INPUT_PALMAS_PWRBUTTON=y
+CONFIG_RMI4_F34=y
+CONFIG_RMI4_F55=y
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+# CONFIG_SERIAL_8250_16550A_VARIANTS is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_DMA is not set
+CONFIG_SERIAL_8250_NR_UARTS=6
+CONFIG_SERIAL_8250_RUNTIME_UARTS=6
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_8250_OMAP=y
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_SERIAL_MAX3100=m
+CONFIG_SERIAL_MAX310X=m
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_N_GSM=m
+CONFIG_SERIAL_DEV_BUS=y
+CONFIG_TTY_PRINTK=m
+CONFIG_VIRTIO_CONSOLE=m
+CONFIG_HW_RANDOM_VIRTIO=m
+CONFIG_TCG_TPM=y
+CONFIG_TCG_TIS_I2C_ATMEL=y
+CONFIG_RANDOM_TRUST_BOOTLOADER=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_ARB_GPIO_CHALLENGE=m
+CONFIG_I2C_MUX_GPIO=y
+CONFIG_I2C_MUX_PCA954x=m
+CONFIG_I2C_MUX_PINCTRL=y
+CONFIG_I2C_GPIO=y
+CONFIG_I2C_IMX=y
+CONFIG_I2C_MV64XXX=y
+CONFIG_I2C_SUN6I_P2WI=y
+CONFIG_I2C_DIOLAN_U2C=m
+CONFIG_I2C_ROBOTFUZZ_OSIF=m
+CONFIG_I2C_TAOS_EVM=m
+CONFIG_I2C_TINY_USB=m
+CONFIG_SPI=y
+CONFIG_SPI_GPIO=y
+CONFIG_SPI_IMX=m
+CONFIG_SPI_OMAP24XX=y
+CONFIG_SPI_TI_QSPI=y
+CONFIG_SPI_SUN4I=m
+CONFIG_SPI_SUN6I=m
+CONFIG_SPI_SPIDEV=m
+CONFIG_SPI_SLAVE=y
+CONFIG_SPI_SLAVE_TIME=m
+CONFIG_SPI_SLAVE_SYSTEM_CONTROL=m
+CONFIG_PPS_CLIENT_LDISC=m
+CONFIG_PPS_CLIENT_GPIO=m
+CONFIG_PINCTRL_AXP209=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_PINCTRL_PALMAS=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_GENERIC_PLATFORM=y
+CONFIG_GPIO_SYSCON=y
+CONFIG_GPIO_ADP5588=m
+CONFIG_GPIO_ADNP=m
+CONFIG_GPIO_MAX7300=m
+CONFIG_GPIO_MAX732X=m
+CONFIG_GPIO_PCA953X=y
+CONFIG_GPIO_PCA953X_IRQ=y
+CONFIG_GPIO_PCF857X=m
+CONFIG_GPIO_TPIC2810=m
+CONFIG_GPIO_DA9052=y
+CONFIG_GPIO_PALMAS=y
+CONFIG_GPIO_TPS65218=y
+CONFIG_GPIO_TPS65910=y
+CONFIG_GPIO_TWL4030=y
+CONFIG_GPIO_TWL6040=y
+CONFIG_GPIO_74X164=m
+CONFIG_GPIO_MAX3191X=m
+CONFIG_GPIO_MAX7301=m
+CONFIG_GPIO_MC33880=m
+CONFIG_GPIO_PISOSR=m
+CONFIG_GPIO_XRA1403=m
+CONFIG_GPIO_AGGREGATOR=m
+CONFIG_W1=m
+CONFIG_W1_MASTER_DS2490=m
+CONFIG_W1_MASTER_DS2482=m
+CONFIG_W1_MASTER_MXC=m
+CONFIG_W1_MASTER_GPIO=m
+CONFIG_HDQ_MASTER_OMAP=m
+CONFIG_W1_SLAVE_THERM=m
+CONFIG_W1_SLAVE_SMEM=m
+CONFIG_W1_SLAVE_DS2405=m
+CONFIG_W1_SLAVE_DS2408=m
+CONFIG_W1_SLAVE_DS2413=m
+CONFIG_W1_SLAVE_DS2406=m
+CONFIG_W1_SLAVE_DS2423=m
+CONFIG_W1_SLAVE_DS2805=m
+CONFIG_W1_SLAVE_DS2431=m
+CONFIG_W1_SLAVE_DS2433=m
+CONFIG_W1_SLAVE_DS2438=m
+CONFIG_W1_SLAVE_DS250X=m
+CONFIG_W1_SLAVE_DS2780=m
+CONFIG_W1_SLAVE_DS2781=m
+CONFIG_W1_SLAVE_DS28E04=m
+CONFIG_W1_SLAVE_DS28E17=m
+CONFIG_POWER_AVS=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_RESET_GPIO=y
+CONFIG_POWER_RESET_GPIO_RESTART=y
+CONFIG_POWER_RESET_RESTART=y
+CONFIG_POWER_RESET_SYSCON=y
+CONFIG_POWER_RESET_SYSCON_POWEROFF=y
+CONFIG_GENERIC_ADC_BATTERY=m
+CONFIG_BATTERY_DS2760=m
+CONFIG_BATTERY_SBS=m
+CONFIG_BATTERY_BQ27XXX=m
+# CONFIG_BATTERY_BQ27XXX_I2C is not set
+CONFIG_CHARGER_AXP20X=m
+CONFIG_BATTERY_AXP20X=m
+CONFIG_AXP20X_POWER=m
+CONFIG_AXP288_FUEL_GAUGE=m
+CONFIG_BATTERY_TWL4030_MADC=m
+CONFIG_BATTERY_RX51=m
+CONFIG_CHARGER_ISP1704=m
+CONFIG_CHARGER_TWL4030=m
+CONFIG_CHARGER_GPIO=m
+CONFIG_CHARGER_BQ2415X=m
+CONFIG_PWRSEQ_GENERIC=y
+CONFIG_SENSORS_AD7314=m
+CONFIG_SENSORS_AD7414=m
+CONFIG_SENSORS_AD7418=m
+CONFIG_SENSORS_ADM1021=m
+CONFIG_SENSORS_ADM1025=m
+CONFIG_SENSORS_ADM1026=m
+CONFIG_SENSORS_ADM1029=m
+CONFIG_SENSORS_ADM1031=m
+CONFIG_SENSORS_ADM1177=m
+CONFIG_SENSORS_ADM9240=m
+CONFIG_SENSORS_ADT7310=m
+CONFIG_SENSORS_ADT7410=m
+CONFIG_SENSORS_ADT7411=m
+CONFIG_SENSORS_ADT7462=m
+CONFIG_SENSORS_ADT7470=m
+CONFIG_SENSORS_ADT7475=m
+CONFIG_SENSORS_AS370=m
+CONFIG_SENSORS_ASC7621=m
+CONFIG_SENSORS_ASPEED=m
+CONFIG_SENSORS_ATXP1=m
+CONFIG_SENSORS_DRIVETEMP=m
+CONFIG_SENSORS_DS620=m
+CONFIG_SENSORS_DS1621=m
+CONFIG_SENSORS_DA9052_ADC=m
+CONFIG_SENSORS_F71805F=m
+CONFIG_SENSORS_F71882FG=m
+CONFIG_SENSORS_F75375S=m
+CONFIG_SENSORS_MC13783_ADC=m
+CONFIG_SENSORS_FTSTEUTATES=m
+CONFIG_SENSORS_GL518SM=m
+CONFIG_SENSORS_GL520SM=m
+CONFIG_SENSORS_G760A=m
+CONFIG_SENSORS_G762=m
+CONFIG_SENSORS_GPIO_FAN=y
+CONFIG_SENSORS_HIH6130=m
+CONFIG_SENSORS_IIO_HWMON=m
+CONFIG_SENSORS_IT87=m
+CONFIG_SENSORS_JC42=m
+CONFIG_SENSORS_POWR1220=m
+CONFIG_SENSORS_LINEAGE=m
+CONFIG_SENSORS_LTC2945=m
+CONFIG_SENSORS_LTC2990=m
+CONFIG_SENSORS_LTC4151=m
+CONFIG_SENSORS_LTC4215=m
+CONFIG_SENSORS_LTC4222=m
+CONFIG_SENSORS_LTC4245=m
+CONFIG_SENSORS_LTC4260=m
+CONFIG_SENSORS_LTC4261=m
+CONFIG_SENSORS_MAX1111=m
+CONFIG_SENSORS_MAX16065=m
+CONFIG_SENSORS_MAX1619=m
+CONFIG_SENSORS_MAX1668=m
+CONFIG_SENSORS_MAX197=m
+CONFIG_SENSORS_MAX31722=m
+CONFIG_SENSORS_MAX31730=m
+CONFIG_SENSORS_MAX6621=m
+CONFIG_SENSORS_MAX6639=m
+CONFIG_SENSORS_MAX6642=m
+CONFIG_SENSORS_MAX6650=m
+CONFIG_SENSORS_MAX6697=m
+CONFIG_SENSORS_MAX31790=m
+CONFIG_SENSORS_MCP3021=m
+CONFIG_SENSORS_TC654=m
+CONFIG_SENSORS_ADCXX=m
+CONFIG_SENSORS_LM63=m
+CONFIG_SENSORS_LM70=m
+CONFIG_SENSORS_LM73=m
+CONFIG_SENSORS_LM75=m
+CONFIG_SENSORS_LM77=m
+CONFIG_SENSORS_LM78=m
+CONFIG_SENSORS_LM80=m
+CONFIG_SENSORS_LM83=m
+CONFIG_SENSORS_LM85=m
+CONFIG_SENSORS_LM87=m
+CONFIG_SENSORS_LM90=m
+CONFIG_SENSORS_LM92=m
+CONFIG_SENSORS_LM93=m
+CONFIG_SENSORS_LM95234=m
+CONFIG_SENSORS_LM95241=m
+CONFIG_SENSORS_LM95245=m
+CONFIG_SENSORS_PC87360=m
+CONFIG_SENSORS_PC87427=m
+CONFIG_SENSORS_NTC_THERMISTOR=m
+CONFIG_SENSORS_NCT6683=m
+CONFIG_SENSORS_NCT6775=m
+CONFIG_SENSORS_NCT7802=m
+CONFIG_SENSORS_NCT7904=m
+CONFIG_SENSORS_NPCM7XX=m
+CONFIG_SENSORS_PCF8591=m
+CONFIG_PMBUS=m
+CONFIG_SENSORS_ADM1275=m
+CONFIG_SENSORS_IBM_CFFPS=m
+CONFIG_SENSORS_INSPUR_IPSPS=m
+CONFIG_SENSORS_IR35221=m
+CONFIG_SENSORS_IR38064=m
+CONFIG_SENSORS_IRPS5401=m
+CONFIG_SENSORS_ISL68137=m
+CONFIG_SENSORS_LM25066=m
+CONFIG_SENSORS_LTC2978=m
+CONFIG_SENSORS_LTC2978_REGULATOR=y
+CONFIG_SENSORS_LTC3815=m
+CONFIG_SENSORS_MAX16064=m
+CONFIG_SENSORS_MAX20730=m
+CONFIG_SENSORS_MAX20751=m
+CONFIG_SENSORS_MAX31785=m
+CONFIG_SENSORS_MAX34440=m
+CONFIG_SENSORS_MAX8688=m
+CONFIG_SENSORS_PXE1610=m
+CONFIG_SENSORS_TPS40422=m
+CONFIG_SENSORS_TPS53679=m
+CONFIG_SENSORS_UCD9000=m
+CONFIG_SENSORS_UCD9200=m
+CONFIG_SENSORS_XDPE122=m
+CONFIG_SENSORS_ZL6100=m
+CONFIG_SENSORS_PWM_FAN=m
+CONFIG_SENSORS_SHT15=m
+CONFIG_SENSORS_SHT21=m
+CONFIG_SENSORS_SHT3x=m
+CONFIG_SENSORS_SHTC1=m
+CONFIG_SENSORS_DME1737=m
+CONFIG_SENSORS_EMC1403=m
+CONFIG_SENSORS_EMC2103=m
+CONFIG_SENSORS_EMC6W201=m
+CONFIG_SENSORS_SMSC47M1=m
+CONFIG_SENSORS_SMSC47M192=m
+CONFIG_SENSORS_SMSC47B397=m
+CONFIG_SENSORS_SCH5627=m
+CONFIG_SENSORS_SCH5636=m
+CONFIG_SENSORS_STTS751=m
+CONFIG_SENSORS_SMM665=m
+CONFIG_SENSORS_ADC128D818=m
+CONFIG_SENSORS_ADS7828=m
+CONFIG_SENSORS_ADS7871=m
+CONFIG_SENSORS_AMC6821=m
+CONFIG_SENSORS_INA209=m
+CONFIG_SENSORS_INA2XX=m
+CONFIG_SENSORS_INA3221=m
+CONFIG_SENSORS_TC74=m
+CONFIG_SENSORS_THMC50=m
+CONFIG_SENSORS_TMP102=m
+CONFIG_SENSORS_TMP103=m
+CONFIG_SENSORS_TMP108=m
+CONFIG_SENSORS_TMP401=m
+CONFIG_SENSORS_TMP421=m
+CONFIG_SENSORS_VT1211=m
+CONFIG_SENSORS_W83773G=m
+CONFIG_SENSORS_W83781D=m
+CONFIG_SENSORS_W83791D=m
+CONFIG_SENSORS_W83792D=m
+CONFIG_SENSORS_W83793=m
+CONFIG_SENSORS_W83795=m
+CONFIG_SENSORS_W83L785TS=m
+CONFIG_SENSORS_W83L786NG=m
+CONFIG_SENSORS_W83627HF=m
+CONFIG_SENSORS_W83627EHF=m
+CONFIG_THERMAL_STATISTICS=y
+CONFIG_THERMAL_GOV_FAIR_SHARE=y
+CONFIG_THERMAL_GOV_BANG_BANG=y
+CONFIG_CPU_THERMAL=y
+CONFIG_DEVFREQ_THERMAL=y
+CONFIG_IMX_THERMAL=y
+CONFIG_TI_THERMAL=y
+CONFIG_OMAP3_THERMAL=y
+CONFIG_OMAP4_THERMAL=y
+CONFIG_OMAP5_THERMAL=y
+CONFIG_DRA752_THERMAL=y
+CONFIG_GENERIC_ADC_THERMAL=m
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_SYSFS=y
+CONFIG_WATCHDOG_PRETIMEOUT_GOV=y
+CONFIG_WATCHDOG_PRETIMEOUT_GOV_NOOP=m
+CONFIG_WATCHDOG_PRETIMEOUT_GOV_PANIC=m
+CONFIG_WATCHDOG_PRETIMEOUT_DEFAULT_GOV_NOOP=y
+CONFIG_SOFT_WATCHDOG=m
+CONFIG_DA9052_WATCHDOG=m
+CONFIG_DW_WATCHDOG=m
+CONFIG_OMAP_WATCHDOG=m
+CONFIG_SUNXI_WATCHDOG=m
+CONFIG_TWL4030_WATCHDOG=m
+CONFIG_IMX2_WDT=y
+CONFIG_MFD_AC100=y
+CONFIG_MFD_AXP20X_I2C=y
+CONFIG_MFD_AXP20X_RSB=y
+CONFIG_MFD_DA9052_SPI=y
+CONFIG_MFD_DA9052_I2C=y
+CONFIG_MFD_MC13XXX_SPI=m
+CONFIG_MFD_MC13XXX_I2C=m
+CONFIG_MFD_MAX77686=y
+CONFIG_MFD_STMPE=y
+CONFIG_MFD_TI_AM335X_TSCADC=m
+CONFIG_MFD_PALMAS=y
+CONFIG_MFD_TPS65217=y
+CONFIG_MFD_TPS65218=y
+CONFIG_MFD_TPS65910=y
+CONFIG_TWL6040_CORE=y
+CONFIG_MFD_WL1273_CORE=m
+CONFIG_REGULATOR_USERSPACE_CONSUMER=y
+CONFIG_REGULATOR_ACT8865=y
+CONFIG_REGULATOR_AD5398=y
+CONFIG_REGULATOR_ANATOP=y
+CONFIG_REGULATOR_AXP20X=y
+CONFIG_REGULATOR_DA9052=y
+CONFIG_REGULATOR_FAN53555=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_REGULATOR_MAX77686=m
+CONFIG_REGULATOR_MC13783=m
+CONFIG_REGULATOR_MC13892=m
+CONFIG_REGULATOR_PALMAS=y
+CONFIG_REGULATOR_PBIAS=y
+CONFIG_REGULATOR_PFUZE100=y
+CONFIG_REGULATOR_PWM=y
+CONFIG_REGULATOR_TI_ABB=y
+CONFIG_REGULATOR_TPS65217=y
+CONFIG_REGULATOR_TPS65218=y
+CONFIG_REGULATOR_TPS65910=y
+CONFIG_REGULATOR_TWL4030=y
+CONFIG_RC_CORE=m
+CONFIG_LIRC=y
+CONFIG_RC_DECODERS=y
+CONFIG_IR_NEC_DECODER=m
+CONFIG_IR_RC5_DECODER=m
+CONFIG_IR_RC6_DECODER=m
+CONFIG_IR_JVC_DECODER=m
+CONFIG_IR_SONY_DECODER=m
+CONFIG_IR_SANYO_DECODER=m
+CONFIG_IR_SHARP_DECODER=m
+CONFIG_IR_MCE_KBD_DECODER=m
+CONFIG_IR_XMP_DECODER=m
+CONFIG_IR_IMON_DECODER=m
+CONFIG_RC_DEVICES=y
+CONFIG_RC_ATI_REMOTE=m
+CONFIG_IR_IMON=m
+CONFIG_IR_IMON_RAW=m
+CONFIG_IR_MCEUSB=m
+CONFIG_IR_REDRAT3=m
+CONFIG_IR_STREAMZAP=m
+CONFIG_IR_IGORPLUGUSB=m
+CONFIG_IR_IGUANA=m
+CONFIG_IR_TTUSBIR=m
+CONFIG_RC_LOOPBACK=m
+CONFIG_IR_GPIO_CIR=m
+CONFIG_IR_SUNXI=m
+CONFIG_USB_PULSE8_CEC=m
+CONFIG_USB_RAINSHADOW_CEC=m
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_SUBDRV_AUTOSELECT=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_USB_M5602=m
+CONFIG_USB_STV06XX=m
+CONFIG_USB_GL860=m
+CONFIG_USB_GSPCA_BENQ=m
+CONFIG_USB_GSPCA_CONEX=m
+CONFIG_USB_GSPCA_CPIA1=m
+CONFIG_USB_GSPCA_DTCS033=m
+CONFIG_USB_GSPCA_ETOMS=m
+CONFIG_USB_GSPCA_FINEPIX=m
+CONFIG_USB_GSPCA_JEILINJ=m
+CONFIG_USB_GSPCA_JL2005BCD=m
+CONFIG_USB_GSPCA_KINECT=m
+CONFIG_USB_GSPCA_KONICA=m
+CONFIG_USB_GSPCA_MARS=m
+CONFIG_USB_GSPCA_MR97310A=m
+CONFIG_USB_GSPCA_NW80X=m
+CONFIG_USB_GSPCA_OV519=m
+CONFIG_USB_GSPCA_OV534=m
+CONFIG_USB_GSPCA_OV534_9=m
+CONFIG_USB_GSPCA_PAC207=m
+CONFIG_USB_GSPCA_PAC7302=m
+CONFIG_USB_GSPCA_PAC7311=m
+CONFIG_USB_GSPCA_SE401=m
+CONFIG_USB_GSPCA_SN9C2028=m
+CONFIG_USB_GSPCA_SN9C20X=m
+CONFIG_USB_GSPCA_SONIXB=m
+CONFIG_USB_GSPCA_SONIXJ=m
+CONFIG_USB_GSPCA_SPCA500=m
+CONFIG_USB_GSPCA_SPCA501=m
+CONFIG_USB_GSPCA_SPCA505=m
+CONFIG_USB_GSPCA_SPCA506=m
+CONFIG_USB_GSPCA_SPCA508=m
+CONFIG_USB_GSPCA_SPCA561=m
+CONFIG_USB_GSPCA_SPCA1528=m
+CONFIG_USB_GSPCA_SQ905=m
+CONFIG_USB_GSPCA_SQ905C=m
+CONFIG_USB_GSPCA_SQ930X=m
+CONFIG_USB_GSPCA_STK014=m
+CONFIG_USB_GSPCA_STK1135=m
+CONFIG_USB_GSPCA_STV0680=m
+CONFIG_USB_GSPCA_SUNPLUS=m
+CONFIG_USB_GSPCA_T613=m
+CONFIG_USB_GSPCA_TOPRO=m
+CONFIG_USB_GSPCA_TOUPTEK=m
+CONFIG_USB_GSPCA_TV8532=m
+CONFIG_USB_GSPCA_VC032X=m
+CONFIG_USB_GSPCA_VICAM=m
+CONFIG_USB_GSPCA_XIRLINK_CIT=m
+CONFIG_USB_GSPCA_ZC3XX=m
+CONFIG_USB_PWC=m
+CONFIG_VIDEO_CPIA2=m
+CONFIG_USB_ZR364XX=m
+CONFIG_USB_STKWEBCAM=m
+CONFIG_USB_S2255=m
+CONFIG_VIDEO_USBTV=m
+CONFIG_VIDEO_PVRUSB2=m
+CONFIG_VIDEO_HDPVR=m
+CONFIG_VIDEO_STK1160_COMMON=m
+CONFIG_VIDEO_GO7007=m
+CONFIG_VIDEO_GO7007_USB=m
+CONFIG_VIDEO_GO7007_USB_S2250_BOARD=m
+CONFIG_VIDEO_AU0828=m
+CONFIG_VIDEO_AU0828_RC=y
+CONFIG_VIDEO_CX231XX=m
+CONFIG_VIDEO_CX231XX_ALSA=m
+CONFIG_VIDEO_CX231XX_DVB=m
+CONFIG_DVB_USB=m
+CONFIG_DVB_USB_A800=m
+CONFIG_DVB_USB_DIBUSB_MB=m
+CONFIG_DVB_USB_DIBUSB_MB_FAULTY=y
+CONFIG_DVB_USB_DIBUSB_MC=m
+CONFIG_DVB_USB_DIB0700=m
+CONFIG_DVB_USB_UMT_010=m
+CONFIG_DVB_USB_CXUSB=m
+CONFIG_DVB_USB_M920X=m
+CONFIG_DVB_USB_DIGITV=m
+CONFIG_DVB_USB_VP7045=m
+CONFIG_DVB_USB_VP702X=m
+CONFIG_DVB_USB_GP8PSK=m
+CONFIG_DVB_USB_NOVA_T_USB2=m
+CONFIG_DVB_USB_TTUSB2=m
+CONFIG_DVB_USB_DTT200U=m
+CONFIG_DVB_USB_OPERA1=m
+CONFIG_DVB_USB_AF9005=m
+CONFIG_DVB_USB_AF9005_REMOTE=m
+CONFIG_DVB_USB_PCTV452E=m
+CONFIG_DVB_USB_DW2102=m
+CONFIG_DVB_USB_CINERGY_T2=m
+CONFIG_DVB_USB_DTV5100=m
+CONFIG_DVB_USB_AZ6027=m
+CONFIG_DVB_USB_TECHNISAT_USB2=m
+CONFIG_DVB_USB_V2=m
+CONFIG_DVB_USB_AF9015=m
+CONFIG_DVB_USB_AF9035=m
+CONFIG_DVB_USB_ANYSEE=m
+CONFIG_DVB_USB_AU6610=m
+CONFIG_DVB_USB_AZ6007=m
+CONFIG_DVB_USB_CE6230=m
+CONFIG_DVB_USB_EC168=m
+CONFIG_DVB_USB_GL861=m
+CONFIG_DVB_USB_LME2510=m
+CONFIG_DVB_USB_MXL111SF=m
+CONFIG_DVB_USB_RTL28XXU=m
+CONFIG_DVB_USB_DVBSKY=m
+CONFIG_DVB_USB_ZD1301=m
+CONFIG_SMS_USB_DRV=m
+CONFIG_DVB_B2C2_FLEXCOP_USB=m
+CONFIG_DVB_AS102=m
+CONFIG_VIDEO_EM28XX=m
+CONFIG_VIDEO_EM28XX_V4L2=m
+CONFIG_VIDEO_EM28XX_ALSA=m
+CONFIG_VIDEO_EM28XX_DVB=m
+CONFIG_USB_AIRSPY=m
+CONFIG_USB_HACKRF=m
+CONFIG_USB_MSI2500=m
+CONFIG_RADIO_SI470X=y
+CONFIG_USB_SI470X=m
+CONFIG_RADIO_SI4713=m
+CONFIG_I2C_SI4713=m
+CONFIG_USB_MR800=m
+CONFIG_RADIO_SHARK=m
+CONFIG_RADIO_SHARK2=m
+CONFIG_USB_KEENE=m
+CONFIG_USB_RAREMONO=m
+CONFIG_USB_MA901=m
+CONFIG_RADIO_WL128X=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_OMAP3=m
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_TI_VPE=m
+CONFIG_SMS_SDIO_DRV=m
+CONFIG_VIDEO_TVAUDIO=m
+CONFIG_VIDEO_TDA7432=m
+CONFIG_VIDEO_TDA9840=m
+CONFIG_VIDEO_TEA6415C=m
+CONFIG_VIDEO_TEA6420=m
+CONFIG_VIDEO_CS3308=m
+CONFIG_VIDEO_CS5345=m
+CONFIG_VIDEO_TLV320AIC23B=m
+CONFIG_VIDEO_WM8739=m
+CONFIG_VIDEO_VP27SMPX=m
+CONFIG_VIDEO_SAA6588=m
+CONFIG_VIDEO_BT819=m
+CONFIG_VIDEO_BT856=m
+CONFIG_VIDEO_KS0127=m
+CONFIG_VIDEO_SAA7110=m
+CONFIG_VIDEO_VPX3220=m
+CONFIG_VIDEO_SAA717X=m
+CONFIG_VIDEO_SAA7127=m
+CONFIG_VIDEO_SAA7185=m
+CONFIG_VIDEO_ADV7170=m
+CONFIG_VIDEO_ADV7175=m
+CONFIG_VIDEO_UPD64031A=m
+CONFIG_VIDEO_UPD64083=m
+CONFIG_VIDEO_SAA6752HS=m
+CONFIG_VIDEO_M52790=m
+CONFIG_VIDEO_OV7670=m
+CONFIG_VIDEO_SR030PC30=m
+CONFIG_VIDEO_NOON010PC30=m
+CONFIG_MEDIA_TUNER_MT2131=m
+CONFIG_MEDIA_TUNER_M88RS6000T=m
+CONFIG_MEDIA_TUNER_MXL301RF=m
+CONFIG_MEDIA_TUNER_QM1D1B0004=m
+CONFIG_DVB_STV0910=m
+CONFIG_DVB_STV6111=m
+CONFIG_DVB_MXL5XX=m
+CONFIG_DVB_CX24110=m
+CONFIG_DVB_ZL10036=m
+CONFIG_DVB_TDA8083=m
+CONFIG_DVB_TDA8261=m
+CONFIG_DVB_VES1X93=m
+CONFIG_DVB_TUA6100=m
+CONFIG_DVB_CX24117=m
+CONFIG_DVB_MB86A16=m
+CONFIG_DVB_SP8870=m
+CONFIG_DVB_SP887X=m
+CONFIG_DVB_CX22700=m
+CONFIG_DVB_L64781=m
+CONFIG_DVB_STV0367=m
+CONFIG_DVB_VES1820=m
+CONFIG_DVB_TDA10021=m
+CONFIG_DVB_OR51211=m
+CONFIG_DVB_OR51132=m
+CONFIG_DVB_LNBH25=m
+CONFIG_DVB_ISL6405=m
+CONFIG_DVB_TDA665x=m
+CONFIG_DVB_HORUS3A=m
+CONFIG_DVB_ASCOT2E=m
+CONFIG_DVB_HELENE=m
+CONFIG_DVB_CXD2099=m
+CONFIG_DVB_DUMMY_FE=m
+CONFIG_IMX_IPUV3_CORE=y
+CONFIG_DRM=y
+CONFIG_DRM_DP_AUX_CHARDEV=y
+CONFIG_DRM_LOAD_EDID_FIRMWARE=y
+CONFIG_DRM_I2C_NXP_TDA998X=y
+CONFIG_DRM_VGEM=m
+CONFIG_DRM_UDL=m
+CONFIG_DRM_SUN4I=y
+CONFIG_DRM_SUN4I_HDMI_CEC=y
+CONFIG_DRM_SUN8I_DW_HDMI=y
+CONFIG_DRM_OMAP=y
+CONFIG_OMAP5_DSS_HDMI=y
+CONFIG_OMAP2_DSS_SDI=y
+CONFIG_OMAP2_DSS_DSI=y
+CONFIG_DRM_TILCDC=y
+CONFIG_DRM_VIRTIO_GPU=m
+CONFIG_DRM_PANEL_SIMPLE=m
+CONFIG_DRM_SII902X=y
+CONFIG_DRM_TI_TFP410=y
+CONFIG_DRM_I2C_ADV7511=y
+CONFIG_DRM_I2C_ADV7511_AUDIO=y
+CONFIG_DRM_DW_HDMI_AHB_AUDIO=m
+CONFIG_DRM_DW_HDMI_I2S_AUDIO=m
+CONFIG_DRM_DW_HDMI_CEC=m
+CONFIG_DRM_IMX=y
+CONFIG_DRM_IMX_PARALLEL_DISPLAY=y
+CONFIG_DRM_IMX_TVE=y
+CONFIG_DRM_IMX_LDB=y
+CONFIG_DRM_IMX_HDMI=y
+CONFIG_DRM_ETNAVIV=y
+CONFIG_DRM_MXSFB=y
+CONFIG_DRM_GM12U320=m
+CONFIG_TINYDRM_HX8357D=m
+CONFIG_TINYDRM_ILI9225=m
+CONFIG_TINYDRM_ILI9341=m
+CONFIG_TINYDRM_ILI9486=m
+CONFIG_TINYDRM_MI0283QT=m
+CONFIG_TINYDRM_REPAPER=m
+CONFIG_TINYDRM_ST7586=m
+CONFIG_TINYDRM_ST7735R=m
+CONFIG_FIRMWARE_EDID=y
+CONFIG_FB_TILEBLITTING=y
+CONFIG_FB_SMSCUFX=m
+CONFIG_FB_UDL=m
+# CONFIG_FB_MX3 is not set
+CONFIG_FB_SIMPLE=y
+CONFIG_FB_SSD1307=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_BACKLIGHT_GPIO=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+CONFIG_LOGO=y
+CONFIG_SOUND=m
+# CONFIG_SOUND_OSS_CORE_PRECLAIM is not set
+CONFIG_SND=m
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=m
+CONFIG_SND_PCM_OSS=m
+CONFIG_SND_HRTIMER=m
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_SEQUENCER=m
+CONFIG_SND_SEQ_DUMMY=m
+CONFIG_SND_DUMMY=m
+CONFIG_SND_ALOOP=m
+CONFIG_SND_VIRMIDI=m
+CONFIG_SND_MTPAV=m
+CONFIG_SND_SERIAL_U16550=m
+CONFIG_SND_MPU401=m
+CONFIG_SND_HDA_PREALLOC_SIZE=2048
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_USB_UA101=m
+CONFIG_SND_USB_CAIAQ=m
+CONFIG_SND_USB_CAIAQ_INPUT=y
+CONFIG_SND_USB_6FIRE=m
+CONFIG_SND_USB_HIFACE=m
+CONFIG_SND_BCD2000=m
+CONFIG_SND_USB_POD=m
+CONFIG_SND_USB_PODHD=m
+CONFIG_SND_USB_TONEPORT=m
+CONFIG_SND_USB_VARIAX=m
+CONFIG_SND_SOC=m
+CONFIG_SND_IMX_SOC=m
+CONFIG_SND_SOC_EUKREA_TLV320=m
+CONFIG_SND_SOC_IMX_ES8328=m
+CONFIG_SND_SOC_IMX_SGTL5000=m
+CONFIG_SND_SOC_IMX_SPDIF=m
+CONFIG_SND_SOC_IMX_MC13783=m
+CONFIG_SND_SUN4I_CODEC=m
+CONFIG_SND_SUN8I_CODEC=m
+CONFIG_SND_SUN8I_CODEC_ANALOG=m
+CONFIG_SND_SUN4I_SPDIF=m
+CONFIG_SND_SOC_DAVINCI_MCASP=m
+CONFIG_SND_SOC_NOKIA_RX51=m
+CONFIG_SND_SOC_OMAP3_PANDORA=m
+CONFIG_SND_SOC_OMAP3_TWL4030=m
+CONFIG_SND_SOC_OMAP_ABE_TWL6040=m
+CONFIG_SND_SOC_OMAP_HDMI=m
+CONFIG_SND_SOC_ADAU1701=m
+CONFIG_SND_SOC_ADAU7002=m
+CONFIG_SND_SOC_AK4554=m
+CONFIG_SND_SOC_CS4265=m
+CONFIG_SND_SOC_CS4271_I2C=m
+CONFIG_SND_SOC_DMIC=m
+CONFIG_SND_SOC_PCM512x_I2C=m
+CONFIG_SND_SOC_SPDIF=m
+CONFIG_SND_SOC_TS3A227E=m
+CONFIG_SND_SOC_WM8753=m
+CONFIG_SND_SOC_WM8804_I2C=m
+CONFIG_SND_SOC_WM8903=m
+CONFIG_SND_SIMPLE_CARD=m
+CONFIG_HID_BATTERY_STRENGTH=y
+CONFIG_HIDRAW=y
+CONFIG_UHID=m
+CONFIG_HID_GENERIC=m
+CONFIG_HID_A4TECH=m
+CONFIG_HID_ACCUTOUCH=m
+CONFIG_HID_ACRUX=m
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=m
+CONFIG_HID_ASUS=m
+CONFIG_HID_AUREAL=m
+CONFIG_HID_BELKIN=m
+CONFIG_HID_BETOP_FF=m
+CONFIG_HID_BIGBEN_FF=m
+CONFIG_HID_CHERRY=m
+CONFIG_HID_CHICONY=m
+CONFIG_HID_CORSAIR=m
+CONFIG_HID_COUGAR=m
+CONFIG_HID_MACALLY=m
+CONFIG_HID_PRODIKEYS=m
+CONFIG_HID_CMEDIA=m
+CONFIG_HID_CP2112=m
+CONFIG_HID_CYPRESS=m
+CONFIG_HID_DRAGONRISE=m
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=m
+CONFIG_HID_ELAN=m
+CONFIG_HID_ELECOM=m
+CONFIG_HID_ELO=m
+CONFIG_HID_EZKEY=m
+CONFIG_HID_GEMBIRD=m
+CONFIG_HID_GFRM=m
+CONFIG_HID_HOLTEK=m
+CONFIG_HOLTEK_FF=y
+CONFIG_HID_GT683R=m
+CONFIG_HID_KEYTOUCH=m
+CONFIG_HID_KYE=m
+CONFIG_HID_UCLOGIC=m
+CONFIG_HID_WALTOP=m
+CONFIG_HID_VIEWSONIC=m
+CONFIG_HID_GYRATION=m
+CONFIG_HID_ICADE=m
+CONFIG_HID_ITE=m
+CONFIG_HID_JABRA=m
+CONFIG_HID_TWINHAN=m
+CONFIG_HID_KENSINGTON=m
+CONFIG_HID_LCPOWER=m
+CONFIG_HID_LENOVO=m
+CONFIG_HID_LOGITECH=y
+CONFIG_HID_LOGITECH_DJ=y
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_HID_MAGICMOUSE=m
+CONFIG_HID_MALTRON=m
+CONFIG_HID_MAYFLASH=m
+CONFIG_HID_REDRAGON=m
+CONFIG_HID_MICROSOFT=m
+CONFIG_HID_MONTEREY=m
+CONFIG_HID_MULTITOUCH=m
+CONFIG_HID_NTI=m
+CONFIG_HID_NTRIG=m
+CONFIG_HID_ORTEK=m
+CONFIG_HID_PANTHERLORD=m
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PENMOUNT=m
+CONFIG_HID_PETALYNX=m
+CONFIG_HID_PICOLCD=m
+CONFIG_HID_PICOLCD_FB=y
+CONFIG_HID_PICOLCD_BACKLIGHT=y
+CONFIG_HID_PICOLCD_LEDS=y
+CONFIG_HID_PICOLCD_CIR=y
+CONFIG_HID_PLANTRONICS=m
+CONFIG_HID_PRIMAX=m
+CONFIG_HID_RETRODE=m
+CONFIG_HID_ROCCAT=m
+CONFIG_HID_SAITEK=m
+CONFIG_HID_SAMSUNG=m
+CONFIG_HID_SONY=m
+CONFIG_SONY_FF=y
+CONFIG_HID_SPEEDLINK=m
+CONFIG_HID_STEAM=m
+CONFIG_HID_STEELSERIES=m
+CONFIG_HID_SUNPLUS=m
+CONFIG_HID_RMI=m
+CONFIG_HID_GREENASIA=m
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=m
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TIVO=m
+CONFIG_HID_TOPSEED=m
+CONFIG_HID_THINGM=m
+CONFIG_HID_THRUSTMASTER=m
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_UDRAW_PS3=m
+CONFIG_HID_U2FZERO=m
+CONFIG_HID_WACOM=m
+CONFIG_HID_WIIMOTE=m
+CONFIG_HID_XINMO=m
+CONFIG_HID_ZEROPLUS=m
+CONFIG_ZEROPLUS_FF=y
+CONFIG_HID_ZYDACRON=m
+CONFIG_HID_SENSOR_HUB=m
+CONFIG_HID_SENSOR_CUSTOM_SENSOR=m
+CONFIG_HID_ALPS=m
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+CONFIG_I2C_HID=y
+CONFIG_USB_LED_TRIG=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_DYNAMIC_MINORS=y
+CONFIG_USB_OTG=y
+CONFIG_USB_LEDS_TRIGGER_USBPORT=m
+CONFIG_USB_MON=m
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_MXC=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_U132_HCD=m
+CONFIG_USB_PRINTER=m
+CONFIG_USB_TMC=m
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_REALTEK=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+CONFIG_USB_STORAGE_ENE_UB6250=y
+CONFIG_USB_UAS=y
+CONFIG_USB_MDC800=m
+CONFIG_USB_MICROTEK=m
+CONFIG_USBIP_CORE=m
+CONFIG_USBIP_VHCI_HCD=m
+CONFIG_USBIP_VHCI_HC_PORTS=15
+CONFIG_USBIP_VHCI_NR_HCS=8
+CONFIG_USBIP_HOST=m
+CONFIG_USBIP_VUDC=m
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_USB_MUSB_SUNXI=y
+CONFIG_USB_MUSB_TUSB6010=y
+CONFIG_USB_MUSB_OMAP2PLUS=y
+CONFIG_USB_MUSB_AM35X=y
+CONFIG_USB_MUSB_DSPS=y
+CONFIG_MUSB_PIO_ONLY=y
+CONFIG_USB_DWC3=y
+CONFIG_USB_DWC2=m
+CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_CHIPIDEA_HOST=y
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_SIMPLE=m
+CONFIG_USB_SERIAL_AIRCABLE=m
+CONFIG_USB_SERIAL_ARK3116=m
+CONFIG_USB_SERIAL_BELKIN=m
+CONFIG_USB_SERIAL_CH341=m
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_CYPRESS_M8=m
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_VISOR=m
+CONFIG_USB_SERIAL_IPAQ=m
+CONFIG_USB_SERIAL_IR=m
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_USB_SERIAL_EDGEPORT_TI=m
+CONFIG_USB_SERIAL_F81232=m
+CONFIG_USB_SERIAL_F8153X=m
+CONFIG_USB_SERIAL_GARMIN=m
+CONFIG_USB_SERIAL_IPW=m
+CONFIG_USB_SERIAL_IUU=m
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_USB_SERIAL_KLSI=m
+CONFIG_USB_SERIAL_KOBIL_SCT=m
+CONFIG_USB_SERIAL_MCT_U232=m
+CONFIG_USB_SERIAL_METRO=m
+CONFIG_USB_SERIAL_MOS7720=m
+CONFIG_USB_SERIAL_MOS7840=m
+CONFIG_USB_SERIAL_MXUPORT=m
+CONFIG_USB_SERIAL_NAVMAN=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_SERIAL_OTI6858=m
+CONFIG_USB_SERIAL_QCAUX=m
+CONFIG_USB_SERIAL_QUALCOMM=m
+CONFIG_USB_SERIAL_SPCP8X5=m
+CONFIG_USB_SERIAL_SAFE=m
+CONFIG_USB_SERIAL_SIERRAWIRELESS=m
+CONFIG_USB_SERIAL_SYMBOL=m
+CONFIG_USB_SERIAL_TI=m
+CONFIG_USB_SERIAL_CYBERJACK=m
+CONFIG_USB_SERIAL_XIRCOM=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_SERIAL_OMNINET=m
+CONFIG_USB_SERIAL_OPTICON=m
+CONFIG_USB_SERIAL_XSENS_MT=m
+CONFIG_USB_SERIAL_WISHBONE=m
+CONFIG_USB_SERIAL_SSU100=m
+CONFIG_USB_SERIAL_QT2=m
+CONFIG_USB_SERIAL_UPD78F0730=m
+CONFIG_USB_SERIAL_DEBUG=m
+CONFIG_USB_EMI62=m
+CONFIG_USB_EMI26=m
+CONFIG_USB_ADUTUX=m
+CONFIG_USB_SEVSEG=m
+CONFIG_USB_LEGOTOWER=m
+CONFIG_USB_LCD=m
+CONFIG_USB_CYPRESS_CY7C63=m
+CONFIG_USB_CYTHERM=m
+CONFIG_USB_IDMOUSE=m
+CONFIG_USB_FTDI_ELAN=m
+CONFIG_USB_APPLEDISPLAY=m
+CONFIG_USB_SISUSBVGA=m
+CONFIG_USB_SISUSBVGA_CON=y
+CONFIG_USB_LD=m
+CONFIG_USB_TRANCEVIBRATOR=m
+CONFIG_USB_IOWARRIOR=m
+CONFIG_USB_TEST=m
+CONFIG_USB_EHSET_TEST_FIXTURE=m
+CONFIG_USB_ISIGHTFW=m
+CONFIG_USB_YUREX=m
+CONFIG_USB_HSIC_USB3503=m
+CONFIG_USB_CHAOSKEY=m
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_AM335X_PHY_USB=y
+CONFIG_TWL6030_USB=y
+CONFIG_USB_GPIO_VBUS=y
+CONFIG_USB_MXS_PHY=y
+CONFIG_USB_ULPI=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_USB_DUMMY_HCD=m
+CONFIG_USB_CONFIGFS=m
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_OBEX=y
+CONFIG_USB_CONFIGFS_NCM=y
+CONFIG_USB_CONFIGFS_ECM=y
+CONFIG_USB_CONFIGFS_ECM_SUBSET=y
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS_EEM=y
+CONFIG_USB_CONFIGFS_PHONET=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_LB_SS=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_UAC1=y
+CONFIG_USB_CONFIGFS_F_UAC2=y
+CONFIG_USB_CONFIGFS_F_MIDI=y
+CONFIG_USB_CONFIGFS_F_HID=y
+CONFIG_USB_CONFIGFS_F_UVC=y
+CONFIG_USB_CONFIGFS_F_PRINTER=y
+CONFIG_USB_ZERO=m
+CONFIG_USB_AUDIO=m
+CONFIG_USB_ETH=m
+CONFIG_USB_G_NCM=m
+CONFIG_USB_GADGETFS=m
+CONFIG_USB_FUNCTIONFS=m
+CONFIG_USB_FUNCTIONFS_ETH=y
+CONFIG_USB_FUNCTIONFS_RNDIS=y
+CONFIG_USB_FUNCTIONFS_GENERIC=y
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+CONFIG_USB_MIDI_GADGET=m
+CONFIG_USB_G_PRINTER=m
+CONFIG_USB_CDC_COMPOSITE=m
+CONFIG_USB_G_NOKIA=m
+CONFIG_USB_G_ACM_MS=m
+CONFIG_USB_G_MULTI=m
+CONFIG_USB_G_HID=m
+CONFIG_USB_G_DBGP=m
+CONFIG_TYPEC=y
+CONFIG_TYPEC_HD3SS3220=y
+CONFIG_MMC=y
+CONFIG_PWRSEQ_SD8787=m
+CONFIG_MMC_BLOCK_MINORS=256
+CONFIG_SDIO_UART=m
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_ESDHC_IMX=y
+CONFIG_MMC_OMAP_HS=y
+CONFIG_MMC_SPI=y
+CONFIG_MMC_VUB300=m
+CONFIG_MMC_USHC=m
+CONFIG_MMC_SUNXI=y
+CONFIG_MMC_SDHCI_OMAP=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_BRIGHTNESS_HW_CHANGED=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_LP3944=m
+CONFIG_LEDS_LP55XX_COMMON=m
+CONFIG_LEDS_LP5523=m
+CONFIG_LEDS_PCA955X=m
+CONFIG_LEDS_DA9052=m
+CONFIG_LEDS_DAC124S085=m
+CONFIG_LEDS_PWM=m
+CONFIG_LEDS_REGULATOR=m
+CONFIG_LEDS_BD2802=m
+CONFIG_LEDS_LT3593=m
+CONFIG_LEDS_MC13783=m
+CONFIG_LEDS_TCA6507=m
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_DISK=y
+CONFIG_LEDS_TRIGGER_MTD=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_ACTIVITY=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_LEDS_TRIGGER_TRANSIENT=m
+CONFIG_LEDS_TRIGGER_CAMERA=m
+CONFIG_LEDS_TRIGGER_PANIC=y
+CONFIG_LEDS_TRIGGER_NETDEV=y
+CONFIG_ACCESSIBILITY=y
+CONFIG_A11Y_BRAILLE_CONSOLE=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_ABB5ZES3=y
+CONFIG_RTC_DRV_ABEOZ9=y
+CONFIG_RTC_DRV_ABX80X=y
+CONFIG_RTC_DRV_AC100=y
+CONFIG_RTC_DRV_DS1307=y
+CONFIG_RTC_DRV_DS1374=y
+CONFIG_RTC_DRV_DS1374_WDT=y
+CONFIG_RTC_DRV_DS1672=y
+CONFIG_RTC_DRV_HYM8563=y
+CONFIG_RTC_DRV_MAX6900=y
+CONFIG_RTC_DRV_MAX77686=y
+CONFIG_RTC_DRV_RS5C372=y
+CONFIG_RTC_DRV_ISL1208=y
+CONFIG_RTC_DRV_ISL12022=y
+CONFIG_RTC_DRV_ISL12026=y
+CONFIG_RTC_DRV_X1205=y
+CONFIG_RTC_DRV_PCF8523=y
+CONFIG_RTC_DRV_PCF85063=y
+CONFIG_RTC_DRV_PCF85363=y
+CONFIG_RTC_DRV_PCF8563=y
+CONFIG_RTC_DRV_PCF8583=y
+CONFIG_RTC_DRV_M41T80=y
+CONFIG_RTC_DRV_M41T80_WDT=y
+CONFIG_RTC_DRV_BQ32K=y
+CONFIG_RTC_DRV_TWL4030=y
+CONFIG_RTC_DRV_PALMAS=y
+CONFIG_RTC_DRV_TPS65910=y
+CONFIG_RTC_DRV_S35390A=y
+CONFIG_RTC_DRV_FM3130=m
+CONFIG_RTC_DRV_RX8010=y
+CONFIG_RTC_DRV_RX8581=y
+CONFIG_RTC_DRV_RX8025=y
+CONFIG_RTC_DRV_EM3027=y
+CONFIG_RTC_DRV_RV8803=y
+CONFIG_RTC_DRV_M41T93=y
+CONFIG_RTC_DRV_M41T94=y
+CONFIG_RTC_DRV_DS1302=y
+CONFIG_RTC_DRV_DS1305=y
+CONFIG_RTC_DRV_DS1343=y
+CONFIG_RTC_DRV_DS1347=y
+CONFIG_RTC_DRV_DS1390=y
+CONFIG_RTC_DRV_MAX6916=y
+CONFIG_RTC_DRV_R9701=y
+CONFIG_RTC_DRV_RX4581=y
+CONFIG_RTC_DRV_RX6110=y
+CONFIG_RTC_DRV_RS5C348=y
+CONFIG_RTC_DRV_MAX6902=y
+CONFIG_RTC_DRV_PCF2123=y
+CONFIG_RTC_DRV_MCP795=y
+CONFIG_RTC_DRV_DS3232=y
+CONFIG_RTC_DRV_PCF2127=y
+CONFIG_RTC_DRV_RV3029C2=y
+CONFIG_RTC_DRV_DS1286=m
+CONFIG_RTC_DRV_DS1511=m
+CONFIG_RTC_DRV_DS1553=m
+CONFIG_RTC_DRV_DS1685_FAMILY=m
+CONFIG_RTC_DRV_DS1742=m
+CONFIG_RTC_DRV_DS2404=m
+CONFIG_RTC_DRV_DA9052=y
+CONFIG_RTC_DRV_STK17TA8=m
+CONFIG_RTC_DRV_M48T86=m
+CONFIG_RTC_DRV_M48T35=m
+CONFIG_RTC_DRV_M48T59=m
+CONFIG_RTC_DRV_MSM6242=m
+CONFIG_RTC_DRV_BQ4802=m
+CONFIG_RTC_DRV_RP5C01=m
+CONFIG_RTC_DRV_V3020=m
+CONFIG_RTC_DRV_IMXDI=y
+CONFIG_RTC_DRV_OMAP=y
+CONFIG_RTC_DRV_SUNXI=y
+CONFIG_RTC_DRV_MC13XXX=m
+CONFIG_RTC_DRV_MXC=y
+CONFIG_RTC_DRV_MXC_V2=y
+CONFIG_RTC_DRV_SNVS=y
+CONFIG_RTC_DRV_R7301=y
+CONFIG_RTC_DRV_HID_SENSOR_TIME=m
+CONFIG_DMADEVICES=y
+CONFIG_DMA_SUN6I=y
+CONFIG_FSL_EDMA=y
+CONFIG_IMX_DMA=y
+CONFIG_IMX_SDMA=y
+CONFIG_MXS_DMA=y
+CONFIG_DW_DMAC=y
+CONFIG_TI_CPPI41=y
+CONFIG_ASYNC_TX_DMA=y
+CONFIG_AUXDISPLAY=y
+CONFIG_HD44780=m
+CONFIG_IMG_ASCII_LCD=m
+CONFIG_HT16K33=m
+CONFIG_UIO=m
+CONFIG_VIRT_DRIVERS=y
+CONFIG_VIRTIO_BALLOON=m
+CONFIG_VIRTIO_INPUT=m
+CONFIG_VIRTIO_MMIO=m
+CONFIG_GREYBUS=m
+CONFIG_GREYBUS_ES2=m
+CONFIG_STAGING=y
+CONFIG_RTLLIB=m
+CONFIG_RTL8723BS=m
+CONFIG_R8712U=m
+CONFIG_R8188EU=m
+CONFIG_ADIS16203=m
+CONFIG_ADIS16240=m
+CONFIG_AD7816=m
+CONFIG_AD7280=m
+CONFIG_ADT7316=m
+CONFIG_ADT7316_I2C=m
+CONFIG_AD7150=m
+CONFIG_AD7746=m
+CONFIG_AD9832=m
+CONFIG_AD9834=m
+CONFIG_AD5933=m
+CONFIG_ADE7854=m
+CONFIG_AD2S1210=m
+CONFIG_FB_TFT=m
+CONFIG_FB_TFT_AGM1264K_FL=m
+CONFIG_FB_TFT_BD663474=m
+CONFIG_FB_TFT_HX8340BN=m
+CONFIG_FB_TFT_HX8347D=m
+CONFIG_FB_TFT_HX8353D=m
+CONFIG_FB_TFT_HX8357D=m
+CONFIG_FB_TFT_ILI9163=m
+CONFIG_FB_TFT_ILI9320=m
+CONFIG_FB_TFT_ILI9325=m
+CONFIG_FB_TFT_ILI9340=m
+CONFIG_FB_TFT_ILI9341=m
+CONFIG_FB_TFT_ILI9481=m
+CONFIG_FB_TFT_ILI9486=m
+CONFIG_FB_TFT_PCD8544=m
+CONFIG_FB_TFT_RA8875=m
+CONFIG_FB_TFT_S6D02A1=m
+CONFIG_FB_TFT_S6D1121=m
+CONFIG_FB_TFT_SH1106=m
+CONFIG_FB_TFT_SSD1289=m
+CONFIG_FB_TFT_SSD1305=m
+CONFIG_FB_TFT_SSD1306=m
+CONFIG_FB_TFT_SSD1331=m
+CONFIG_FB_TFT_SSD1351=m
+CONFIG_FB_TFT_ST7735R=m
+CONFIG_FB_TFT_ST7789V=m
+CONFIG_FB_TFT_TINYLCD=m
+CONFIG_FB_TFT_TLS8204=m
+CONFIG_FB_TFT_UC1611=m
+CONFIG_FB_TFT_UC1701=m
+CONFIG_FB_TFT_UPD161704=m
+CONFIG_FB_TFT_WATTEROTT=m
+CONFIG_GREYBUS_AUDIO=m
+CONFIG_GREYBUS_BOOTROM=m
+CONFIG_GREYBUS_FIRMWARE=m
+CONFIG_GREYBUS_HID=m
+CONFIG_GREYBUS_LIGHT=m
+CONFIG_GREYBUS_LOG=m
+CONFIG_GREYBUS_LOOPBACK=m
+CONFIG_GREYBUS_POWER=m
+CONFIG_GREYBUS_RAW=m
+CONFIG_GREYBUS_VIBRATOR=m
+CONFIG_GREYBUS_BRIDGED_PHY=m
+CONFIG_GREYBUS_GPIO=m
+CONFIG_GREYBUS_I2C=m
+CONFIG_GREYBUS_PWM=m
+CONFIG_GREYBUS_SDIO=m
+CONFIG_GREYBUS_SPI=m
+CONFIG_GREYBUS_UART=m
+CONFIG_GREYBUS_USB=m
+CONFIG_COMMON_CLK_MAX77686=m
+CONFIG_COMMON_CLK_SI5351=m
+CONFIG_CLK_TWL6040=y
+CONFIG_COMMON_CLK_PALMAS=y
+CONFIG_HWSPINLOCK=y
+CONFIG_HWSPINLOCK_OMAP=y
+CONFIG_OMAP2PLUS_MBOX=y
+CONFIG_OMAP_IOMMU=y
+CONFIG_REMOTEPROC=y
+CONFIG_IMX_REMOTEPROC=m
+CONFIG_OMAP_REMOTEPROC=m
+CONFIG_OMAP_REMOTEPROC_WATCHDOG=y
+CONFIG_WKUP_M3_RPROC=y
+CONFIG_RPMSG_CHAR=m
+CONFIG_RPMSG_VIRTIO=m
+CONFIG_SOC_TI=y
+CONFIG_AMX3_PM=y
+CONFIG_WKUP_M3_IPC=y
+CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
+CONFIG_DEVFREQ_GOV_PERFORMANCE=y
+CONFIG_DEVFREQ_GOV_POWERSAVE=y
+CONFIG_DEVFREQ_GOV_USERSPACE=y
+CONFIG_DEVFREQ_GOV_PASSIVE=y
+CONFIG_EXTCON_GPIO=y
+CONFIG_EXTCON_PALMAS=y
+CONFIG_EXTCON_USB_GPIO=y
+CONFIG_TI_EMIF=y
+CONFIG_TI_EMIF_SRAM=y
+CONFIG_IIO=m
+CONFIG_IIO_SW_DEVICE=m
+CONFIG_IIO_SW_TRIGGER=m
+CONFIG_ADIS16201=m
+CONFIG_ADIS16209=m
+CONFIG_ADXL345_I2C=m
+CONFIG_ADXL345_SPI=m
+CONFIG_ADXL372_SPI=m
+CONFIG_ADXL372_I2C=m
+CONFIG_BMA180=m
+CONFIG_BMA220=m
+CONFIG_BMA400=m
+CONFIG_BMC150_ACCEL=m
+CONFIG_DA280=m
+CONFIG_DA311=m
+CONFIG_DMARD06=m
+CONFIG_DMARD09=m
+CONFIG_DMARD10=m
+CONFIG_HID_SENSOR_ACCEL_3D=m
+CONFIG_IIO_ST_ACCEL_3AXIS=m
+CONFIG_KXSD9=m
+CONFIG_KXCJK1013=m
+CONFIG_MC3230=m
+CONFIG_MMA7455_I2C=m
+CONFIG_MMA7455_SPI=m
+CONFIG_MMA7660=m
+CONFIG_MMA8452=m
+CONFIG_MMA9551=m
+CONFIG_MMA9553=m
+CONFIG_MXC4005=m
+CONFIG_MXC6255=m
+CONFIG_SCA3000=m
+CONFIG_STK8312=m
+CONFIG_STK8BA50=m
+CONFIG_AD7091R5=m
+CONFIG_AD7124=m
+CONFIG_AD7192=m
+CONFIG_AD7266=m
+CONFIG_AD7291=m
+CONFIG_AD7298=m
+CONFIG_AD7476=m
+CONFIG_AD7606_IFACE_SPI=m
+CONFIG_AD7766=m
+CONFIG_AD7768_1=m
+CONFIG_AD7780=m
+CONFIG_AD7791=m
+CONFIG_AD7793=m
+CONFIG_AD7887=m
+CONFIG_AD7923=m
+CONFIG_AD7949=m
+CONFIG_AD799X=m
+CONFIG_AXP20X_ADC=m
+CONFIG_AXP288_ADC=m
+CONFIG_CC10001_ADC=m
+CONFIG_ENVELOPE_DETECTOR=m
+CONFIG_HI8435=m
+CONFIG_HX711=m
+CONFIG_INA2XX_ADC=m
+CONFIG_IMX7D_ADC=m
+CONFIG_LTC2471=m
+CONFIG_LTC2485=m
+CONFIG_LTC2496=m
+CONFIG_LTC2497=m
+CONFIG_MAX1027=m
+CONFIG_MAX11100=m
+CONFIG_MAX1118=m
+CONFIG_MAX1363=m
+CONFIG_MAX9611=m
+CONFIG_MCP320X=m
+CONFIG_MCP3422=m
+CONFIG_MCP3911=m
+CONFIG_NAU7802=m
+CONFIG_PALMAS_GPADC=m
+CONFIG_SD_ADC_MODULATOR=m
+CONFIG_STMPE_ADC=m
+CONFIG_SUN4I_GPADC=m
+CONFIG_TI_ADC081C=m
+CONFIG_TI_ADC0832=m
+CONFIG_TI_ADC084S021=m
+CONFIG_TI_ADC12138=m
+CONFIG_TI_ADC108S102=m
+CONFIG_TI_ADC128S052=m
+CONFIG_TI_ADC161S626=m
+CONFIG_TI_ADS1015=m
+CONFIG_TI_ADS7950=m
+CONFIG_TI_ADS8344=m
+CONFIG_TI_ADS8688=m
+CONFIG_TI_ADS124S08=m
+CONFIG_TI_AM335X_ADC=m
+CONFIG_TI_TLC4541=m
+CONFIG_TWL4030_MADC=m
+CONFIG_TWL6030_GPADC=m
+CONFIG_IIO_RESCALE=m
+CONFIG_AD8366=m
+CONFIG_HMC425=m
+CONFIG_ATLAS_PH_SENSOR=m
+CONFIG_BME680=m
+CONFIG_CCS811=m
+CONFIG_IAQCORE=m
+CONFIG_PMS7003=m
+CONFIG_SENSIRION_SGP30=m
+CONFIG_SPS30=m
+CONFIG_VZ89X=m
+CONFIG_AD5064=m
+CONFIG_AD5360=m
+CONFIG_AD5380=m
+CONFIG_AD5421=m
+CONFIG_AD5446=m
+CONFIG_AD5449=m
+CONFIG_AD5592R=m
+CONFIG_AD5593R=m
+CONFIG_AD5504=m
+CONFIG_AD5624R_SPI=m
+CONFIG_AD5686_SPI=m
+CONFIG_AD5696_I2C=m
+CONFIG_AD5755=m
+CONFIG_AD5758=m
+CONFIG_AD5761=m
+CONFIG_AD5764=m
+CONFIG_AD5770R=m
+CONFIG_AD5791=m
+CONFIG_AD7303=m
+CONFIG_AD8801=m
+CONFIG_DPOT_DAC=m
+CONFIG_DS4424=m
+CONFIG_LTC1660=m
+CONFIG_LTC2632=m
+CONFIG_M62332=m
+CONFIG_MAX517=m
+CONFIG_MAX5821=m
+CONFIG_MCP4725=m
+CONFIG_MCP4922=m
+CONFIG_TI_DAC082S085=m
+CONFIG_TI_DAC5571=m
+CONFIG_TI_DAC7311=m
+CONFIG_TI_DAC7612=m
+CONFIG_AD9523=m
+CONFIG_ADF4350=m
+CONFIG_ADF4371=m
+CONFIG_ADIS16080=m
+CONFIG_ADIS16130=m
+CONFIG_ADIS16136=m
+CONFIG_ADIS16260=m
+CONFIG_ADXRS450=m
+CONFIG_BMG160=m
+CONFIG_FXAS21002C=m
+CONFIG_HID_SENSOR_GYRO_3D=m
+CONFIG_MPU3050_I2C=m
+CONFIG_IIO_ST_GYRO_3AXIS=m
+CONFIG_ITG3200=m
+CONFIG_AFE4403=m
+CONFIG_AFE4404=m
+CONFIG_MAX30100=m
+CONFIG_MAX30102=m
+CONFIG_AM2315=m
+CONFIG_DHT11=m
+CONFIG_HDC100X=m
+CONFIG_HID_SENSOR_HUMIDITY=m
+CONFIG_HTS221=m
+CONFIG_HTU21=m
+CONFIG_SI7005=m
+CONFIG_SI7020=m
+CONFIG_ADIS16400=m
+CONFIG_ADIS16460=m
+CONFIG_ADIS16480=m
+CONFIG_BMI160_I2C=m
+CONFIG_BMI160_SPI=m
+CONFIG_KMX61=m
+CONFIG_INV_MPU6050_I2C=m
+CONFIG_INV_MPU6050_SPI=m
+CONFIG_IIO_ST_LSM6DSX=m
+CONFIG_ADJD_S311=m
+CONFIG_AL3010=m
+CONFIG_AL3320A=m
+CONFIG_APDS9300=m
+CONFIG_APDS9960=m
+CONFIG_BH1750=m
+CONFIG_BH1780=m
+CONFIG_CM32181=m
+CONFIG_CM3232=m
+CONFIG_CM3323=m
+CONFIG_CM3605=m
+CONFIG_CM36651=m
+CONFIG_GP2AP002=m
+CONFIG_GP2AP020A00F=m
+CONFIG_SENSORS_ISL29018=m
+CONFIG_SENSORS_ISL29028=m
+CONFIG_ISL29125=m
+CONFIG_HID_SENSOR_ALS=m
+CONFIG_HID_SENSOR_PROX=m
+CONFIG_JSA1212=m
+CONFIG_RPR0521=m
+CONFIG_LTR501=m
+CONFIG_LV0104CS=m
+CONFIG_MAX44000=m
+CONFIG_MAX44009=m
+CONFIG_NOA1305=m
+CONFIG_OPT3001=m
+CONFIG_PA12203001=m
+CONFIG_SI1133=m
+CONFIG_SI1145=m
+CONFIG_STK3310=m
+CONFIG_ST_UVIS25=m
+CONFIG_TCS3414=m
+CONFIG_TCS3472=m
+CONFIG_SENSORS_TSL2563=m
+CONFIG_TSL2583=m
+CONFIG_TSL2772=m
+CONFIG_TSL4531=m
+CONFIG_US5182D=m
+CONFIG_VCNL4000=m
+CONFIG_VCNL4035=m
+CONFIG_VEML6070=m
+CONFIG_VL6180=m
+CONFIG_ZOPT2201=m
+CONFIG_AK8974=m
+CONFIG_AK09911=m
+CONFIG_BMC150_MAGN_I2C=m
+CONFIG_BMC150_MAGN_SPI=m
+CONFIG_MAG3110=m
+CONFIG_HID_SENSOR_MAGNETOMETER_3D=m
+CONFIG_MMC35240=m
+CONFIG_IIO_ST_MAGN_3AXIS=m
+CONFIG_SENSORS_HMC5843_I2C=m
+CONFIG_SENSORS_HMC5843_SPI=m
+CONFIG_SENSORS_RM3100_I2C=m
+CONFIG_SENSORS_RM3100_SPI=m
+CONFIG_HID_SENSOR_INCLINOMETER_3D=m
+CONFIG_HID_SENSOR_DEVICE_ROTATION=m
+CONFIG_IIO_HRTIMER_TRIGGER=m
+CONFIG_IIO_INTERRUPT_TRIGGER=m
+CONFIG_IIO_TIGHTLOOP_TRIGGER=m
+CONFIG_IIO_SYSFS_TRIGGER=m
+CONFIG_AD5272=m
+CONFIG_DS1803=m
+CONFIG_MAX5432=m
+CONFIG_MAX5481=m
+CONFIG_MAX5487=m
+CONFIG_MCP4018=m
+CONFIG_MCP4131=m
+CONFIG_MCP4531=m
+CONFIG_MCP41010=m
+CONFIG_TPL0102=m
+CONFIG_LMP91000=m
+CONFIG_ABP060MG=m
+CONFIG_BMP280=m
+CONFIG_DLHL60D=m
+CONFIG_DPS310=m
+CONFIG_HID_SENSOR_PRESS=m
+CONFIG_HP03=m
+CONFIG_ICP10100=m
+CONFIG_MPL115_I2C=m
+CONFIG_MPL115_SPI=m
+CONFIG_MPL3115=m
+CONFIG_MS5611=m
+CONFIG_MS5611_I2C=m
+CONFIG_MS5611_SPI=m
+CONFIG_MS5637=m
+CONFIG_IIO_ST_PRESS=m
+CONFIG_T5403=m
+CONFIG_HP206C=m
+CONFIG_ZPA2326=m
+CONFIG_AS3935=m
+CONFIG_ISL29501=m
+CONFIG_LIDAR_LITE_V2=m
+CONFIG_MB1232=m
+CONFIG_PING=m
+CONFIG_RFD77402=m
+CONFIG_SRF04=m
+CONFIG_SX9500=m
+CONFIG_SRF08=m
+CONFIG_VL53L0X_I2C=m
+CONFIG_AD2S90=m
+CONFIG_AD2S1200=m
+CONFIG_MAXIM_THERMOCOUPLE=m
+CONFIG_HID_SENSOR_TEMP=m
+CONFIG_MLX90614=m
+CONFIG_MLX90632=m
+CONFIG_TMP006=m
+CONFIG_TMP007=m
+CONFIG_TSYS01=m
+CONFIG_TSYS02D=m
+CONFIG_MAX31856=m
+CONFIG_PWM_IMX27=m
+CONFIG_PWM_OMAP_DMTIMER=m
+CONFIG_PWM_PCA9685=m
+CONFIG_PWM_STMPE=y
+CONFIG_PWM_SUN4I=m
+CONFIG_PWM_TIECAP=m
+CONFIG_PWM_TIEHRPWM=m
+CONFIG_PWM_TWL=m
+CONFIG_PWM_TWL_LED=m
+CONFIG_RESET_TI_SYSCON=y
+CONFIG_PHY_SUN4I_USB=y
+CONFIG_PHY_SUN9I_USB=y
+CONFIG_PHY_SAMSUNG_USB2=m
+CONFIG_OMAP_USB2=y
+CONFIG_TI_PIPE3=m
+CONFIG_TWL4030_USB=y
+CONFIG_RAS=y
+CONFIG_NVMEM_SUNXI_SID=m
+CONFIG_FPGA=m
+CONFIG_ALTERA_PR_IP_CORE=m
+CONFIG_ALTERA_PR_IP_CORE_PLAT=m
+CONFIG_FPGA_MGR_ALTERA_PS_SPI=m
+CONFIG_FPGA_MGR_XILINX_SPI=m
+CONFIG_FPGA_MGR_ICE40_SPI=m
+CONFIG_FPGA_MGR_MACHXO2_SPI=m
+CONFIG_FPGA_BRIDGE=m
+CONFIG_ALTERA_FREEZE_BRIDGE=m
+CONFIG_XILINX_PR_DECOUPLER=m
+CONFIG_FPGA_REGION=m
+CONFIG_OF_FPGA_REGION=m
+CONFIG_COUNTER=m
+CONFIG_TI_EQEP=m
+CONFIG_VALIDATE_FS_PARSER=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_JFS_FS=m
+CONFIG_JFS_POSIX_ACL=y
+CONFIG_JFS_SECURITY=y
+CONFIG_GFS2_FS=m
+CONFIG_GFS2_FS_LOCKING_DLM=y
+CONFIG_BTRFS_FS=y
+CONFIG_BTRFS_FS_POSIX_ACL=y
+CONFIG_F2FS_FS=y
+CONFIG_F2FS_FS_SECURITY=y
+CONFIG_FS_ENCRYPTION=y
+CONFIG_FS_VERITY=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+CONFIG_QFMT_V2=m
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=m
+CONFIG_OVERLAY_FS=y
+CONFIG_FSCACHE=m
+CONFIG_FSCACHE_STATS=y
+CONFIG_CACHEFILES=m
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+CONFIG_FAT_DEFAULT_UTF8=y
+CONFIG_EXFAT_FS=m
+CONFIG_NTFS_FS=m
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_ECRYPT_FS=m
+CONFIG_ECRYPT_FS_MESSAGING=y
+CONFIG_JFFS2_FS=m
+CONFIG_JFFS2_SUMMARY=y
+CONFIG_JFFS2_FS_XATTR=y
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_LZO=y
+CONFIG_UBIFS_FS=y
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+CONFIG_SQUASHFS=m
+CONFIG_SQUASHFS_XATTR=y
+CONFIG_SQUASHFS_LZ4=y
+CONFIG_SQUASHFS_LZO=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_SQUASHFS_ZSTD=y
+CONFIG_ROMFS_FS=m
+CONFIG_ROMFS_BACKED_BY_BOTH=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_SWAP=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_ROOT_NFS=y
+CONFIG_NFSD=m
+CONFIG_NFSD_V3_ACL=y
+CONFIG_NFSD_V4=y
+CONFIG_NFSD_BLOCKLAYOUT=y
+CONFIG_NFSD_V4_SECURITY_LABEL=y
+CONFIG_SUNRPC_DEBUG=y
+CONFIG_CEPH_FS=m
+CONFIG_CEPH_FSCACHE=y
+CONFIG_CEPH_FS_POSIX_ACL=y
+CONFIG_CIFS=m
+CONFIG_CIFS_WEAK_PW_HASH=y
+CONFIG_CIFS_UPCALL=y
+CONFIG_CIFS_XATTR=y
+CONFIG_CIFS_POSIX=y
+CONFIG_CIFS_DFS_UPCALL=y
+CONFIG_CIFS_FSCACHE=y
+CONFIG_CODA_FS=m
+CONFIG_AFS_FS=m
+CONFIG_AFS_FSCACHE=y
+CONFIG_9P_FS=m
+CONFIG_9P_FSCACHE=y
+CONFIG_9P_FS_POSIX_ACL=y
+CONFIG_9P_FS_SECURITY=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_MAC_ROMAN=m
+CONFIG_NLS_MAC_CELTIC=m
+CONFIG_NLS_MAC_CENTEURO=m
+CONFIG_NLS_MAC_CROATIAN=m
+CONFIG_NLS_MAC_CYRILLIC=m
+CONFIG_NLS_MAC_GAELIC=m
+CONFIG_NLS_MAC_GREEK=m
+CONFIG_NLS_MAC_ICELAND=m
+CONFIG_NLS_MAC_INUIT=m
+CONFIG_NLS_MAC_ROMANIAN=m
+CONFIG_NLS_MAC_TURKISH=m
+CONFIG_NLS_UTF8=y
+CONFIG_DLM=m
+CONFIG_DLM_DEBUG=y
+CONFIG_SECURITY=y
+CONFIG_SECURITY_NETWORK_XFRM=y
+CONFIG_HARDENED_USERCOPY=y
+# CONFIG_HARDENED_USERCOPY_FALLBACK is not set
+CONFIG_FORTIFY_SOURCE=y
+CONFIG_SECURITY_SELINUX=y
+CONFIG_SECURITY_TOMOYO=y
+CONFIG_SECURITY_APPARMOR=y
+CONFIG_SECURITY_YAMA=y
+CONFIG_INTEGRITY_SIGNATURE=y
+CONFIG_INTEGRITY_ASYMMETRIC_KEYS=y
+# CONFIG_INTEGRITY_TRUSTED_KEYRING is not set
+CONFIG_DEFAULT_SECURITY_APPARMOR=y
+CONFIG_LSM="yama,loadpin,safesetid,integrity,apparmor,selinux,smack,tomoyo"
+CONFIG_CRYPTO_USER=m
+CONFIG_CRYPTO_PCRYPT=m
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_DH=y
+CONFIG_CRYPTO_CHACHA20POLY1305=m
+CONFIG_CRYPTO_AEGIS128=m
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_LRW=m
+CONFIG_CRYPTO_ADIANTUM=m
+CONFIG_CRYPTO_XCBC=m
+CONFIG_CRYPTO_VMAC=m
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
+CONFIG_CRYPTO_SHA3=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_LZ4=m
+CONFIG_CRYPTO_LZ4HC=m
+CONFIG_CRYPTO_ANSI_CPRNG=m
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+CONFIG_CRYPTO_USER_API_RNG=m
+CONFIG_CRYPTO_USER_API_AEAD=m
+CONFIG_CRYPTO_DEV_SUN4I_SS=y
+CONFIG_CRYPTO_DEV_FSL_CAAM=y
+CONFIG_CRYPTO_DEV_OMAP=y
+CONFIG_CRYPTO_DEV_OMAP_SHAM=y
+CONFIG_CRYPTO_DEV_OMAP_AES=y
+CONFIG_CRYPTO_DEV_OMAP_DES=y
+CONFIG_CRYPTO_DEV_SAHARA=y
+CONFIG_CRYPTO_DEV_ATMEL_ECC=y
+CONFIG_CRYPTO_DEV_ATMEL_SHA204A=y
+# CONFIG_RAID6_PQ_BENCHMARK is not set
+CONFIG_CORDIC=m
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_CMA_SIZE_MBYTES=48
+CONFIG_IRQ_POLL=y
+CONFIG_PRINTK_TIME=y
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x01b6
+CONFIG_PAGE_EXTENSION=y
+CONFIG_PAGE_POISONING=y
+CONFIG_SCHED_STACK_END_CHECK=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_SCHEDSTATS=y
+CONFIG_BUG_ON_DATA_CORRUPTION=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_STACK_TRACER=y
+CONFIG_FTRACE_SYSCALLS=y
+CONFIG_TRACER_SNAPSHOT=y
+CONFIG_BLK_DEV_IO_TRACE=y
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_NOTIFIER_ERROR_INJECTION=m
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff --git a/arch/arm/mach-imx/devices/Kconfig b/arch/arm/mach-imx/devices/Kconfig
index fdca73d117e6..95e0e8ee5dae 100644
--- a/arch/arm/mach-imx/devices/Kconfig
+++ b/arch/arm/mach-imx/devices/Kconfig
@@ -69,3 +69,9 @@ config IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX
 
 config IMX_HAVE_PLATFORM_SPI_IMX
 	bool
+
+config WAND_RFKILL
+	tristate "Wandboard RF Kill support"
+	depends on SOC_IMX6Q
+	default m
+	select RFKILL
diff --git a/arch/arm/mach-imx/devices/Makefile b/arch/arm/mach-imx/devices/Makefile
index e44758aaa11c..c179a5500929 100644
--- a/arch/arm/mach-imx/devices/Makefile
+++ b/arch/arm/mach-imx/devices/Makefile
@@ -26,3 +26,4 @@ obj-$(CONFIG_IMX_HAVE_PLATFORM_MXC_W1) += platform-mxc_w1.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX) += platform-sdhci-esdhc-imx.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_SPI_IMX) +=  platform-spi_imx.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_MX2_EMMA) += platform-mx2-emma.o
+obj-$(CONFIG_WAND_RFKILL) += wand-rfkill.o
diff --git a/arch/arm/mach-imx/devices/wand-rfkill.c b/arch/arm/mach-imx/devices/wand-rfkill.c
new file mode 100644
index 000000000000..da7ef9f4268a
--- /dev/null
+++ b/arch/arm/mach-imx/devices/wand-rfkill.c
@@ -0,0 +1,290 @@
+/*
+ * arch/arm/mach-imx/devices/wand-rfkill.c
+ *
+ * Copyright (C) 2013 Vladimir Ermakov <vooon341@gmail.com>
+ *
+ * based on net/rfkill/rfkill-gpio.c
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/rfkill.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+
+struct wand_rfkill_data {
+	struct rfkill *rfkill_dev;
+	int shutdown_gpio;
+	const char *shutdown_name;
+};
+
+static int wand_rfkill_set_block(void *data, bool blocked)
+{
+	struct wand_rfkill_data *rfkill = data;
+
+	pr_debug("wandboard-rfkill: set block %d\n", blocked);
+
+	if (blocked) {
+		if (gpio_is_valid(rfkill->shutdown_gpio))
+			gpio_direction_output(rfkill->shutdown_gpio, 0);
+	} else {
+		if (gpio_is_valid(rfkill->shutdown_gpio))
+			gpio_direction_output(rfkill->shutdown_gpio, 1);
+	}
+
+	return 0;
+}
+
+static const struct rfkill_ops wand_rfkill_ops = {
+	.set_block = wand_rfkill_set_block,
+};
+
+static int wand_rfkill_wifi_probe(struct device *dev,
+		struct device_node *np,
+		struct wand_rfkill_data *rfkill)
+{
+	int ret;
+	int wl_ref_on, wl_rst_n, wl_reg_on, wl_wake, wl_host_wake;
+
+	wl_ref_on = of_get_named_gpio(np, "wifi-ref-on", 0);
+	wl_rst_n = of_get_named_gpio(np, "wifi-rst-n", 0);
+	wl_reg_on = of_get_named_gpio(np, "wifi-reg-on", 0);
+	wl_wake = of_get_named_gpio(np, "wifi-wake", 0);
+	wl_host_wake = of_get_named_gpio(np, "wifi-host-wake", 0);
+
+	if (!gpio_is_valid(wl_rst_n) || !gpio_is_valid(wl_ref_on) ||
+			!gpio_is_valid(wl_reg_on) || !gpio_is_valid(wl_wake) ||
+			!gpio_is_valid(wl_host_wake)) {
+
+		dev_err(dev, "incorrect wifi gpios (%d %d %d %d %d)\n",
+				wl_rst_n, wl_ref_on, wl_reg_on, wl_wake, wl_host_wake);
+		return -EINVAL;
+	}
+
+	dev_info(dev, "initialize wifi chip\n");
+
+	gpio_request(wl_rst_n, "wl_rst_n");
+	gpio_direction_output(wl_rst_n, 0);
+	msleep(11);
+	gpio_set_value(wl_rst_n, 1);
+
+	gpio_request(wl_ref_on, "wl_ref_on");
+	gpio_direction_output(wl_ref_on, 1);
+
+	gpio_request(wl_reg_on, "wl_reg_on");
+	gpio_direction_output(wl_reg_on, 1);
+
+	gpio_request(wl_wake, "wl_wake");
+	gpio_direction_output(wl_wake, 1);
+
+	gpio_request(wl_host_wake, "wl_host_wake");
+	gpio_direction_input(wl_host_wake);
+
+	rfkill->shutdown_name = "wifi_shutdown";
+	rfkill->shutdown_gpio = wl_wake;
+
+	rfkill->rfkill_dev = rfkill_alloc("wifi-rfkill", dev, RFKILL_TYPE_WLAN,
+			&wand_rfkill_ops, rfkill);
+	if (!rfkill->rfkill_dev) {
+		ret = -ENOMEM;
+		goto wifi_fail_free_gpio;
+	}
+
+	ret = rfkill_register(rfkill->rfkill_dev);
+	if (ret < 0)
+		goto wifi_fail_unregister;
+
+	dev_info(dev, "wifi-rfkill registered.\n");
+
+	return 0;
+
+wifi_fail_unregister:
+	rfkill_destroy(rfkill->rfkill_dev);
+wifi_fail_free_gpio:
+	if (gpio_is_valid(wl_rst_n))     gpio_free(wl_rst_n);
+	if (gpio_is_valid(wl_ref_on))    gpio_free(wl_ref_on);
+	if (gpio_is_valid(wl_reg_on))    gpio_free(wl_reg_on);
+	if (gpio_is_valid(wl_wake))      gpio_free(wl_wake);
+	if (gpio_is_valid(wl_host_wake)) gpio_free(wl_host_wake);
+
+	return ret;
+}
+
+static int wand_rfkill_bt_probe(struct device *dev,
+		struct device_node *np,
+		struct wand_rfkill_data *rfkill)
+{
+	int ret;
+	int bt_on, bt_wake, bt_host_wake;
+
+	bt_on = of_get_named_gpio(np, "bluetooth-on", 0);
+	bt_wake = of_get_named_gpio(np, "bluetooth-wake", 0);
+	bt_host_wake = of_get_named_gpio(np, "bluetooth-host-wake", 0);
+
+	if (!gpio_is_valid(bt_on) || !gpio_is_valid(bt_wake) ||
+			!gpio_is_valid(bt_host_wake)) {
+
+		dev_err(dev, "incorrect bt gpios (%d %d %d)\n",
+				bt_on, bt_wake, bt_host_wake);
+		return -EINVAL;
+	}
+
+	dev_info(dev, "initialize bluetooth chip\n");
+
+	gpio_request(bt_on, "bt_on");
+	gpio_direction_output(bt_on, 0);
+	msleep(11);
+	gpio_set_value(bt_on, 1);
+
+	gpio_request(bt_wake, "bt_wake");
+	gpio_direction_output(bt_wake, 1);
+
+	gpio_request(bt_host_wake, "bt_host_wake");
+	gpio_direction_input(bt_host_wake);
+
+	rfkill->shutdown_name = "bluetooth_shutdown";
+	rfkill->shutdown_gpio = bt_wake;
+
+	rfkill->rfkill_dev = rfkill_alloc("bluetooth-rfkill", dev, RFKILL_TYPE_BLUETOOTH,
+			&wand_rfkill_ops, rfkill);
+	if (!rfkill->rfkill_dev) {
+		ret = -ENOMEM;
+		goto bt_fail_free_gpio;
+	}
+
+	ret = rfkill_register(rfkill->rfkill_dev);
+	if (ret < 0)
+		goto bt_fail_unregister;
+
+	dev_info(dev, "bluetooth-rfkill registered.\n");
+
+	return 0;
+
+bt_fail_unregister:
+	rfkill_destroy(rfkill->rfkill_dev);
+bt_fail_free_gpio:
+	if (gpio_is_valid(bt_on))        gpio_free(bt_on);
+	if (gpio_is_valid(bt_wake))      gpio_free(bt_wake);
+	if (gpio_is_valid(bt_host_wake)) gpio_free(bt_host_wake);
+
+	return ret;
+}
+
+static int wand_rfkill_probe(struct platform_device *pdev)
+{
+	struct wand_rfkill_data *rfkill;
+	struct pinctrl *pinctrl;
+	int ret;
+
+	dev_info(&pdev->dev, "Wandboard rfkill initialization\n");
+
+	if (!pdev->dev.of_node) {
+		dev_err(&pdev->dev, "no device tree node\n");
+		return -ENODEV;
+	}
+
+	rfkill = kzalloc(sizeof(*rfkill) * 2, GFP_KERNEL);
+	if (!rfkill)
+		return -ENOMEM;
+
+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(pinctrl)) {
+		int ret = PTR_ERR(pinctrl);
+		dev_err(&pdev->dev, "failed to get default pinctrl: %d\n", ret);
+		return ret;
+	}
+
+	/* setup WiFi */
+	ret = wand_rfkill_wifi_probe(&pdev->dev, pdev->dev.of_node, &rfkill[0]);
+	if (ret < 0)
+		goto fail_free_rfkill;
+
+	/* setup bluetooth */
+	ret = wand_rfkill_bt_probe(&pdev->dev, pdev->dev.of_node, &rfkill[1]);
+	if (ret < 0)
+		goto fail_unregister_wifi;
+
+	platform_set_drvdata(pdev, rfkill);
+
+	return 0;
+
+fail_unregister_wifi:
+	if (rfkill[1].rfkill_dev) {
+		rfkill_unregister(rfkill[1].rfkill_dev);
+		rfkill_destroy(rfkill[1].rfkill_dev);
+	}
+
+	/* TODO free gpio */
+
+fail_free_rfkill:
+	kfree(rfkill);
+
+	return ret;
+}
+
+static int wand_rfkill_remove(struct platform_device *pdev)
+{
+	struct wand_rfkill_data *rfkill = platform_get_drvdata(pdev);
+
+	dev_info(&pdev->dev, "Module unloading\n");
+
+	if (!rfkill)
+		return 0;
+
+	/* WiFi */
+	if (gpio_is_valid(rfkill[0].shutdown_gpio))
+		gpio_free(rfkill[0].shutdown_gpio);
+
+	rfkill_unregister(rfkill[0].rfkill_dev);
+	rfkill_destroy(rfkill[0].rfkill_dev);
+
+	/* Bt */
+	if (gpio_is_valid(rfkill[1].shutdown_gpio))
+		gpio_free(rfkill[1].shutdown_gpio);
+
+	rfkill_unregister(rfkill[1].rfkill_dev);
+	rfkill_destroy(rfkill[1].rfkill_dev);
+
+	kfree(rfkill);
+
+	return 0;
+}
+
+static struct of_device_id wand_rfkill_match[] = {
+	{ .compatible = "wand,imx6q-wandboard-rfkill", },
+	{ .compatible = "wand,imx6dl-wandboard-rfkill", },
+	{ .compatible = "wand,imx6qdl-wandboard-rfkill", },
+	{}
+};
+
+static struct platform_driver wand_rfkill_driver = {
+	.driver = {
+		.name = "wandboard-rfkill",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(wand_rfkill_match),
+	},
+	.probe = wand_rfkill_probe,
+	.remove = wand_rfkill_remove
+};
+
+module_platform_driver(wand_rfkill_driver);
+
+MODULE_AUTHOR("Vladimir Ermakov <vooon341@gmail.com>");
+MODULE_DESCRIPTION("Wandboard rfkill driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/Makefile b/drivers/Makefile
index c0cd1b9075e3..da81dab2c577 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -56,6 +56,9 @@ obj-$(CONFIG_RESET_CONTROLLER)	+= reset/
 obj-y				+= tty/
 obj-y				+= char/
 
+# put mmc early as many morden devices use emm/sd card as rootfs storage
+obj-y				+= mmc/
+
 # iommu/ comes before gpu as gpu are using iommu controllers
 obj-y				+= iommu/
 
@@ -128,7 +131,6 @@ obj-$(CONFIG_EISA)		+= eisa/
 obj-$(CONFIG_PM_OPP)		+= opp/
 obj-$(CONFIG_CPU_FREQ)		+= cpufreq/
 obj-$(CONFIG_CPU_IDLE)		+= cpuidle/
-obj-y				+= mmc/
 obj-$(CONFIG_MEMSTICK)		+= memstick/
 obj-$(CONFIG_NEW_LEDS)		+= leds/
 obj-$(CONFIG_INFINIBAND)	+= infiniband/
diff --git a/drivers/gnss/serial.c b/drivers/gnss/serial.c
index def64b36d994..473faeea6aae 100644
--- a/drivers/gnss/serial.c
+++ b/drivers/gnss/serial.c
@@ -110,10 +110,9 @@ static int gnss_serial_set_power(struct gnss_serial *gserial,
 static int gnss_serial_parse_dt(struct serdev_device *serdev)
 {
 	struct gnss_serial *gserial = serdev_device_get_drvdata(serdev);
-	struct device_node *node = serdev->dev.of_node;
 	u32 speed = 4800;
 
-	of_property_read_u32(node, "current-speed", &speed);
+	device_property_read_u32(&serdev->dev, "current-speed", &speed);
 
 	gserial->speed = speed;
 
diff --git a/drivers/gnss/ubx.c b/drivers/gnss/ubx.c
index 7b05bc40532e..e50056cc4223 100644
--- a/drivers/gnss/ubx.c
+++ b/drivers/gnss/ubx.c
@@ -138,6 +138,14 @@ static const struct of_device_id ubx_of_match[] = {
 MODULE_DEVICE_TABLE(of, ubx_of_match);
 #endif
 
+static const struct serdev_device_id ubx_serdev_id[] = {
+	{ "neo-6m", },
+	{ "neo-8", },
+	{ "neo-m8", },
+	{}
+};
+MODULE_DEVICE_TABLE(serdev, ubx_serdev_id);
+
 static struct serdev_device_driver ubx_driver = {
 	.driver	= {
 		.name		= "gnss-ubx",
@@ -146,6 +154,7 @@ static struct serdev_device_driver ubx_driver = {
 	},
 	.probe	= ubx_probe,
 	.remove	= ubx_remove,
+	.id_table = ubx_serdev_id,
 };
 module_serdev_device_driver(ubx_driver);
 
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 8030fd91a3cc..71f6ccb8e7a6 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -69,6 +69,20 @@ config GPIO_SYSFS
 	  ioctl() operations instead. The character device is always
 	  available.
 
+config GPIO_OF_HELPER
+	bool "GPIO OF helper device (EXPERIMENTAL)"
+	depends on OF_GPIO
+	help
+	  Say Y here to add an GPIO OF helper driver
+
+	  Allows you specify a GPIO helper based on OF
+	  which allows simple export of GPIO functionality
+	  in user-space.
+
+	  Features include, value set/get, direction control,
+	  interrupt/value change poll support, event counting
+	  and others.
+
 config GPIO_GENERIC
 	depends on HAS_IOMEM # Only for IOMEM drivers
 	tristate
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 4f9abff4f2dc..5d2fbba0b6d2 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_GPIOLIB)		+= gpiolib-cdev.o
 obj-$(CONFIG_OF_GPIO)		+= gpiolib-of.o
 obj-$(CONFIG_GPIO_SYSFS)	+= gpiolib-sysfs.o
 obj-$(CONFIG_GPIO_ACPI)		+= gpiolib-acpi.o
+obj-$(CONFIG_GPIO_OF_HELPER)	+= gpio-of-helper.o
 
 # Device drivers. Generally keep list sorted alphabetically
 obj-$(CONFIG_GPIO_REGMAP)	+= gpio-regmap.o
diff --git a/drivers/gpio/gpio-of-helper.c b/drivers/gpio/gpio-of-helper.c
new file mode 100644
index 000000000000..83f362f7da5f
--- /dev/null
+++ b/drivers/gpio/gpio-of-helper.c
@@ -0,0 +1,435 @@
+/*
+ * GPIO OF based helper
+ *
+ * A simple DT based driver to provide access to GPIO functionality
+ * to user-space via sysfs.
+ *
+ * Copyright (C) 2013 Pantelis Antoniou <panto@antoniou-consulting.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/atomic.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/math64.h>
+#include <linux/atomic.h>
+#include <linux/idr.h>
+
+/* fwd decl. */
+struct gpio_of_helper_info;
+
+enum gpio_type {
+	GPIO_TYPE_INPUT = 0,
+	GPIO_TYPE_OUTPUT = 1,
+};
+
+struct gpio_of_entry {
+	int id;
+	struct gpio_of_helper_info *info;
+	struct device_node *node;
+	enum gpio_type type;
+	int gpio;
+	int irq;
+	const char *name;
+	atomic64_t counter;
+	unsigned int count_flags;
+#define COUNT_RISING_EDGE	(1 << 0)
+#define COUNT_FALLING_EDGE	(1 << 1)
+};
+
+struct gpio_of_helper_info {
+	struct platform_device *pdev;
+	struct idr idr;
+};
+
+static const struct of_device_id gpio_of_helper_of_match[] = {
+	{
+		.compatible = "gpio-of-helper",
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, gpio_of_helper_of_match);
+
+static ssize_t gpio_of_helper_show_status(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct gpio_of_helper_info *info = platform_get_drvdata(pdev);
+	struct gpio_of_entry *entry;
+	char *p, *e;
+	int id, n;
+
+	p = buf;
+	e = p + PAGE_SIZE;
+	n = 0;
+	idr_for_each_entry(&info->idr, entry, id) {
+		switch (entry->type) {
+		case GPIO_TYPE_INPUT:
+			n = snprintf(p, e - p, "%2d %-24s %3d %-3s %llu\n",
+				entry->id, entry->name, entry->gpio, "IN",
+				(unsigned long long)
+					atomic64_read(&entry->counter));
+			break;
+		case GPIO_TYPE_OUTPUT:
+			n = snprintf(p, e - p, "%2d %-24s %3d %-3s\n",
+				entry->id, entry->name, entry->gpio, "OUT");
+			break;
+		}
+		p += n;
+	}
+
+	return p - buf;
+}
+
+static DEVICE_ATTR(status, S_IRUGO,
+		gpio_of_helper_show_status, NULL);
+
+static irqreturn_t gpio_of_helper_handler(int irq, void *ptr)
+{
+	struct gpio_of_entry *entry = ptr;
+
+	/* caution - low speed interfaces only! */
+	atomic64_inc(&entry->counter);
+
+	return IRQ_HANDLED;
+}
+
+static struct gpio_of_entry *
+gpio_of_entry_create(struct gpio_of_helper_info *info,
+		struct device_node *node)
+{
+	struct platform_device *pdev = info->pdev;
+	struct device *dev = &pdev->dev;
+	struct gpio_of_entry *entry;
+	int err, gpio, irq;
+	unsigned int req_flags, count_flags, irq_flags;
+	enum gpio_type type;
+	enum of_gpio_flags gpio_flags;
+	const char *name;
+
+	/* get the type of the node first */
+	if (of_property_read_bool(node, "input"))
+		type = GPIO_TYPE_INPUT;
+	else if (of_property_read_bool(node, "output")
+			|| of_property_read_bool(node, "init-low")
+			|| of_property_read_bool(node, "init-high"))
+		type = GPIO_TYPE_OUTPUT;
+	else {
+		dev_err(dev, "Not valid gpio node type\n");
+		err = -EINVAL;
+		goto err_bad_node;
+	}
+
+	/* get the name */
+	if (of_property_read_string(node, "line-name", &name))
+		if (of_property_read_string(node, "gpio-name", &name))
+			name = node->name;
+
+	err = of_get_named_gpio_flags(node, "gpio", 0, &gpio_flags);
+	if (IS_ERR_VALUE(err)) {
+		dev_err(dev, "Failed to get gpio property of '%s'\n", name);
+		goto err_bad_node;
+	}
+	gpio = err;
+
+	req_flags = 0;
+	count_flags = 0;
+
+	/* set the request flags */
+	switch (type) {
+		case GPIO_TYPE_INPUT:
+			req_flags = GPIOF_DIR_IN | GPIOF_EXPORT;
+			if (of_property_read_bool(node, "count-falling-edge"))
+				count_flags |= COUNT_FALLING_EDGE;
+			if (of_property_read_bool(node, "count-rising-edge"))
+				count_flags |= COUNT_RISING_EDGE;
+			break;
+		case GPIO_TYPE_OUTPUT:
+			req_flags = GPIOF_DIR_OUT | GPIOF_EXPORT;
+			if (of_property_read_bool(node, "init-high"))
+				req_flags |= GPIOF_OUT_INIT_HIGH;
+			else if (of_property_read_bool(node, "init-low"))
+				req_flags |= GPIOF_OUT_INIT_LOW;
+			break;
+	}
+	if (of_property_read_bool(node, "dir-changeable"))
+		req_flags |= GPIOF_EXPORT_CHANGEABLE;
+	if (gpio_flags & OF_GPIO_ACTIVE_LOW)
+		req_flags |= GPIOF_ACTIVE_LOW;
+	if (gpio_flags & OF_GPIO_SINGLE_ENDED) {
+		if (gpio_flags & OF_GPIO_ACTIVE_LOW)
+			req_flags |= GPIOF_OPEN_DRAIN;
+		else
+			req_flags |= GPIOF_OPEN_SOURCE;
+	}
+
+	/* request the gpio */
+	err = devm_gpio_request_one(dev, gpio, req_flags, name);
+	if (err != 0) {
+		dev_err(dev, "Failed to request gpio '%s'\n", name);
+		goto err_bad_node;
+	}
+
+	irq = -1;
+	irq_flags = 0;
+
+	/* counter mode requested - need an interrupt */
+	if (count_flags != 0) {
+		irq = gpio_to_irq(gpio);
+		if (IS_ERR_VALUE(irq)) {
+			dev_err(dev, "Failed to request gpio '%s'\n", name);
+			goto err_bad_node;
+		}
+
+		if (count_flags & COUNT_RISING_EDGE)
+			irq_flags |= IRQF_TRIGGER_RISING;
+		if (count_flags & COUNT_FALLING_EDGE)
+			irq_flags |= IRQF_TRIGGER_FALLING;
+	}
+
+//	if (!idr_pre_get(&info->idr, GFP_KERNEL)) {
+//		dev_err(dev, "Failed on idr_pre_get of '%s'\n", name);
+//		err = -ENOMEM;
+//		goto err_no_mem;
+//	}
+
+	idr_preload(GFP_KERNEL);
+
+	entry = devm_kzalloc(dev, sizeof(*entry), GFP_KERNEL);
+	if (entry == NULL) {
+		dev_err(dev, "Failed to allocate gpio entry of '%s'\n", name);
+		err = -ENOMEM;
+		goto err_no_mem;
+	}
+
+	entry->id = -1;
+	entry->info = info;
+	entry->node = of_node_get(node);	/* get node reference */
+	entry->type = type;
+	entry->gpio = gpio;
+	entry->irq = irq;
+	entry->name = name;
+
+	/* interrupt enable is last thing done */
+	if (irq >= 0) {
+		atomic64_set(&entry->counter, 0);
+		entry->count_flags = count_flags;
+		err = devm_request_irq(dev, irq, gpio_of_helper_handler,
+				irq_flags, name, entry);
+		if (err != 0) {
+			dev_err(dev, "Failed to request irq of '%s'\n", name);
+			goto err_no_irq;
+		}
+	}
+
+	/* all done; insert */
+//	err = idr_get_new(&info->idr, entry, &entry->id);
+//	if (IS_ERR_VALUE(err)) {
+//		dev_err(dev, "Failed to idr_get_new  of '%s'\n", name);
+//		goto err_fail_idr;
+//	}
+
+	err = idr_alloc(&info->idr, entry, 0, 0, GFP_NOWAIT);
+	if (err >= 0)
+		entry->id = err;
+
+	idr_preload_end();
+
+	if (err < 0) {
+		dev_err(dev, "Failed to idr_get_new  of '%s'\n", name);
+		goto err_fail_idr;
+	}
+
+	dev_dbg(dev, "Allocated GPIO id=%d name='%s'\n", entry->id, name);
+
+	return entry;
+
+err_fail_idr:
+	/* nothing to do */
+err_no_irq:
+	/* release node ref */
+	of_node_put(node);
+	/* nothing else needs to be done, devres handles it */
+err_no_mem:
+err_bad_node:
+	return ERR_PTR(err);
+}
+
+static int gpio_of_entry_destroy(struct gpio_of_entry *entry)
+{
+	struct gpio_of_helper_info *info = entry->info;
+	struct platform_device *pdev = info->pdev;
+	struct device *dev = &pdev->dev;
+
+	dev_dbg(dev, "Destroying GPIO id=%d\n", entry->id);
+
+	/* remove from the IDR */
+	idr_remove(&info->idr, entry->id);
+
+	/* remove node ref */
+	of_node_put(entry->node);
+
+	/* free gpio */
+	devm_gpio_free(dev, entry->gpio);
+
+	/* gree irq */
+	if (entry->irq >= 0)
+		devm_free_irq(dev, entry->irq, entry);
+
+	/* and free */
+	devm_kfree(dev, entry);
+
+	return 0;
+}
+
+static int gpio_of_helper_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct gpio_of_helper_info *info;
+	struct gpio_of_entry *entry;
+	struct device_node *pnode = pdev->dev.of_node;
+	struct device_node *cnode;
+	struct pinctrl *pinctrl;
+	int err;
+
+	/* we only support OF */
+	if (pnode == NULL) {
+		dev_err(&pdev->dev, "No platform of_node!\n");
+		return -ENODEV;
+	}
+
+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(pinctrl)) {
+		/* special handling for probe defer */
+		if (PTR_ERR(pinctrl) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+
+		dev_warn(&pdev->dev,
+			"pins are not configured from the driver\n");
+	}
+
+	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
+	if (info == NULL) {
+		dev_err(&pdev->dev, "Failed to allocate info\n");
+		err = -ENOMEM;
+		goto err_no_mem;
+	}
+	platform_set_drvdata(pdev, info);
+	info->pdev = pdev;
+
+	idr_init(&info->idr);
+
+	err = device_create_file(dev, &dev_attr_status);
+	if (err != 0) {
+		dev_err(dev, "Failed to create status sysfs attribute\n");
+		goto err_no_sysfs;
+	}
+
+	for_each_child_of_node(pnode, cnode) {
+
+		entry = gpio_of_entry_create(info, cnode);
+		if (IS_ERR_OR_NULL(entry)) {
+			dev_err(dev, "Failed to create gpio entry\n");
+			err = PTR_ERR(entry);
+			goto err_fail_entry;
+		}
+	}
+
+	dev_info(&pdev->dev, "ready\n");
+
+	return 0;
+err_fail_entry:
+	device_remove_file(&pdev->dev, &dev_attr_status);
+err_no_sysfs:
+err_no_mem:
+	return err;
+}
+
+static int gpio_of_helper_remove(struct platform_device *pdev)
+{
+	struct gpio_of_helper_info *info = platform_get_drvdata(pdev);
+	struct gpio_of_entry *entry;
+	int id;
+
+	dev_info(&pdev->dev, "removing\n");
+
+	device_remove_file(&pdev->dev, &dev_attr_status);
+
+	id = 0;
+	idr_for_each_entry(&info->idr, entry, id) {
+		/* destroy each and every one */
+		gpio_of_entry_destroy(entry);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+//#ifdef CONFIG_PM_RUNTIME
+static int gpio_of_helper_runtime_suspend(struct device *dev)
+{
+	/* place holder */
+	return 0;
+}
+
+static int gpio_of_helper_runtime_resume(struct device *dev)
+{
+	/* place holder */
+	return 0;
+}
+//#endif /* CONFIG_PM_RUNTIME */
+
+static struct dev_pm_ops gpio_of_helper_pm_ops = {
+	SET_RUNTIME_PM_OPS(gpio_of_helper_runtime_suspend,
+			   gpio_of_helper_runtime_resume, NULL)
+};
+#define GPIO_OF_HELPER_PM_OPS (&gpio_of_helper_pm_ops)
+#else
+#define GPIO_OF_HELPER_PM_OPS NULL
+#endif /* CONFIG_PM */
+
+struct platform_driver gpio_of_helper_driver = {
+	.probe		= gpio_of_helper_probe,
+	.remove		= gpio_of_helper_remove,
+	.driver = {
+		.name		= "gpio-of-helper",
+		.owner		= THIS_MODULE,
+		.pm		= GPIO_OF_HELPER_PM_OPS,
+		.of_match_table	= gpio_of_helper_of_match,
+	},
+};
+
+module_platform_driver(gpio_of_helper_driver);
+
+MODULE_AUTHOR("Pantelis Antoniou <panto@antoniou-consulting.com>");
+MODULE_DESCRIPTION("GPIO OF Helper driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:gpio-of-helper");
diff --git a/drivers/gpio/gpiolib-sysfs.c b/drivers/gpio/gpiolib-sysfs.c
index 728f6c687182..0a297d8672b4 100644
--- a/drivers/gpio/gpiolib-sysfs.c
+++ b/drivers/gpio/gpiolib-sysfs.c
@@ -38,10 +38,10 @@ static DEFINE_MUTEX(sysfs_lock);
 /*
  * /sys/class/gpio/gpioN... only for GPIOs that are exported
  *   /direction
- *      * MAY BE OMITTED if kernel won't allow direction changes
  *      * is read/write as "in" or "out"
  *      * may also be written as "high" or "low", initializing
  *        output value as specified ("out" implies "low")
+ *      * read-only if kernel won't allow direction changes
  *   /value
  *      * always readable, subject to hardware behavior
  *      * may be writable, as zero/nonzero
@@ -54,6 +54,8 @@ static DEFINE_MUTEX(sysfs_lock);
  *      * is read/write as zero/nonzero
  *      * also affects existing and subsequent "falling" and "rising"
  *        /edge configuration
+ *   /label
+ *      * descriptor label
  */
 
 static ssize_t direction_show(struct device *dev,
@@ -84,7 +86,9 @@ static ssize_t direction_store(struct device *dev,
 
 	mutex_lock(&data->mutex);
 
-	if (sysfs_streq(buf, "high"))
+	if (!data->direction_can_change)
+		status = -EPERM;
+	else if (sysfs_streq(buf, "high"))
 		status = gpiod_direction_output_raw(desc, 1);
 	else if (sysfs_streq(buf, "out") || sysfs_streq(buf, "low"))
 		status = gpiod_direction_output_raw(desc, 0);
@@ -363,6 +367,23 @@ static ssize_t active_low_store(struct device *dev,
 }
 static DEVICE_ATTR_RW(active_low);
 
+static ssize_t label_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct gpiod_data *data = dev_get_drvdata(dev);
+	struct gpio_desc *desc = data->desc;
+	ssize_t			status;
+
+	mutex_lock(&data->mutex);
+
+	status = sprintf(buf, "%s\n", desc->label);
+
+	mutex_unlock(&data->mutex);
+
+	return status;
+}
+static DEVICE_ATTR_RO(label);
+
 static umode_t gpio_is_visible(struct kobject *kobj, struct attribute *attr,
 			       int n)
 {
@@ -374,12 +395,15 @@ static umode_t gpio_is_visible(struct kobject *kobj, struct attribute *attr,
 
 	if (attr == &dev_attr_direction.attr) {
 		if (!show_direction)
-			mode = 0;
+			mode &= 0444;
 	} else if (attr == &dev_attr_edge.attr) {
 		if (gpiod_to_irq(desc) < 0)
 			mode = 0;
 		if (!show_direction && test_bit(FLAG_IS_OUT, &desc->flags))
 			mode = 0;
+	} else if (attr == &dev_attr_value.attr) {
+		if (!show_direction && !test_bit(FLAG_IS_OUT, &desc->flags))
+			mode &= 0444;
 	}
 
 	return mode;
@@ -390,6 +414,7 @@ static struct attribute *gpio_attrs[] = {
 	&dev_attr_edge.attr,
 	&dev_attr_value.attr,
 	&dev_attr_active_low.attr,
+	&dev_attr_label.attr,
 	NULL,
 };
 
@@ -403,6 +428,10 @@ static const struct attribute_group *gpio_groups[] = {
 	NULL
 };
 
+/* bwlegh, a second device in the same file... get out of my namespace! */
+#define dev_attr_label dev_attr_chip_label
+#define label_show chip_label_show
+
 /*
  * /sys/class/gpio/gpiochipN/
  *   /base ... matching gpio_chip.base (N)
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index 80137c1b3cdc..ad68b7bdcb54 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -1918,10 +1918,10 @@ static int gpiod_request_commit(struct gpio_desc *desc, const char *label)
 	if (test_and_set_bit(FLAG_REQUESTED, &desc->flags) == 0) {
 		desc_set_label(desc, label ? : "?");
 		ret = 0;
-	} else {
-		kfree_const(label);
-		ret = -EBUSY;
-		goto done;
+//	} else {
+//		kfree_const(label);
+//		ret = -EBUSY;
+//		goto done;
 	}
 
 	if (gc->request) {
diff --git a/drivers/iio/light/tsl2563.c b/drivers/iio/light/tsl2563.c
index abc8d7db8dc1..5bf2bfbc5379 100644
--- a/drivers/iio/light/tsl2563.c
+++ b/drivers/iio/light/tsl2563.c
@@ -12,6 +12,8 @@
  */
 
 #include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/property.h>
 #include <linux/i2c.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
@@ -703,7 +705,6 @@ static int tsl2563_probe(struct i2c_client *client,
 	struct iio_dev *indio_dev;
 	struct tsl2563_chip *chip;
 	struct tsl2563_platform_data *pdata = client->dev.platform_data;
-	struct device_node *np = client->dev.of_node;
 	int err = 0;
 	u8 id = 0;
 
@@ -738,13 +739,14 @@ static int tsl2563_probe(struct i2c_client *client,
 	chip->calib0 = tsl2563_calib_from_sysfs(CALIB_BASE_SYSFS);
 	chip->calib1 = tsl2563_calib_from_sysfs(CALIB_BASE_SYSFS);
 
-	if (pdata)
+	if (pdata) {
 		chip->cover_comp_gain = pdata->cover_comp_gain;
-	else if (np)
-		of_property_read_u32(np, "amstaos,cover-comp-gain",
-				     &chip->cover_comp_gain);
-	else
-		chip->cover_comp_gain = 1;
+	} else {
+		err = device_property_read_u32(&client->dev, "amstaos,cover-comp-gain",
+					       &chip->cover_comp_gain);
+		if (err)
+			chip->cover_comp_gain = 1;
+	}
 
 	dev_info(&client->dev, "model %d, rev. %d\n", id >> 4, id & 0x0f);
 	indio_dev->name = client->name;
diff --git a/drivers/iio/light/vcnl4035.c b/drivers/iio/light/vcnl4035.c
index 765c44adac57..73a28e30dddc 100644
--- a/drivers/iio/light/vcnl4035.c
+++ b/drivers/iio/light/vcnl4035.c
@@ -652,6 +652,12 @@ static const struct dev_pm_ops vcnl4035_pm_ops = {
 			   vcnl4035_runtime_resume, NULL)
 };
 
+static const struct i2c_device_id vcnl4035_id[] = {
+	{ "vcnl4035", 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, vcnl4035_id);
+
 static const struct of_device_id vcnl4035_of_match[] = {
 	{ .compatible = "vishay,vcnl4035", },
 	{ }
@@ -666,6 +672,7 @@ static struct i2c_driver vcnl4035_driver = {
 	},
 	.probe  = vcnl4035_probe,
 	.remove	= vcnl4035_remove,
+	.id_table = vcnl4035_id,
 };
 
 module_i2c_driver(vcnl4035_driver);
diff --git a/drivers/iio/proximity/vl53l0x-i2c.c b/drivers/iio/proximity/vl53l0x-i2c.c
index 5fbda9475ba9..7c29d4cae24a 100644
--- a/drivers/iio/proximity/vl53l0x-i2c.c
+++ b/drivers/iio/proximity/vl53l0x-i2c.c
@@ -143,6 +143,12 @@ static int vl53l0x_probe(struct i2c_client *client)
 	return devm_iio_device_register(&client->dev, indio_dev);
 }
 
+static const struct i2c_device_id vl53l0x_id[] = {
+	{ "vl53l0x", 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, vl53l0x_id);
+
 static const struct of_device_id st_vl53l0x_dt_match[] = {
 	{ .compatible = "st,vl53l0x", },
 	{ }
@@ -155,6 +161,7 @@ static struct i2c_driver vl53l0x_driver = {
 		.of_match_table = st_vl53l0x_dt_match,
 	},
 	.probe_new = vl53l0x_probe,
+	.id_table = vl53l0x_id,
 };
 module_i2c_driver(vl53l0x_driver);
 
diff --git a/drivers/input/misc/tps65218-pwrbutton.c b/drivers/input/misc/tps65218-pwrbutton.c
index f011447c44fb..e0c6deacca18 100644
--- a/drivers/input/misc/tps65218-pwrbutton.c
+++ b/drivers/input/misc/tps65218-pwrbutton.c
@@ -36,7 +36,7 @@ struct tps6521x_data {
 static const struct tps6521x_data tps65217_data = {
 	.reg_status = TPS65217_REG_STATUS,
 	.pb_mask = TPS65217_STATUS_PB,
-	.name = "tps65217_pwrbutton",
+	.name = "tps65217_pwr_but",
 };
 
 static const struct tps6521x_data tps65218_data = {
diff --git a/drivers/input/touchscreen/ar1021_i2c.c b/drivers/input/touchscreen/ar1021_i2c.c
index c0d5c2413356..740956f9431a 100644
--- a/drivers/input/touchscreen/ar1021_i2c.c
+++ b/drivers/input/touchscreen/ar1021_i2c.c
@@ -17,6 +17,7 @@
 
 #define AR1021_MAX_X	4095
 #define AR1021_MAX_Y	4095
+#define AR1021_MAX_PRESSURE 255
 
 #define AR1021_CMD	0x55
 
@@ -26,8 +27,29 @@ struct ar1021_i2c {
 	struct i2c_client *client;
 	struct input_dev *input;
 	u8 data[AR1021_TOUCH_PKG_SIZE];
+	bool invert_x;
+	bool invert_y;
+	bool swap_xy;
 };
 
+static bool ar1021_get_prop_u32(struct device *dev,
+				     const char *property,
+				     unsigned int default_value,
+				     unsigned int *value)
+{
+	u32 val;
+	int error;
+
+	error = device_property_read_u32(dev, property, &val);
+	if (error) {
+		*value = default_value;
+		return false;
+	}
+
+	*value = val;
+	return true;
+}
+
 static irqreturn_t ar1021_i2c_irq(int irq, void *dev_id)
 {
 	struct ar1021_i2c *ar1021 = dev_id;
@@ -49,9 +71,22 @@ static irqreturn_t ar1021_i2c_irq(int irq, void *dev_id)
 	x = ((data[2] & 0x1f) << 7) | (data[1] & 0x7f);
 	y = ((data[4] & 0x1f) << 7) | (data[3] & 0x7f);
 
-	input_report_abs(input, ABS_X, x);
-	input_report_abs(input, ABS_Y, y);
+	if (ar1021->invert_x)
+		x = AR1021_MAX_X - x;
+
+	if (ar1021->invert_y)
+		y = AR1021_MAX_Y - y;
+
+	if (ar1021->swap_xy) {
+		input_report_abs(input, ABS_X, y);
+		input_report_abs(input, ABS_Y, x);
+	} else {
+		input_report_abs(input, ABS_X, x);
+		input_report_abs(input, ABS_Y, y);
+	}
+
 	input_report_key(input, BTN_TOUCH, button);
+	input_report_abs(input, ABS_PRESSURE, AR1021_MAX_PRESSURE);
 	input_sync(input);
 
 out:
@@ -93,6 +128,8 @@ static int ar1021_i2c_probe(struct i2c_client *client,
 	struct ar1021_i2c *ar1021;
 	struct input_dev *input;
 	int error;
+	unsigned int offset_x, offset_y;
+	bool data_present;
 
 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
 		dev_err(&client->dev, "i2c_check_functionality error\n");
@@ -116,10 +153,44 @@ static int ar1021_i2c_probe(struct i2c_client *client,
 	input->open = ar1021_i2c_open;
 	input->close = ar1021_i2c_close;
 
+	ar1021->invert_x = device_property_read_bool(&client->dev, "touchscreen-inverted-x");
+	ar1021->invert_y = device_property_read_bool(&client->dev, "touchscreen-inverted-y");
+	ar1021->swap_xy = device_property_read_bool(&client->dev, "touchscreen-swapped-x-y");
+
+	data_present = ar1021_get_prop_u32(&client->dev,
+						"touchscreen-offset-x",
+						0,
+						&offset_x);
+
+	if (data_present)
+		dev_info(&client->dev, "touchscreen-offset-x: %d\n", offset_x);
+
+	data_present = ar1021_get_prop_u32(&client->dev,
+						"touchscreen-offset-y",
+						0,
+						&offset_y);
+
+	if (data_present)
+		dev_info(&client->dev, "touchscreen-offset-y: %d\n", offset_y);
+
 	__set_bit(INPUT_PROP_DIRECT, input->propbit);
-	input_set_capability(input, EV_KEY, BTN_TOUCH);
-	input_set_abs_params(input, ABS_X, 0, AR1021_MAX_X, 0, 0);
-	input_set_abs_params(input, ABS_Y, 0, AR1021_MAX_Y, 0, 0);
+	//input_set_capability(input, EV_KEY, BTN_TOUCH);
+
+	input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	if(ar1021->swap_xy)
+	{
+		input_set_abs_params(input, ABS_X, 0, AR1021_MAX_Y, 0, 0);
+		input_set_abs_params(input, ABS_Y, 0, AR1021_MAX_X, 0, 0);
+	}
+	else
+	{
+		input_set_abs_params(input, ABS_X, offset_x, AR1021_MAX_X-offset_x, 0, 0);
+		input_set_abs_params(input, ABS_Y, offset_y, AR1021_MAX_Y-offset_y, 0, 0);
+	}
+
+	input_set_abs_params(input, ABS_PRESSURE, 0, AR1021_MAX_PRESSURE, 0, 0);
 
 	input_set_drvdata(input, ar1021);
 
diff --git a/drivers/input/touchscreen/ti_am335x_tsc.c b/drivers/input/touchscreen/ti_am335x_tsc.c
index 83e685557a19..dd358bff4a55 100644
--- a/drivers/input/touchscreen/ti_am335x_tsc.c
+++ b/drivers/input/touchscreen/ti_am335x_tsc.c
@@ -34,6 +34,7 @@
 #define ADCFSM_STEPID		0x10
 #define SEQ_SETTLE		275
 #define MAX_12BIT		((1 << 12) - 1)
+#define PRESSURE_MAX		1000
 
 #define TSC_IRQENB_MASK		(IRQENB_FIFO0THRES | IRQENB_EOS | IRQENB_HW_PEN)
 
@@ -234,6 +235,7 @@ static void titsc_read_coordinates(struct titsc *ts_dev,
 	for (i = 0; i < creads; i++) {
 		xvals[i] = titsc_readl(ts_dev, REG_FIFO0);
 		xvals[i] &= 0xfff;
+		pr_debug("i %d xval %d yval %d z1 %d z2 %d\n", i, xvals[i], yvals[i], *z1, *z2);
 	}
 
 	/*
@@ -312,13 +314,13 @@ static irqreturn_t titsc_irq(int irq, void *dev)
 			 * Resistance(touch) = x plate resistance *
 			 * x postion/4096 * ((z2 / z1) - 1)
 			 */
-			z = z1 - z2;
+			z = z2 - z1;
 			z *= x;
 			z *= ts_dev->x_plate_resistance;
-			z /= z2;
+			z /= z1;
 			z = (z + 2047) >> 12;
-
-			if (z <= MAX_12BIT) {
+			pr_debug("x %d y %d z1 %d z2 %d z %d\n", x, y, z1, z2, z);
+			if (z <= PRESSURE_MAX) {
 				input_report_abs(input_dev, ABS_X, x);
 				input_report_abs(input_dev, ABS_Y, y);
 				input_report_abs(input_dev, ABS_PRESSURE, z);
@@ -459,6 +461,7 @@ static int titsc_probe(struct platform_device *pdev)
 	input_dev->name = "ti-tsc";
 	input_dev->dev.parent = &pdev->dev;
 
+	__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
 	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
 	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
 
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index ce136d685d14..d861cfb051f9 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -456,6 +456,13 @@ config PVPANIC
 	  a paravirtualized device provided by QEMU; it lets a virtual machine
 	  (guest) communicate panic events to the host.
 
+config UDOO_ARD
+	tristate "UDOO-Arduino erase/reset Driver"
+	default y
+	help
+	  This driver is used to erase and reset arduino board via command sent
+	  over USB-to-SERIAL connection.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
@@ -466,10 +473,12 @@ source "drivers/misc/mei/Kconfig"
 source "drivers/misc/vmw_vmci/Kconfig"
 source "drivers/misc/mic/Kconfig"
 source "drivers/misc/genwqe/Kconfig"
+source "drivers/misc/cape/Kconfig"
 source "drivers/misc/echo/Kconfig"
 source "drivers/misc/cxl/Kconfig"
 source "drivers/misc/ocxl/Kconfig"
 source "drivers/misc/cardreader/Kconfig"
 source "drivers/misc/habanalabs/Kconfig"
 source "drivers/misc/uacce/Kconfig"
+source "drivers/misc/mikrobus/Kconfig"
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index c7bd01ac6291..0e7da59c1f7a 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -40,6 +40,7 @@ obj-$(CONFIG_VMWARE_BALLOON)	+= vmw_balloon.o
 obj-$(CONFIG_PCH_PHUB)		+= pch_phub.o
 obj-y				+= ti-st/
 obj-y				+= lis3lv02d/
+obj-y				+= mikrobus/
 obj-$(CONFIG_ALTERA_STAPL)	+=altera-stapl/
 obj-$(CONFIG_INTEL_MEI)		+= mei/
 obj-$(CONFIG_VMWARE_VMCI)	+= vmw_vmci/
@@ -48,8 +49,10 @@ obj-$(CONFIG_SRAM)		+= sram.o
 obj-$(CONFIG_SRAM_EXEC)		+= sram-exec.o
 obj-y				+= mic/
 obj-$(CONFIG_GENWQE)		+= genwqe/
+obj-y				+= cape/
 obj-$(CONFIG_ECHO)		+= echo/
 obj-$(CONFIG_CXL_BASE)		+= cxl/
+obj-$(CONFIG_UDOO_ARD)		+= udoo_ard.o
 obj-$(CONFIG_PCI_ENDPOINT_TEST)	+= pci_endpoint_test.o
 obj-$(CONFIG_OCXL)		+= ocxl/
 obj-y				+= cardreader/
diff --git a/drivers/misc/cape/Kconfig b/drivers/misc/cape/Kconfig
new file mode 100644
index 000000000000..a2ef85e0415c
--- /dev/null
+++ b/drivers/misc/cape/Kconfig
@@ -0,0 +1,5 @@
+#
+# Capes
+#
+
+source "drivers/misc/cape/beaglebone/Kconfig"
diff --git a/drivers/misc/cape/Makefile b/drivers/misc/cape/Makefile
new file mode 100644
index 000000000000..7c4eb96ab29e
--- /dev/null
+++ b/drivers/misc/cape/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for cape like devices
+#
+
+obj-y				+= beaglebone/
diff --git a/drivers/misc/cape/beaglebone/Kconfig b/drivers/misc/cape/beaglebone/Kconfig
new file mode 100644
index 000000000000..eeb67828fd82
--- /dev/null
+++ b/drivers/misc/cape/beaglebone/Kconfig
@@ -0,0 +1,10 @@
+#
+# Beaglebone capes
+#
+
+config BEAGLEBONE_PINMUX_HELPER
+	tristate "Beaglebone Pinmux Helper"
+	depends on ARCH_OMAP2PLUS && OF
+	default n
+	help
+	  Say Y here to include support for the pinmux helper
diff --git a/drivers/misc/cape/beaglebone/Makefile b/drivers/misc/cape/beaglebone/Makefile
new file mode 100644
index 000000000000..7f4617a01e26
--- /dev/null
+++ b/drivers/misc/cape/beaglebone/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for beaglebone capes
+#
+
+obj-$(CONFIG_BEAGLEBONE_PINMUX_HELPER)	+= bone-pinmux-helper.o
diff --git a/drivers/misc/cape/beaglebone/bone-pinmux-helper.c b/drivers/misc/cape/beaglebone/bone-pinmux-helper.c
new file mode 100644
index 000000000000..57703d8bcac7
--- /dev/null
+++ b/drivers/misc/cape/beaglebone/bone-pinmux-helper.c
@@ -0,0 +1,242 @@
+/*
+ * Pinmux helper driver
+ *
+ * Copyright (C) 2013 Pantelis Antoniou <panto@antoniou-consulting.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/slab.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/consumer.h>
+
+static const struct of_device_id bone_pinmux_helper_of_match[] = {
+	{
+		.compatible = "bone-pinmux-helper",
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, bone_pinmux_helper_of_match);
+
+struct pinmux_helper_data {
+	struct pinctrl *pinctrl;
+	char *selected_state_name;
+};
+
+static ssize_t pinmux_helper_show_state(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pinmux_helper_data *data = platform_get_drvdata(pdev);
+	const char *name;
+
+	name = data->selected_state_name;
+	if (name == NULL || strlen(name) == 0)
+		name = "none";
+	return sprintf(buf, "%s\n", name);
+}
+
+static ssize_t pinmux_helper_store_state(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pinmux_helper_data *data = platform_get_drvdata(pdev);
+	struct pinctrl_state *state;
+	char *state_name;
+	char *s;
+	int err;
+
+	/* duplicate (as a null terminated string) */
+	state_name = kmalloc(count + 1, GFP_KERNEL);
+	if (state_name == NULL)
+		return -ENOMEM;
+	memcpy(state_name, buf, count);
+	state_name[count] = '\0';
+
+	/* and chop off newline */
+	s = strchr(state_name, '\n');
+	if (s != NULL)
+		*s = '\0';
+
+	/* try to select default state at first (if it exists) */
+	state = pinctrl_lookup_state(data->pinctrl, state_name);
+	if (!IS_ERR(state)) {
+		err = pinctrl_select_state(data->pinctrl, state);
+		if (err != 0)
+			dev_err(dev, "Failed to select state %s\n",
+					state_name);
+	} else {
+		dev_err(dev, "Failed to find state %s\n", state_name);
+		err = PTR_ERR_OR_ZERO(state);
+	}
+
+	if (err == 0) {
+		kfree(data->selected_state_name);
+		data->selected_state_name = state_name;
+	}
+
+	return err ? err : count;
+}
+
+static DEVICE_ATTR(state, S_IWUSR | S_IRUGO,
+		   pinmux_helper_show_state, pinmux_helper_store_state);
+
+static struct attribute *pinmux_helper_attributes[] = {
+	&dev_attr_state.attr,
+	NULL
+};
+
+static const struct attribute_group pinmux_helper_attr_group = {
+	.attrs = pinmux_helper_attributes,
+};
+
+static int bone_pinmux_helper_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct pinmux_helper_data *data;
+	struct pinctrl_state *state;
+	char *state_name;
+	const char *mode_name;
+	int mode_len;
+	int err;
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (data == NULL) {
+		dev_err(dev, "Failed to allocate data\n");
+		err = -ENOMEM;
+		goto err_no_mem;
+	}
+
+	state_name = kmalloc(strlen(PINCTRL_STATE_DEFAULT) + 1,
+			GFP_KERNEL);
+	if (state_name == NULL) {
+		dev_err(dev, "Failed to allocate state name\n");
+		err = -ENOMEM;
+		goto err_no_state_mem;
+	}
+	data->selected_state_name = state_name;
+	strcpy(data->selected_state_name, PINCTRL_STATE_DEFAULT);
+
+	platform_set_drvdata(pdev, data);
+
+	data->pinctrl = devm_pinctrl_get(dev);
+	if (IS_ERR(data->pinctrl)) {
+		dev_err(dev, "Failed to get pinctrl\n");
+		err = PTR_ERR_OR_ZERO(data->pinctrl);
+		goto err_no_pinctrl;
+	}
+
+	/* See if an initial mode is specified in the device tree */
+	mode_name = of_get_property(dev->of_node, "mode", &mode_len);
+
+	err = -1;
+	if (mode_name != NULL ) {
+		state_name = kmalloc(mode_len + 1, GFP_KERNEL);
+		if (state_name == NULL) {
+			dev_err(dev, "Failed to allocate state name\n");
+			err = -ENOMEM;
+			goto err_no_mode_mem;
+		}
+		strncpy(state_name, mode_name, mode_len);
+
+		/* try to select requested mode */
+		state = pinctrl_lookup_state(data->pinctrl, state_name);
+		if (!IS_ERR(state)) {
+			err = pinctrl_select_state(data->pinctrl, state);
+			if (err != 0) {
+				dev_warn(dev, "Unable to select requested mode %s\n", state_name);
+				kfree(state_name);
+			} else {
+				kfree(data->selected_state_name);
+				data->selected_state_name = state_name;
+				dev_notice(dev, "Set initial pinmux mode to %s\n", state_name);
+			}
+		}
+	}
+
+	/* try to select default state if mode_name failed */
+	if ( err != 0) {
+		state = pinctrl_lookup_state(data->pinctrl,
+				data->selected_state_name);
+		if (!IS_ERR(state)) {
+			err = pinctrl_select_state(data->pinctrl, state);
+			if (err != 0) {
+				dev_err(dev, "Failed to select default state\n");
+				goto err_no_state;
+			}
+		} else {
+			data->selected_state_name = '\0';
+		}
+	}
+
+	/* Register sysfs hooks */
+	err = sysfs_create_group(&dev->kobj, &pinmux_helper_attr_group);
+	if (err) {
+		dev_err(dev, "Failed to create sysfs group\n");
+		goto err_no_sysfs;
+	}
+
+	return 0;
+
+err_no_sysfs:
+err_no_state:
+err_no_mode_mem:
+	devm_pinctrl_put(data->pinctrl);
+err_no_pinctrl:
+	devm_kfree(dev, data->selected_state_name);
+err_no_state_mem:
+	devm_kfree(dev, data);
+err_no_mem:
+	return err;
+}
+
+static int bone_pinmux_helper_remove(struct platform_device *pdev)
+{
+	struct pinmux_helper_data *data = platform_get_drvdata(pdev);
+	struct device *dev = &pdev->dev;
+
+	sysfs_remove_group(&dev->kobj, &pinmux_helper_attr_group);
+	kfree(data->selected_state_name);
+	devm_pinctrl_put(data->pinctrl);
+	devm_kfree(dev, data);
+
+	return 0;
+}
+
+struct platform_driver bone_pinmux_helper_driver = {
+	.probe		= bone_pinmux_helper_probe,
+	.remove		= bone_pinmux_helper_remove,
+	.driver = {
+		.name		= "bone-pinmux-helper",
+		.owner		= THIS_MODULE,
+		.of_match_table	= bone_pinmux_helper_of_match,
+	},
+};
+
+module_platform_driver(bone_pinmux_helper_driver);
+
+MODULE_AUTHOR("Pantelis Antoniou");
+MODULE_DESCRIPTION("Beaglebone pinmux helper driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:bone-pinmux-helper");
diff --git a/drivers/misc/mikrobus/Kconfig b/drivers/misc/mikrobus/Kconfig
new file mode 100644
index 000000000000..5f42bc4e9410
--- /dev/null
+++ b/drivers/misc/mikrobus/Kconfig
@@ -0,0 +1,16 @@
+menuconfig MIKROBUS
+	tristate "Module for instantiating devices on mikroBUS ports"
+	help
+	  This option enables the mikroBUS driver. mikroBUS is an add-on
+	  board socket standard that offers maximum expandability with
+	  the smallest number of pins. The mikroBUS driver instantiates
+	  devices on a mikroBUS port described by identifying data present
+	  in an add-on board resident EEPROM, more details on the mikroBUS
+	  driver support and discussion can be found in this eLinux wiki :
+	  elinux.org/Mikrobus
+
+
+	  Say Y here to enable support for this driver.
+
+	  To compile this code as a module, chose M here: the module
+	  will be called mikrobus.ko
diff --git a/drivers/misc/mikrobus/Makefile b/drivers/misc/mikrobus/Makefile
new file mode 100644
index 000000000000..982bdec90c09
--- /dev/null
+++ b/drivers/misc/mikrobus/Makefile
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0
+# mikroBUS Core
+
+obj-$(CONFIG_MIKROBUS) += mikrobus.o
+mikrobus-y :=	mikrobus_core.o	mikrobus_manifest.o
\ No newline at end of file
diff --git a/drivers/misc/mikrobus/mikrobus_core.c b/drivers/misc/mikrobus/mikrobus_core.c
new file mode 100644
index 000000000000..7e342e2b079b
--- /dev/null
+++ b/drivers/misc/mikrobus/mikrobus_core.c
@@ -0,0 +1,880 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * mikroBUS driver for instantiating add-on
+ * board devices with an identifier EEPROM
+ *
+ * Copyright 2020 Vaishnav M A, BeagleBoard.org Foundation.
+ */
+
+#define pr_fmt(fmt) "mikrobus:%s: " fmt, __func__
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/idr.h>
+#include <linux/init.h>
+#include <linux/jump_label.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/gpio/consumer.h>
+#include <linux/mutex.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/gpio/machine.h>
+#include <linux/nvmem-consumer.h>
+#include <linux/nvmem-provider.h>
+#include <linux/interrupt.h>
+#include <linux/spi/spi.h>
+#include <linux/serdev.h>
+#include <linux/property.h>
+#include <linux/platform_device.h>
+#include <linux/debugfs.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regulator/fixed.h>
+#include <linux/regulator/machine.h>
+#include <linux/clk-provider.h>
+#include <linux/greybus/greybus_manifest.h>
+
+#include "mikrobus_core.h"
+#include "mikrobus_manifest.h"
+
+static DEFINE_MUTEX(core_lock);
+static DEFINE_IDR(mikrobus_port_idr);
+static struct class_compat *mikrobus_port_compat_class;
+int	__mikrobus_first_dynamic_bus_num;
+static bool is_registered;
+
+const char *MIKROBUS_PINCTRL_STR[] = {"pwm", "uart", "i2c", "spi"};
+
+struct bus_type mikrobus_bus_type = {
+	.name = "mikrobus",
+};
+EXPORT_SYMBOL_GPL(mikrobus_bus_type);
+
+static int mikrobus_port_scan_eeprom(struct mikrobus_port *port)
+{
+	struct addon_board_info *board;
+	int manifest_size;
+	char header[12];
+	int retval;
+	char *buf;
+
+	retval = nvmem_device_read(port->eeprom, 0, 12, header);
+	if (retval != 12) {
+		dev_err(&port->dev, "failed to fetch manifest header %d\n",
+			retval);
+		return -EINVAL;
+	}
+	manifest_size = mikrobus_manifest_header_validate(header, 12);
+	if (manifest_size < 0) {
+		dev_err(&port->dev, "invalid manifest size %d\n",
+			manifest_size);
+		return -EINVAL;
+	}
+	buf = kzalloc(manifest_size, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+	retval = nvmem_device_read(port->eeprom, 0, manifest_size, buf);
+	if (retval != manifest_size) {
+		dev_err(&port->dev, "failed to fetch manifest %d\n", retval);
+		retval = -EINVAL;
+		goto err_free_buf;
+	}
+	board = kzalloc(sizeof(*board), GFP_KERNEL);
+	if (!board) {
+		retval = -ENOMEM;
+		goto err_free_buf;
+	}
+	INIT_LIST_HEAD(&board->manifest_descs);
+	INIT_LIST_HEAD(&board->devices);
+	retval = mikrobus_manifest_parse(board, buf, manifest_size);
+	if (!retval) {
+		dev_err(&port->dev, "failed to parse manifest, size %d\n",
+			manifest_size);
+		retval = -EINVAL;
+		goto err_free_board;
+	}
+	retval = mikrobus_board_register(port, board);
+	if (retval) {
+		dev_err(&port->dev, "failed to register board %s\n",
+			board->name);
+		goto err_free_board;
+	}
+	kfree(buf);
+	return 0;
+err_free_board:
+	kfree(board);
+err_free_buf:
+	kfree(buf);
+	return retval;
+}
+
+static ssize_t name_show(struct device *dev, struct device_attribute *attr,
+						 char *buf)
+{
+	return sprintf(buf, "%s\n", to_mikrobus_port(dev)->name);
+}
+static DEVICE_ATTR_RO(name);
+
+static ssize_t new_device_store(struct device *dev, struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	struct mikrobus_port *port = to_mikrobus_port(dev);
+	struct addon_board_info *board;
+	int retval;
+
+	if (port->board) {
+		dev_err(dev, "already has board registered\n");
+		return -EBUSY;
+	}
+
+	board = kzalloc(sizeof(*board), GFP_KERNEL);
+	if (!board)
+		return -ENOMEM;
+	INIT_LIST_HEAD(&board->manifest_descs);
+	INIT_LIST_HEAD(&board->devices);
+	retval = mikrobus_manifest_parse(board, (void *)buf, count);
+	if (!retval) {
+		dev_err(dev, "failed to parse manifest\n");
+		retval = -EINVAL;
+		goto err_free_board;
+	}
+	retval = mikrobus_board_register(port, board);
+	if (retval) {
+		dev_err(dev, "failed to register board %s\n", board->name);
+		retval = -EINVAL;
+		goto err_free_board;
+	}
+	return count;
+err_free_board:
+	kfree(board);
+	return retval;
+}
+static DEVICE_ATTR_WO(new_device);
+
+static ssize_t rescan_store(struct device *dev, struct device_attribute *attr,
+							const char *buf, size_t count)
+{
+	struct mikrobus_port *port = to_mikrobus_port(dev);
+	unsigned long id;
+	int retval;
+
+	if (kstrtoul(buf, 0, &id)) {
+		dev_err(dev, "cannot parse trigger\n");
+		return -EINVAL;
+	}
+	if (port->board) {
+		dev_err(dev, "already has board registered\n");
+		return -EBUSY;
+	}
+	retval = mikrobus_port_scan_eeprom(port);
+	if (retval) {
+		dev_err(dev, "board register from manifest failed\n");
+		return -EINVAL;
+	}
+	return count;
+}
+static DEVICE_ATTR_WO(rescan);
+
+static ssize_t delete_device_store(struct device *dev, struct device_attribute *attr,
+							const char *buf, size_t count)
+{
+	struct mikrobus_port *port = to_mikrobus_port(dev);
+	unsigned long id;
+
+	if (kstrtoul(buf, 0, &id)) {
+		dev_err(dev, "cannot parse board id");
+		return -EINVAL;
+	}
+	if (!port->board) {
+		dev_err(dev, "does not have registered boards");
+		return -ENODEV;
+	}
+	mikrobus_board_unregister(port, port->board);
+	return count;
+}
+static DEVICE_ATTR_IGNORE_LOCKDEP(delete_device, 0200, NULL, delete_device_store);
+
+static struct attribute *mikrobus_port_attrs[] = {
+	&dev_attr_new_device.attr, &dev_attr_rescan.attr,
+	&dev_attr_delete_device.attr, &dev_attr_name.attr, NULL};
+ATTRIBUTE_GROUPS(mikrobus_port);
+
+static void mikrobus_port_release(struct device *dev)
+{
+	struct mikrobus_port *port = to_mikrobus_port(dev);
+
+	mutex_lock(&core_lock);
+	idr_remove(&mikrobus_port_idr, port->id);
+	mutex_unlock(&core_lock);
+	kfree(port);
+}
+
+struct device_type mikrobus_port_type = {
+	.groups = mikrobus_port_groups,
+	.release = mikrobus_port_release,
+};
+EXPORT_SYMBOL_GPL(mikrobus_port_type);
+
+
+
+int mikrobus_port_pinctrl_select(struct mikrobus_port *port)
+{
+	struct pinctrl_state *state;
+	int retval;
+	int i;
+
+	for (i = 0; i < MIKROBUS_NUM_PINCTRL_STATE; i++) {
+		state = pinctrl_lookup_state(port->pinctrl,
+						port->pinctrl_selected[i]);
+		if (!IS_ERR(state)) {
+			retval = pinctrl_select_state(port->pinctrl, state);
+			pr_info("setting pinctrl %s\n",
+					port->pinctrl_selected[i]);
+			if (retval != 0) {
+				dev_err(&port->dev, "failed to select state %s\n",
+						port->pinctrl_selected[i]);
+				return retval;
+			}
+		} else {
+			dev_err(&port->dev, "failed to find state %s\n",
+						port->pinctrl_selected[i]);
+			return PTR_ERR(state);
+		}
+	}
+
+	return retval;
+}
+EXPORT_SYMBOL_GPL(mikrobus_port_pinctrl_select);
+
+static int mikrobus_port_pinctrl_setup(struct mikrobus_port *port, struct addon_board_info *board)
+{
+	int retval;
+	int i;
+
+	for (i = 0; i < MIKROBUS_NUM_PINCTRL_STATE; i++) {
+		switch (i) {
+		case MIKROBUS_PINCTRL_PWM:
+			if (board->pin_state[MIKROBUS_PIN_PWM] == MIKROBUS_STATE_PWM)
+				sprintf(port->pinctrl_selected[i], "%s_%s",
+					MIKROBUS_PINCTRL_STR[i], PINCTRL_STATE_DEFAULT);
+			else
+				sprintf(port->pinctrl_selected[i], "%s_%s",
+					MIKROBUS_PINCTRL_STR[i], MIKROBUS_PINCTRL_STATE_GPIO);
+			break;
+		case MIKROBUS_PINCTRL_UART:
+			if (board->pin_state[MIKROBUS_PIN_RX] == MIKROBUS_STATE_UART)
+				sprintf(port->pinctrl_selected[i], "%s_%s",
+					MIKROBUS_PINCTRL_STR[i], PINCTRL_STATE_DEFAULT);
+			else
+				sprintf(port->pinctrl_selected[i], "%s_%s",
+					MIKROBUS_PINCTRL_STR[i], MIKROBUS_PINCTRL_STATE_GPIO);
+			break;
+		case MIKROBUS_PINCTRL_I2C:
+			if (board->pin_state[MIKROBUS_PIN_SCL] == MIKROBUS_STATE_I2C)
+				sprintf(port->pinctrl_selected[i], "%s_%s",
+					MIKROBUS_PINCTRL_STR[i], PINCTRL_STATE_DEFAULT);
+			else
+				sprintf(port->pinctrl_selected[i], "%s_%s",
+					MIKROBUS_PINCTRL_STR[i], MIKROBUS_PINCTRL_STATE_GPIO);
+			break;
+		case MIKROBUS_PINCTRL_SPI:
+			if (board->pin_state[MIKROBUS_PIN_MOSI] == MIKROBUS_STATE_SPI)
+				sprintf(port->pinctrl_selected[i], "%s_%s",
+					MIKROBUS_PINCTRL_STR[i], PINCTRL_STATE_DEFAULT);
+			else
+				sprintf(port->pinctrl_selected[i], "%s_%s",
+					MIKROBUS_PINCTRL_STR[i], MIKROBUS_PINCTRL_STATE_GPIO);
+			break;
+		}
+	}
+
+	retval = mikrobus_port_pinctrl_select(port);
+	if (retval)
+		dev_err(&port->dev, "failed to select pinctrl states [%d]", retval);
+	return retval;
+}
+
+static int mikrobus_irq_get(struct mikrobus_port *port, int irqno,
+							int irq_type)
+{
+	int irq;
+
+	if (irqno > port->gpios->ndescs - 1) {
+		dev_err(&port->dev, "GPIO %d does not exist", irqno);
+		return -ENODEV;
+	}
+
+	irq = gpiod_to_irq(port->gpios->desc[irqno]);
+	if (irq < 0) {
+		dev_err(&port->dev, "could not get irq %d", irqno);
+		return -EINVAL;
+	}
+	irq_set_irq_type(irq, irq_type);
+	return irq;
+}
+
+static int mikrobus_gpio_setup(struct gpio_desc *gpio, int gpio_state)
+{
+	int retval;
+
+	switch (gpio_state) {
+	case MIKROBUS_STATE_INPUT:
+		retval = gpiod_direction_input(gpio);
+		break;
+	case MIKROBUS_STATE_OUTPUT_HIGH:
+		retval = gpiod_direction_output(gpio, 1);
+		break;
+	case MIKROBUS_STATE_OUTPUT_LOW:
+		retval = gpiod_direction_output(gpio, 0);
+		break;
+	case MIKROBUS_STATE_PWM:
+	case MIKROBUS_STATE_SPI:
+	case MIKROBUS_STATE_I2C:
+	default:
+		return 0;
+	}
+	return retval;
+}
+
+static char *mikrobus_gpio_chip_name_get(struct mikrobus_port *port, int gpio)
+{
+	char *name;
+	struct gpio_chip *gpiochip;
+
+	if (gpio > port->gpios->ndescs - 1)
+		return NULL;
+
+	gpiochip = gpiod_to_chip(port->gpios->desc[gpio]);
+	name = kmemdup(gpiochip->label, MIKROBUS_NAME_SIZE, GFP_KERNEL);
+	return name;
+}
+
+static int mikrobus_gpio_hwnum_get(struct mikrobus_port *port, int gpio)
+{
+	int hwnum;
+	struct gpio_chip *gpiochip;
+
+	if (gpio > port->gpios->ndescs - 1)
+		return -ENODEV;
+
+	gpiochip = gpiod_to_chip(port->gpios->desc[gpio]);
+	hwnum = desc_to_gpio(port->gpios->desc[gpio]) - gpiochip->base;
+	return hwnum;
+}
+
+static void mikrobus_board_device_release_all(struct addon_board_info *info)
+{
+	struct board_device_info *dev;
+	struct board_device_info *next;
+
+	list_for_each_entry_safe(dev, next, &info->devices, links) {
+		list_del(&dev->links);
+		kfree(dev);
+	}
+}
+
+static int mikrobus_device_register(struct mikrobus_port *port,
+					struct board_device_info *dev, char *board_name)
+{
+	struct i2c_board_info *i2c;
+	struct spi_device *spi;
+	struct serdev_device *serdev;
+	struct platform_device *pdev;
+	struct gpiod_lookup_table *lookup;
+	struct regulator_consumer_supply regulator;
+	char devname[MIKROBUS_NAME_SIZE];
+	int i;
+	u64 *val;
+
+	dev_info(&port->dev, "registering device : %s", dev->drv_name);
+
+	if (dev->gpio_lookup) {
+		lookup = dev->gpio_lookup;
+		if (dev->protocol == GREYBUS_PROTOCOL_SPI) {
+			snprintf(devname, sizeof(devname), "%s.%u",
+				dev_name(&port->spi_mstr->dev),
+				port->chip_select[dev->reg]);
+			lookup->dev_id = kmemdup(devname, MIKROBUS_NAME_SIZE, GFP_KERNEL);
+		} else if (dev->protocol == GREYBUS_PROTOCOL_RAW) {
+			snprintf(devname, sizeof(devname), "%s.%u",
+				 dev->drv_name, dev->reg);
+			lookup->dev_id = kmemdup(devname, MIKROBUS_NAME_SIZE, GFP_KERNEL);
+		} else
+			lookup->dev_id = dev->drv_name;
+		dev_info(&port->dev, " adding lookup table : %s\n",
+			lookup->dev_id);
+		for (i = 0; i < dev->num_gpio_resources; i++) {
+			lookup->table[i].key =
+			mikrobus_gpio_chip_name_get(port,
+						lookup->table[i].chip_hwnum);
+			lookup->table[i].chip_hwnum =
+			mikrobus_gpio_hwnum_get(port,
+						lookup->table[i].chip_hwnum);
+		}
+		gpiod_add_lookup_table(lookup);
+	}
+	if (dev->regulators) {
+		if (dev->protocol == GREYBUS_PROTOCOL_SPI) {
+			snprintf(devname, sizeof(devname), "%s.%u",
+				dev_name(&port->spi_mstr->dev),
+				port->chip_select[dev->reg]);
+			regulator.dev_name  = kmemdup(devname, MIKROBUS_NAME_SIZE, GFP_KERNEL);
+		} else if (dev->protocol == GREYBUS_PROTOCOL_RAW) {
+			snprintf(devname, sizeof(devname), "%s.%u",
+				 dev->drv_name, dev->reg);
+			regulator.dev_name  = kmemdup(devname, MIKROBUS_NAME_SIZE, GFP_KERNEL);
+		} else
+			regulator.dev_name  = dev->drv_name;
+
+		for (i = 0; i < dev->num_regulators; i++) {
+			val = dev->regulators[i].value.u64_data;
+			regulator.supply = kmemdup(dev->regulators[i].name, MIKROBUS_NAME_SIZE, GFP_KERNEL);
+			dev_info(&port->dev, " adding fixed regulator %llu uv, %s for %s\n",
+				*val, regulator.supply, regulator.dev_name);
+			regulator_register_always_on(0, dev->regulators[i].name, &regulator,
+				     1, *val);
+		}
+	}
+	switch (dev->protocol) {
+	case GREYBUS_PROTOCOL_SPI:
+		spi = spi_alloc_device(port->spi_mstr);
+		if (!spi)
+			return -ENOMEM;
+		strncpy(spi->modalias, dev->drv_name, sizeof(spi->modalias) - 1);
+		if (dev->irq)
+			spi->irq = mikrobus_irq_get(port, dev->irq, dev->irq_type);
+		if (dev->properties)
+			device_add_properties(&spi->dev, dev->properties);
+		spi->chip_select = port->chip_select[dev->reg];
+		spi->max_speed_hz = dev->max_speed_hz;
+		spi->mode = dev->mode;
+		if (dev->clocks) {
+			for (i = 0; i < dev->num_clocks; i++) {
+				val = dev->clocks[i].value.u64_data;
+				dev_info(&port->dev, " adding fixed clock %s, %llu hz\n",
+					dev->clocks[i].name, *val);
+				//failing: under debug
+				clk_register_fixed_rate(&spi->dev, dev->clocks[i].name, devname, 0, *val);
+			}
+		}
+		dev->dev_client = (void *) spi_add_device(spi);
+		break;
+	case GREYBUS_PROTOCOL_I2C:
+		i2c = kzalloc(sizeof(*i2c), GFP_KERNEL);
+		if (!i2c)
+			return -ENOMEM;
+		strncpy(i2c->type, dev->drv_name, sizeof(i2c->type) - 1);
+		if (dev->irq)
+			i2c->irq = mikrobus_irq_get(port, dev->irq, dev->irq_type);
+		if (dev->properties)
+			i2c->properties = dev->properties;
+		i2c->addr = dev->reg;
+		dev->dev_client = (void *) i2c_new_client_device(port->i2c_adap, i2c);
+		break;
+	case GREYBUS_PROTOCOL_RAW:
+		pdev = platform_device_alloc(dev->drv_name, 0);
+		if (!pdev)
+			return -ENOMEM;
+		if (dev->properties)
+			platform_device_add_properties(pdev, dev->properties);
+		dev->dev_client = pdev;
+		platform_device_add(dev->dev_client);
+		break;
+	case GREYBUS_PROTOCOL_UART:
+		serdev = serdev_device_alloc(port->ser_ctrl);
+		if (!serdev)
+			return -ENOMEM;
+		strncpy(serdev->modalias, dev->drv_name, sizeof(serdev->modalias) - 1);
+		if (dev->properties)
+			device_add_properties(&serdev->dev, dev->properties);
+		dev->dev_client = serdev;
+		serdev_device_add(serdev);
+		break;
+	break;
+	default:
+	return -EINVAL;
+	}
+	return 0;
+}
+
+static void mikrobus_device_unregister(struct mikrobus_port *port,
+					struct board_device_info *dev, char *board_name)
+{
+	dev_info(&port->dev, "removing device %s\n", dev->drv_name);
+	if (dev->gpio_lookup) {
+		gpiod_remove_lookup_table(dev->gpio_lookup);
+		kfree(dev->gpio_lookup);
+	}
+	kfree(dev->properties);
+	switch (dev->protocol) {
+	case GREYBUS_PROTOCOL_SPI:
+		spi_unregister_device((struct spi_device *)dev->dev_client);
+		break;
+	case GREYBUS_PROTOCOL_I2C:
+		i2c_unregister_device((struct i2c_client *)dev->dev_client);
+		break;
+	case GREYBUS_PROTOCOL_RAW:
+		platform_device_unregister((struct platform_device  *)dev->dev_client);
+		break;
+	case GREYBUS_PROTOCOL_UART:
+		serdev_device_remove((struct serdev_device  *)dev->dev_client);
+		break;
+	}
+}
+
+int mikrobus_board_register(struct mikrobus_port *port,	struct addon_board_info *board)
+{
+	struct board_device_info *devinfo;
+	struct board_device_info *next;
+	int retval;
+	int i;
+
+	if (WARN_ON(list_empty(&board->devices)))
+		return false;
+	if (port->pinctrl) {
+		retval = mikrobus_port_pinctrl_setup(port, board);
+		if (retval)
+			dev_err(&port->dev, "failed to setup pinctrl state [%d]", retval);
+
+	}
+	if (port->gpios) {
+		for (i = 0; i < port->gpios->ndescs; i++) {
+			retval = mikrobus_gpio_setup(port->gpios->desc[i], board->pin_state[i]);
+			if (retval)
+				dev_err(&port->dev, "failed to setup gpio %d, state %d",
+									i, board->pin_state[i]);
+		}
+	}
+	list_for_each_entry_safe(devinfo, next, &board->devices, links)
+		mikrobus_device_register(port, devinfo, board->name);
+	port->board = board;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mikrobus_board_register);
+
+void mikrobus_board_unregister(struct mikrobus_port *port, struct addon_board_info *board)
+{
+	struct board_device_info *devinfo;
+	struct board_device_info *next;
+
+	if (WARN_ON(list_empty(&board->devices)))
+		return;
+	port->board = NULL;
+	list_for_each_entry_safe(devinfo, next, &board->devices, links)
+		mikrobus_device_unregister(port, devinfo, board->name);
+	mikrobus_board_device_release_all(board);
+	kfree(board);
+	port->board = NULL;
+}
+EXPORT_SYMBOL_GPL(mikrobus_board_unregister);
+
+static struct i2c_board_info mikrobus_eeprom_info = {
+	I2C_BOARD_INFO("24c32", 0x57),
+};
+
+static int mikrobus_port_eeprom_probe(struct mikrobus_port *port)
+{
+	struct i2c_client *eeprom_client;
+	struct nvmem_device *eeprom;
+	char dev_name[MIKROBUS_NAME_SIZE];
+
+	eeprom_client = i2c_new_client_device(port->i2c_adap, &mikrobus_eeprom_info);
+	if (!IS_ERR(eeprom_client)) {
+		pr_info(" mikrobus port %d default eeprom is probed at %02x\n", port->id,
+									eeprom_client->addr);
+		snprintf(dev_name, sizeof(dev_name), "%d-%04x0", port->i2c_adap->nr,
+				 eeprom_client->addr);
+		eeprom = nvmem_device_get(&eeprom_client->dev, dev_name);
+		if (IS_ERR(eeprom)) {
+			pr_err(" mikrobus port %d eeprom nvmem device probe failed\n", port->id);
+			i2c_unregister_device(eeprom_client);
+			port->eeprom = NULL;
+			return 0;
+		}
+	} else {
+		pr_info(" mikrobus port %d default eeprom probe failed\n", port->id);
+		return 0;
+	}
+	port->eeprom = eeprom;
+	port->eeprom_client = eeprom_client;
+	return 0;
+}
+
+int mikrobus_port_register(struct mikrobus_port *port)
+{
+	struct device *dev = &port->dev;
+	int retval;
+	int id;
+
+	if (WARN_ON(!is_registered))
+		return -EAGAIN;
+
+	if (dev->of_node) {
+		id = of_alias_get_id(dev->of_node, "mikrobus");
+		if (id >= 0) {
+			port->id = id;
+			mutex_lock(&core_lock);
+			id = idr_alloc(&mikrobus_port_idr, port, port->id, port->id + 1,
+										GFP_KERNEL);
+			mutex_unlock(&core_lock);
+			if (WARN(id < 0, "couldn't get idr"))
+				return id == -ENOSPC ? -EBUSY : id;
+		}
+	} else {
+		mutex_lock(&core_lock);
+		id = idr_alloc(&mikrobus_port_idr, port, __mikrobus_first_dynamic_bus_num, 0,
+											GFP_KERNEL);
+		mutex_unlock(&core_lock);
+		if (id < 0)
+			return id;
+		port->id = id;
+	}
+	port->dev.bus = &mikrobus_bus_type;
+	port->dev.type = &mikrobus_port_type;
+	strncpy(port->name, "mikrobus-port", sizeof(port->name) - 1);
+	dev_set_name(&port->dev, "mikrobus-%d", port->id);
+	pr_info("registering port mikrobus-%d ", port->id);
+	retval = device_register(&port->dev);
+	if (retval) {
+		pr_err("port '%d': can't register device (%d)", port->id, retval);
+		put_device(&port->dev);
+		return retval;
+	}
+	retval = class_compat_create_link(mikrobus_port_compat_class, &port->dev,
+								port->dev.parent);
+	if (retval)
+		dev_warn(&port->dev, "failed to create compatibility class link\n");
+	if (!port->eeprom) {
+		dev_info(&port->dev, "mikrobus port %d eeprom empty probing default eeprom\n",
+											port->id);
+		retval = mikrobus_port_eeprom_probe(port);
+	}
+	if (port->eeprom) {
+		retval = mikrobus_port_scan_eeprom(port);
+		if (retval) {
+			dev_warn(&port->dev, "failed to register board from manifest\n");
+			return 0;
+		}
+	}
+	return retval;
+}
+EXPORT_SYMBOL_GPL(mikrobus_port_register);
+
+void mikrobus_port_delete(struct mikrobus_port *port)
+{
+	struct mikrobus_port *found;
+
+	mutex_lock(&core_lock);
+	found = idr_find(&mikrobus_port_idr, port->id);
+	mutex_unlock(&core_lock);
+	if (found != port) {
+		pr_err("port [%s] not registered", port->name);
+		return;
+	}
+	if (port->board) {
+		dev_err(&port->dev, "attempting to delete port with registered boards, port [%s]\n",
+									port->name);
+		return;
+	}
+
+	if (port->eeprom) {
+		nvmem_device_put(port->eeprom);
+		i2c_unregister_device(port->eeprom_client);
+	}
+
+	class_compat_remove_link(mikrobus_port_compat_class, &port->dev,
+							port->dev.parent);
+	device_unregister(&port->dev);
+	mutex_lock(&core_lock);
+	idr_remove(&mikrobus_port_idr, port->id);
+	mutex_unlock(&core_lock);
+	memset(&port->dev, 0, sizeof(port->dev));
+}
+EXPORT_SYMBOL_GPL(mikrobus_port_delete);
+
+static int mikrobus_port_probe_pinctrl_setup(struct mikrobus_port *port)
+{
+	struct pinctrl_state *state;
+	struct device *dev = port->dev.parent;
+	int retval, i;
+
+	state = pinctrl_lookup_state(port->pinctrl, PINCTRL_STATE_DEFAULT);
+	if (!IS_ERR(state)) {
+		retval = pinctrl_select_state(port->pinctrl, state);
+		if (retval != 0) {
+			dev_err(dev, "Failed to select state %s\n",
+				PINCTRL_STATE_DEFAULT);
+			return retval;
+		}
+	} else {
+		dev_err(dev, "failed to find state %s\n",
+			PINCTRL_STATE_DEFAULT);
+		return PTR_ERR(state);
+	}
+
+	for (i = 0; i < MIKROBUS_NUM_PINCTRL_STATE; i++) {
+		port->pinctrl_selected[i] =
+				kmalloc(MIKROBUS_PINCTRL_NAME_SIZE, GFP_KERNEL);
+		sprintf(port->pinctrl_selected[i], "%s_%s",
+			MIKROBUS_PINCTRL_STR[i], PINCTRL_STATE_DEFAULT);
+	}
+
+	retval = mikrobus_port_pinctrl_select(port);
+	if (retval)
+		dev_err(dev, "failed to select pinctrl states [%d]", retval);
+	return retval;
+}
+
+static int mikrobus_port_probe(struct platform_device *pdev)
+{
+	struct mikrobus_port *port;
+	struct device *dev = &pdev->dev;
+	struct device_node *i2c_adap_np;
+	struct device_node *uart_np;
+	int retval;
+	u32 val;
+
+	port = kzalloc(sizeof(*port), GFP_KERNEL);
+	if (!port)
+		return -ENOMEM;
+
+	i2c_adap_np = of_parse_phandle(dev->of_node, "i2c-adapter", 0);
+	if (!i2c_adap_np) {
+		dev_err(dev, "cannot parse i2c-adapter\n");
+		retval = -ENODEV;
+		goto err_port;
+	}
+	port->i2c_adap = of_find_i2c_adapter_by_node(i2c_adap_np);
+	of_node_put(i2c_adap_np);
+	retval = device_property_read_u32(dev, "spi-master", &val);
+	if (retval) {
+		dev_err(dev, "failed to get spi-master [%d]\n", retval);
+		goto err_port;
+	}
+	port->spi_mstr = spi_busnum_to_master(val);
+	retval = device_property_read_u32_array(dev, "spi-cs",
+						port->chip_select, 2);
+	if (retval) {
+		dev_err(dev, "failed to get spi-cs [%d]\n", retval);
+		goto err_port;
+	}
+	uart_np = of_parse_phandle(dev->of_node, "uart", 0);
+	if (!uart_np) {
+		dev_err(dev, "cannot parse uart\n");
+		retval = -ENODEV;
+		goto err_port;
+	}
+	port->ser_ctrl = of_find_serdev_controller_by_node(uart_np);
+	of_node_put(uart_np);
+	//port->pwm = devm_pwm_get(dev, NULL);
+	//if (IS_ERR(port->pwm)) {
+	//	retval = PTR_ERR(port->pwm);
+	//	if (retval != -EPROBE_DEFER)
+	//		dev_err(dev, "failed to request PWM device [%d]\n",
+	//			retval);
+	//	goto err_port;
+	//}
+	port->gpios = gpiod_get_array(dev, "mikrobus", GPIOD_OUT_LOW);
+	if (IS_ERR(port->gpios)) {
+		retval = PTR_ERR(port->gpios);
+		dev_err(dev, "failed to get gpio array [%d]\n", retval);
+		goto err_port;
+	}
+	port->pinctrl = devm_pinctrl_get(dev);
+	if (IS_ERR(port->pinctrl)) {
+		retval = PTR_ERR(port->pinctrl);
+		dev_err(dev, "failed to get pinctrl [%d]\n", retval);
+		goto err_port;
+	}
+	port->dev.parent = dev;
+	port->dev.of_node = pdev->dev.of_node;
+
+	retval = mikrobus_port_probe_pinctrl_setup(port);
+	if (retval) {
+		dev_err(dev, "failed to setup pinctrl [%d]\n", retval);
+		goto err_port;
+	}
+
+	retval = mikrobus_port_register(port);
+	if (retval) {
+		pr_err("port : can't register port [%d]\n", retval);
+		goto err_port;
+	}
+	platform_set_drvdata(pdev, port);
+	return 0;
+err_port:
+	kfree(port);
+	return retval;
+}
+
+static int mikrobus_port_remove(struct platform_device *pdev)
+{
+	struct mikrobus_port	*port = platform_get_drvdata(pdev);
+
+	mikrobus_port_delete(port);
+	return 0;
+}
+
+static const struct of_device_id mikrobus_port_of_match[] = {
+	{.compatible = "linux,mikrobus"},
+	{},
+};
+MODULE_DEVICE_TABLE(of, mikrobus_port_of_match);
+
+static struct platform_driver mikrobus_port_driver = {
+	.probe = mikrobus_port_probe,
+	.remove = mikrobus_port_remove,
+	.driver = {
+		.name = "mikrobus",
+		.of_match_table = of_match_ptr(mikrobus_port_of_match),
+	},
+};
+
+static int __init mikrobus_init(void)
+{
+	int retval;
+
+	retval = bus_register(&mikrobus_bus_type);
+	if (retval) {
+		pr_err("bus_register failed (%d)\n", retval);
+		return retval;
+	}
+	mikrobus_port_compat_class = class_compat_register("mikrobus-port");
+	if (!mikrobus_port_compat_class) {
+		pr_err("class_compat register failed (%d)\n", retval);
+		retval = -ENOMEM;
+		goto class_err;
+	}
+	retval = of_alias_get_highest_id("mikrobus");
+	if (retval >= __mikrobus_first_dynamic_bus_num)
+		__mikrobus_first_dynamic_bus_num = retval + 1;
+
+	is_registered = true;
+	retval = platform_driver_register(&mikrobus_port_driver);
+	if (retval)
+		pr_err("driver register failed [%d]\n", retval);
+	return retval;
+
+class_err:
+	bus_unregister(&mikrobus_bus_type);
+	idr_destroy(&mikrobus_port_idr);
+	is_registered = false;
+	return retval;
+}
+subsys_initcall(mikrobus_init);
+
+static void __exit mikrobus_exit(void)
+{
+	platform_driver_unregister(&mikrobus_port_driver);
+	bus_unregister(&mikrobus_bus_type);
+	class_compat_unregister(mikrobus_port_compat_class);
+	idr_destroy(&mikrobus_port_idr);
+}
+module_exit(mikrobus_exit);
+
+MODULE_AUTHOR("Vaishnav M A <vaishnav@beagleboard.org>");
+MODULE_DESCRIPTION("mikroBUS main module");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/mikrobus/mikrobus_core.h b/drivers/misc/mikrobus/mikrobus_core.h
new file mode 100644
index 000000000000..9ac1e6248018
--- /dev/null
+++ b/drivers/misc/mikrobus/mikrobus_core.h
@@ -0,0 +1,197 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * mikroBUS Driver for instantiating add-on
+ * board devices with an identifier EEPROM
+ *
+ * Copyright 2020 Vaishnav M A, BeagleBoard.org Foundation.
+ */
+
+#ifndef __MIKROBUS_H
+#define __MIKROBUS_H
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/gpio/machine.h>
+#include <linux/spi/spi.h>
+#include <linux/serdev.h>
+#include <linux/property.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/nvmem-consumer.h>
+#include <linux/nvmem-provider.h>
+
+#define MIKROBUS_VERSION_MAJOR 0x00
+#define MIKROBUS_VERSION_MINOR 0x03
+
+#define MIKROBUS_NAME_SIZE		40
+#define MIKROBUS_PINCTRL_NAME_SIZE	20
+
+#define MIKROBUS_NUM_PINCTRL_STATE	4
+#define MIKROBUS_NUM_CS			2
+
+#define MIKROBUS_PINCTRL_PWM		0
+#define MIKROBUS_PINCTRL_UART		1
+#define MIKROBUS_PINCTRL_I2C		2
+#define MIKROBUS_PINCTRL_SPI		3
+
+#define MIKROBUS_PINCTRL_STATE_GPIO	"gpio"
+
+extern struct bus_type mikrobus_bus_type;
+extern struct device_type mikrobus_port_type;
+extern const char *MIKROBUS_PINCTRL_STR[];
+
+enum mikrobus_property_type {
+	MIKROBUS_PROPERTY_TYPE_MIKROBUS = 0x00,
+	MIKROBUS_PROPERTY_TYPE_PROPERTY	= 0x01,
+	MIKROBUS_PROPERTY_TYPE_GPIO	= 0x02,
+	MIKROBUS_PROPERTY_TYPE_U8	= 0x03,
+	MIKROBUS_PROPERTY_TYPE_U16	= 0x04,
+	MIKROBUS_PROPERTY_TYPE_U32	= 0x05,
+	MIKROBUS_PROPERTY_TYPE_U64	= 0x06,
+	MIKROBUS_PROPERTY_TYPE_REGULATOR	= 0x07,
+	MIKROBUS_PROPERTY_TYPE_CLOCK	= 0x08,
+};
+
+enum mikrobus_pin {
+	MIKROBUS_PIN_PWM	= 0x00,
+	MIKROBUS_PIN_INT	= 0x01,
+	MIKROBUS_PIN_RX		= 0x02,
+	MIKROBUS_PIN_TX		= 0x03,
+	MIKROBUS_PIN_SCL	= 0x04,
+	MIKROBUS_PIN_SDA	= 0x05,
+	MIKROBUS_PIN_MOSI	= 0x06,
+	MIKROBUS_PIN_MISO	= 0x07,
+	MIKROBUS_PIN_SCK	= 0x08,
+	MIKROBUS_PIN_CS		= 0x09,
+	MIKROBUS_PIN_RST	= 0x0A,
+	MIKROBUS_PIN_AN		= 0x0B,
+	MIKROBUS_PORT_PIN_COUNT = 0x0C,
+};
+
+enum mikrobus_pin_state {
+	MIKROBUS_STATE_INPUT		= 0x01,
+	MIKROBUS_STATE_OUTPUT_HIGH	= 0x02,
+	MIKROBUS_STATE_OUTPUT_LOW	= 0x03,
+	MIKROBUS_STATE_PWM		= 0x04,
+	MIKROBUS_STATE_SPI		= 0x05,
+	MIKROBUS_STATE_I2C		= 0x06,
+	MIKROBUS_STATE_UART		= 0x07,
+};
+
+/*
+ * board_device_info describes a single device on a mikrobus add-on
+ * board, an add-on board can present one or more device to the host
+ *
+ * @gpio_lookup: used to provide the GPIO lookup table for
+ * passing the named GPIOs to device drivers.
+ * @properties: used to provide the property_entry to pass named
+ * properties to device drivers, applicable only when driver uses
+ * device_property_read_* calls to fetch the properties.
+ * @num_gpio_resources: number of named gpio resources for the device,
+ * used mainly for gpiod_lookup_table memory allocation.
+ * @num_properties: number of custom properties for the device,
+ * used mainly for property_entry memory allocation.
+ * @protocol: used to know the type of the device and it should
+ * contain one of the values defined under 'enum greybus_class_type'
+ * under linux/greybus/greybus_manifest.h
+ * @reg: I2C address for the device, for devices on the SPI bus
+ * this field is the chip select address relative to the mikrobus
+ * port:0->device chip select connected to CS pin on mikroBUS port
+ *	1->device chip select connected to RST Pin on mikroBUS port
+ * @mode: SPI mode
+ * @max_speed_hz: SPI max speed(Hz)
+ * @drv_name: device_id to match with the driver
+ * @irq_type: type of IRQ trigger , match with defines in linux/interrupt.h
+ * @irq: irq number relative to the mikrobus port should contain one of the
+ * values defined under 'enum mikrobus_pin'
+ * @id: device id starting from 1
+ */
+struct board_device_info {
+	struct gpiod_lookup_table *gpio_lookup;
+	struct property_entry *properties;
+	struct property_entry *regulators;
+	struct property_entry *clocks;
+	struct list_head links;
+	unsigned short num_gpio_resources;
+	unsigned short num_properties;
+	unsigned short num_regulators;
+	unsigned short num_clocks;
+	unsigned short protocol;
+	unsigned short reg;
+	unsigned int mode;
+	void *dev_client;
+	u32 max_speed_hz;
+	char *drv_name;
+	int irq_type;
+	int irq;
+	int id;
+};
+
+/*
+ * addon_board_info describes a mikrobus add-on device the add-on
+ * board, an add-on board can present one or more device to the host
+ *
+ * @manifest_descs: list of manifest descriptors
+ * @devices: list of devices on the board
+ * @pin_state: the state of each pin on the mikrobus port required
+ * for the add-on board should contain one of the values defined under
+ * 'enum mikrobus_pin_state' restrictions are as per mikrobus standard
+ * specifications.
+ * @name: add-on board name
+ */
+struct addon_board_info {
+	struct list_head manifest_descs;
+	struct list_head devices;
+	u8 pin_state[MIKROBUS_PORT_PIN_COUNT];
+	char *name;
+};
+
+/*
+ * mikrobus_port describes the peripherals mapped to a
+ * mikrobus port.
+ *
+ * @eeprom_client: i2c_client corresponding to the eeprom
+ * on the add-on board.
+ * @board: pointer to the attached add-on board.
+ * @i2c_adap: I2C adapter attached to the mikrobus port.
+ * @spi_mstr: SPI master attached to the mikrobus port.
+ * @eeprom: nvmem_device for the eeprom on the add-on board.
+ * @pwm: pwm_device attached to the mikrobus port PWM pin.
+ * @pinctrl_selected: current pinctrl_selected state.
+ * @chip_select: chip select number mapped to the SPI
+ * CS pin on the mikrobus port and the RST pin on the mikrobus
+ * port
+ * @id: port id starting from 1
+ */
+struct mikrobus_port {
+	struct i2c_client *eeprom_client;
+	struct addon_board_info *board;
+	struct i2c_adapter *i2c_adap;
+	struct spi_master *spi_mstr;
+	struct serdev_controller *ser_ctrl;
+	struct nvmem_device *eeprom;
+	struct gpio_descs *gpios;
+	struct pwm_device *pwm;
+	struct pinctrl *pinctrl;
+	struct module *owner;
+	struct device dev;
+	char name[MIKROBUS_NAME_SIZE];
+	char *pinctrl_selected[MIKROBUS_NUM_PINCTRL_STATE];
+	unsigned int chip_select[MIKROBUS_NUM_CS];
+	int id;
+};
+#define to_mikrobus_port(d) container_of(d, struct mikrobus_port, dev)
+
+void mikrobus_board_unregister(struct mikrobus_port *port,
+				struct addon_board_info *board);
+int mikrobus_board_register(struct mikrobus_port *port,
+				struct addon_board_info *board);
+int mikrobus_port_register(struct mikrobus_port *port);
+int mikrobus_port_pinctrl_select(struct mikrobus_port *port);
+void mikrobus_port_delete(struct mikrobus_port *port);
+
+#endif /* __MIKROBUS_H */
diff --git a/drivers/misc/mikrobus/mikrobus_manifest.c b/drivers/misc/mikrobus/mikrobus_manifest.c
new file mode 100644
index 000000000000..9cacc3d36d4e
--- /dev/null
+++ b/drivers/misc/mikrobus/mikrobus_manifest.c
@@ -0,0 +1,475 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * mikroBUS manifest parsing, an
+ * extension to Greybus Manifest Parsing
+ * under drivers/greybus/manifest.c
+ *
+ * Copyright 2014-2015 Google Inc.
+ * Copyright 2014-2015 Linaro Ltd.
+ */
+
+#define pr_fmt(fmt) "mikrobus_manifest:%s: " fmt, __func__
+
+#include <linux/bits.h>
+#include <linux/types.h>
+#include <linux/property.h>
+#include <linux/greybus/greybus_manifest.h>
+
+#include "mikrobus_manifest.h"
+
+struct manifest_desc {
+	struct list_head links;
+	size_t size;
+	void *data;
+	enum greybus_descriptor_type type;
+};
+
+static void manifest_descriptor_release_all(struct addon_board_info *board)
+{
+	struct manifest_desc *descriptor;
+	struct manifest_desc *next;
+
+	list_for_each_entry_safe(descriptor, next, &board->manifest_descs, links) {
+		list_del(&descriptor->links);
+		kfree(descriptor);
+	}
+}
+
+static int board_descriptor_add(struct addon_board_info *board, struct greybus_descriptor *desc,
+				size_t size)
+{
+	struct greybus_descriptor_header *desc_header = &desc->header;
+	struct manifest_desc *descriptor;
+	size_t desc_size;
+	size_t expected_size;
+
+	if (size < sizeof(*desc_header)) {
+		pr_err("short descriptor (%zu < %zu)", size, sizeof(*desc_header));
+		return -EINVAL;
+	}
+	desc_size = le16_to_cpu(desc_header->size);
+	if (desc_size > size) {
+		pr_err("incorrect descriptor size (%zu != %zu)", size, desc_size);
+		return -EINVAL;
+	}
+	expected_size = sizeof(*desc_header);
+	switch (desc_header->type) {
+	case GREYBUS_TYPE_STRING:
+		expected_size += sizeof(struct greybus_descriptor_string);
+		expected_size += desc->string.length;
+		expected_size = ALIGN(expected_size, 4);
+		break;
+	case GREYBUS_TYPE_PROPERTY:
+		expected_size += sizeof(struct greybus_descriptor_property);
+		expected_size += desc->property.length;
+		expected_size = ALIGN(expected_size, 4);
+		break;
+	case GREYBUS_TYPE_DEVICE:
+		expected_size += sizeof(struct greybus_descriptor_device);
+		break;
+	case GREYBUS_TYPE_MIKROBUS:
+		expected_size += sizeof(struct greybus_descriptor_mikrobus);
+		break;
+	case GREYBUS_TYPE_INTERFACE:
+		expected_size += sizeof(struct greybus_descriptor_interface);
+		break;
+	case GREYBUS_TYPE_CPORT:
+		expected_size += sizeof(struct greybus_descriptor_cport);
+		break;
+	case GREYBUS_TYPE_BUNDLE:
+		expected_size += sizeof(struct greybus_descriptor_bundle);
+		break;
+	case GREYBUS_TYPE_INVALID:
+	default:
+		pr_err("invalid descriptor type %d", desc_header->type);
+		return -EINVAL;
+	}
+
+	descriptor = kzalloc(sizeof(*descriptor), GFP_KERNEL);
+	if (!descriptor)
+		return -ENOMEM;
+	descriptor->size = desc_size;
+	descriptor->data = (char *)desc + sizeof(*desc_header);
+	descriptor->type = desc_header->type;
+	list_add_tail(&descriptor->links, &board->manifest_descs);
+	return desc_size;
+}
+
+static char *mikrobus_string_get(struct addon_board_info *board, u8 string_id)
+{
+	struct greybus_descriptor_string *desc_string;
+	struct manifest_desc *descriptor;
+	bool found = false;
+	char *string;
+
+	if (!string_id)
+		return NULL;
+
+	list_for_each_entry(descriptor, &board->manifest_descs, links) {
+		if (descriptor->type != GREYBUS_TYPE_STRING)
+			continue;
+		desc_string = descriptor->data;
+		if (desc_string->id == string_id) {
+			found = true;
+			break;
+		}
+	}
+	if (!found)
+		return ERR_PTR(-ENOENT);
+	string = kmemdup(&desc_string->string, desc_string->length + 1, GFP_KERNEL);
+	if (!string)
+		return ERR_PTR(-ENOMEM);
+	string[desc_string->length] = '\0';
+	return string;
+}
+
+static void mikrobus_state_get(struct addon_board_info *board)
+{
+	struct greybus_descriptor_mikrobus *mikrobus;
+	struct greybus_descriptor_interface *interface;
+	struct manifest_desc *descriptor;
+	bool found = false;
+	int i;
+
+	list_for_each_entry(descriptor, &board->manifest_descs, links) {
+		if (descriptor->type == GREYBUS_TYPE_MIKROBUS) {
+			mikrobus = descriptor->data;
+			found = true;
+			break;
+		}
+	}
+	if (!found) {
+		pr_err("mikrobus descriptor not found");
+		return;
+	}
+	for (i = 0; i < MIKROBUS_PORT_PIN_COUNT; i++)
+		board->pin_state[i] =  mikrobus->pin_state[i];
+
+	found = false;
+	list_for_each_entry(descriptor, &board->manifest_descs, links) {
+		if (descriptor->type == GREYBUS_TYPE_INTERFACE) {
+			interface = descriptor->data;
+			found = true;
+			break;
+		}
+	}
+	if (!found) {
+		pr_err("interface descriptor not found");
+		return;
+	}
+	board->name = mikrobus_string_get(board, interface->product_stringid);
+}
+
+static struct property_entry *
+mikrobus_property_entry_get(struct addon_board_info *board, u8 *prop_link,
+			    int num_properties)
+{
+	struct greybus_descriptor_property *desc_property;
+	struct manifest_desc *descriptor;
+	struct property_entry *properties;
+	bool found = false;
+	char *prop_name;
+	u64 *val_u64;
+	u32 *val_u32;
+	u16 *val_u16;
+	u8 *val_u8;
+	int i;
+
+	properties = kcalloc(num_properties, sizeof(*properties), GFP_KERNEL);
+	if (!properties)
+		return ERR_PTR(-ENOMEM);
+	for (i = 0; i < num_properties; i++) {
+		list_for_each_entry(descriptor, &board->manifest_descs, links) {
+			if (descriptor->type != GREYBUS_TYPE_PROPERTY)
+				continue;
+			desc_property = descriptor->data;
+			if (desc_property->id == prop_link[i]) {
+				found = true;
+				break;
+			}
+		}
+		if (!found) {
+			kfree(properties);
+			return ERR_PTR(-ENOENT);
+		}
+		prop_name = mikrobus_string_get(board, desc_property->propname_stringid);
+		if (!prop_name) {
+			kfree(properties);
+			return ERR_PTR(-ENOENT);
+		}
+		switch (desc_property->type) {
+		case MIKROBUS_PROPERTY_TYPE_U8:
+			val_u8 = kmemdup(&desc_property->value,
+					(desc_property->length) * sizeof(u8),
+					GFP_KERNEL);
+			if (desc_property->length == 1)
+				properties[i] = PROPERTY_ENTRY_U8(prop_name, *val_u8);
+			else
+				properties[i] = PROPERTY_ENTRY_U8_ARRAY_LEN(prop_name,
+					(void *)desc_property->value, desc_property->length);
+			break;
+		case MIKROBUS_PROPERTY_TYPE_U16:
+			val_u16 = kmemdup(&desc_property->value,
+					(desc_property->length) * sizeof(u16), GFP_KERNEL);
+			if (desc_property->length == 1)
+				properties[i] = PROPERTY_ENTRY_U16(prop_name, *val_u16);
+			else
+				properties[i] = PROPERTY_ENTRY_U16_ARRAY_LEN(prop_name,
+					(void *)desc_property->value, desc_property->length);
+			break;
+		case MIKROBUS_PROPERTY_TYPE_U32:
+			val_u32 = kmemdup(&desc_property->value,
+						(desc_property->length) * sizeof(u32), GFP_KERNEL);
+			if (desc_property->length == 1)
+				properties[i] = PROPERTY_ENTRY_U32(prop_name, *val_u32);
+			else
+				properties[i] = PROPERTY_ENTRY_U32_ARRAY_LEN(prop_name,
+					(void *)desc_property->value, desc_property->length);
+			break;
+		case MIKROBUS_PROPERTY_TYPE_U64:
+			val_u64 = kmemdup(&desc_property->value,
+					(desc_property->length) * sizeof(u64), GFP_KERNEL);
+			if (desc_property->length == 1)
+				properties[i] = PROPERTY_ENTRY_U64(prop_name, *val_u64);
+			else
+				properties[i] = PROPERTY_ENTRY_U64_ARRAY_LEN(prop_name,
+					(void *)desc_property->value, desc_property->length);
+			break;
+		default:
+			kfree(properties);
+			return ERR_PTR(-EINVAL);
+		}
+	}
+	return properties;
+}
+
+static u8 *mikrobus_property_link_get(struct addon_board_info *board, u8 prop_id,
+					struct board_device_info *board_dev,  u8 prop_type)
+{
+	struct greybus_descriptor_property *desc_property;
+	struct manifest_desc *descriptor;
+	bool found = false;
+	u8 *val_u8;
+
+	if (!prop_id)
+		return NULL;
+	list_for_each_entry(descriptor, &board->manifest_descs, links) {
+		if (descriptor->type != GREYBUS_TYPE_PROPERTY)
+			continue;
+		desc_property = descriptor->data;
+		if (desc_property->id == prop_id && desc_property->type == prop_type) {
+			found = true;
+			break;
+		}
+	}
+	if (!found)
+		return ERR_PTR(-ENOENT);
+	val_u8 = kmemdup(&desc_property->value, desc_property->length, GFP_KERNEL);
+	if (prop_type == MIKROBUS_PROPERTY_TYPE_GPIO)
+		board_dev->num_gpio_resources = desc_property->length;
+	else if (prop_type == MIKROBUS_PROPERTY_TYPE_PROPERTY)
+		board_dev->num_properties = desc_property->length;
+	else if (prop_type == MIKROBUS_PROPERTY_TYPE_REGULATOR)
+		board_dev->num_regulators = desc_property->length;
+	else if (prop_type == MIKROBUS_PROPERTY_TYPE_CLOCK)
+		board_dev->num_clocks = desc_property->length;
+	return val_u8;
+}
+
+static int mikrobus_manifest_attach_device(struct addon_board_info *board,
+						struct greybus_descriptor_device *dev_desc)
+{
+	struct board_device_info *board_dev;
+	struct gpiod_lookup_table *lookup;
+	struct greybus_descriptor_property *desc_property;
+	struct manifest_desc *descriptor;
+	u8 *gpio_desc_link;
+	u8 *prop_link;
+	u8 *reg_link;
+	u8 *clock_link;
+	u8 *gpioval;
+	int retval;
+	int i;
+
+	board_dev = kzalloc(sizeof(*board_dev), GFP_KERNEL);
+	if (!board_dev)
+		return -ENOMEM;
+	board_dev->id = dev_desc->id;
+	board_dev->drv_name = mikrobus_string_get(board, dev_desc->driver_stringid);
+	if (!board_dev->drv_name) {
+		retval = -ENOENT;
+		goto err_free_board_dev;
+	}
+	board_dev->protocol = dev_desc->protocol;
+	board_dev->reg = dev_desc->reg;
+	board_dev->irq = dev_desc->irq;
+	board_dev->irq_type = dev_desc->irq_type;
+	board_dev->max_speed_hz = le32_to_cpu(dev_desc->max_speed_hz);
+	board_dev->mode = dev_desc->mode;
+	pr_info("parsed device %d, driver=%s", board_dev->id, board_dev->drv_name);
+
+	if (dev_desc->prop_link > 0) {
+		prop_link = mikrobus_property_link_get(board, dev_desc->prop_link,
+				board_dev, MIKROBUS_PROPERTY_TYPE_PROPERTY);
+		if (!prop_link) {
+			retval = -ENOENT;
+			goto err_free_board_dev;
+		}
+		pr_info("device %d, number of properties=%d", board_dev->id,
+								board_dev->num_properties);
+		board_dev->properties = mikrobus_property_entry_get(board, prop_link,
+									board_dev->num_properties);
+	}
+
+	if (dev_desc->gpio_link > 0) {
+		gpio_desc_link = mikrobus_property_link_get(board, dev_desc->gpio_link, board_dev,
+							MIKROBUS_PROPERTY_TYPE_GPIO);
+		if (!gpio_desc_link) {
+			retval = -ENOENT;
+			goto err_free_board_dev;
+		}
+		pr_info("device %d, number of gpio resource=%d", board_dev->id,
+							board_dev->num_gpio_resources);
+		lookup = kzalloc(struct_size(lookup, table, board_dev->num_gpio_resources),
+					GFP_KERNEL);
+		if (!lookup) {
+			retval = -ENOMEM;
+			goto err_free_board_dev;
+		}
+		for (i = 0; i < board_dev->num_gpio_resources; i++) {
+			list_for_each_entry(descriptor, &board->manifest_descs, links) {
+				if (descriptor->type != GREYBUS_TYPE_PROPERTY)
+					continue;
+				desc_property = descriptor->data;
+				if (desc_property->id == gpio_desc_link[i]) {
+					gpioval = desc_property->value;
+					lookup->table[i].chip_hwnum = gpioval[0];
+					lookup->table[i].flags = gpioval[1];
+					lookup->table[i].con_id =
+					mikrobus_string_get(board,
+							desc_property->propname_stringid);
+					break;
+				}
+			}
+		}
+		board_dev->gpio_lookup = lookup;
+	}
+
+	if (dev_desc->reg_link > 0) {
+		reg_link = mikrobus_property_link_get(board, dev_desc->reg_link,
+				board_dev, MIKROBUS_PROPERTY_TYPE_REGULATOR);
+		if (!reg_link) {
+			retval = -ENOENT;
+			goto err_free_board_dev;
+		}
+		pr_info("device %d, number of regulators=%d", board_dev->id,
+								board_dev->num_regulators);
+		board_dev->regulators = mikrobus_property_entry_get(board, reg_link,
+									board_dev->num_regulators);
+	}
+
+	if (dev_desc->clock_link > 0) {
+		clock_link = mikrobus_property_link_get(board, dev_desc->clock_link,
+				board_dev, MIKROBUS_PROPERTY_TYPE_CLOCK);
+		if (!clock_link) {
+			retval = -ENOENT;
+			goto err_free_board_dev;
+		}
+		pr_info("device %d, number of clocks=%d", board_dev->id,
+								board_dev->num_clocks);
+		board_dev->clocks = mikrobus_property_entry_get(board, clock_link,
+									board_dev->num_clocks);
+	}
+	list_add_tail(&board_dev->links, &board->devices);
+	return 0;
+err_free_board_dev:
+	kfree(board_dev);
+	return retval;
+}
+
+static int mikrobus_manifest_parse_devices(struct addon_board_info *board)
+{
+	struct greybus_descriptor_device *desc_device;
+	struct manifest_desc *desc, *next;
+	int retval;
+	int devcount = 0;
+
+	list_for_each_entry_safe(desc, next, &board->manifest_descs, links) {
+		if (desc->type != GREYBUS_TYPE_DEVICE)
+			continue;
+		desc_device = desc->data;
+		retval = mikrobus_manifest_attach_device(board, desc_device);
+		devcount++;
+	}
+	return devcount;
+}
+
+int mikrobus_manifest_parse(struct addon_board_info *board, void *data,
+							 size_t size)
+{
+	struct greybus_manifest_header *header;
+	struct greybus_manifest *manifest;
+	struct greybus_descriptor *desc;
+	u16 manifest_size;
+	int dev_count;
+	int desc_size;
+
+	if (size < sizeof(*header)) {
+		pr_err("short manifest (%zu < %zu)", size, sizeof(*header));
+		return -EINVAL;
+	}
+
+	manifest = data;
+	header = &manifest->header;
+	manifest_size = le16_to_cpu(header->size);
+
+	if (manifest_size != size) {
+		pr_err("invalid manifest size(%zu < %u)", size, manifest_size);
+		return -EINVAL;
+	}
+
+	if (header->version_major > MIKROBUS_VERSION_MAJOR) {
+		pr_err("manifest version too new (%u.%u > %u.%u)",
+		header->version_major, header->version_minor,
+		MIKROBUS_VERSION_MAJOR, MIKROBUS_VERSION_MINOR);
+		return -EINVAL;
+	}
+
+	desc = manifest->descriptors;
+	size -= sizeof(*header);
+	while (size) {
+		desc_size = board_descriptor_add(board, desc, size);
+		if (desc_size < 0) {
+			pr_err("invalid manifest descriptor, size: %u", desc_size);
+			return -EINVAL;
+		}
+		desc = (void *)desc + desc_size;
+		size -= desc_size;
+	}
+	mikrobus_state_get(board);
+	dev_count = mikrobus_manifest_parse_devices(board);
+	pr_info(" %s manifest parsed with %d devices", board->name, dev_count);
+	manifest_descriptor_release_all(board);
+	return true;
+}
+
+size_t mikrobus_manifest_header_validate(void *data, size_t size)
+{
+	struct greybus_manifest_header *header;
+	u16 manifest_size;
+
+	if (size < sizeof(*header)) {
+		pr_err("short manifest (%zu < %zu)", size, sizeof(*header));
+		return -EINVAL;
+	}
+	header = data;
+	manifest_size = le16_to_cpu(header->size);
+	if (header->version_major > MIKROBUS_VERSION_MAJOR) {
+		pr_err("manifest version too new (%u.%u > %u.%u)",
+		header->version_major, header->version_minor,
+		MIKROBUS_VERSION_MAJOR, MIKROBUS_VERSION_MINOR);
+		return -EINVAL;
+	}
+	return manifest_size;
+}
+
diff --git a/drivers/misc/mikrobus/mikrobus_manifest.h b/drivers/misc/mikrobus/mikrobus_manifest.h
new file mode 100644
index 000000000000..36b64b2093f5
--- /dev/null
+++ b/drivers/misc/mikrobus/mikrobus_manifest.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * mikroBUS manifest definition
+ * extension to Greybus Manifest Definition
+ *
+ * Copyright 2014-2015 Google Inc.
+ * Copyright 2014-2015 Linaro Ltd.
+ *
+ * Released under the GPLv2 and BSD licenses.
+ */
+
+#ifndef __MIKROBUS_MANIFEST_H
+#define __MIKROBUS_MANIFEST_H
+
+#include "mikrobus_core.h"
+
+int mikrobus_manifest_parse(struct addon_board_info *info, void *data, size_t size);
+size_t mikrobus_manifest_header_validate(void *data, size_t size);
+
+#endif /* __MIKROBUS_MANIFEST_H */
diff --git a/drivers/misc/udoo_ard.c b/drivers/misc/udoo_ard.c
new file mode 100755
index 000000000000..2210738e09c0
--- /dev/null
+++ b/drivers/misc/udoo_ard.c
@@ -0,0 +1,417 @@
+/*
+ * udoo_ard.c
+ * UDOO quad/dual Arduino flash erase / CPU resetter
+ *
+ * Copyright (C) 2013-2015 Aidilab srl
+ * Author: UDOO Team <social@udoo.org>
+ * Author: Giuseppe Pagano <giuseppe.pagano@seco.com>
+ * Author: Francesco Montefoschi <francesco.monte@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/sched.h>
+#include <linux/sched/clock.h>
+#include <linux/kernel.h>
+#include <linux/workqueue.h>
+#include <linux/fs.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/uaccess.h>
+
+#define DRIVER_NAME              "udoo_ard"
+#define PINCTRL_DEFAULT          "default"
+#define AUTH_TOKEN               0x5A5A
+#define MAX_MSEC_SINCE_LAST_IRQ  400
+#define GRAY_TIME_BETWEEN_RESET  10000 // In this time we can't accept new erase/reset code
+
+static struct workqueue_struct *erase_reset_wq;
+typedef struct {
+    struct work_struct erase_reset_work;
+    struct pinctrl *pinctrl;
+    struct pinctrl_state *pins_default;
+    int    step;
+    int    cmdcode;
+    int    erase_reset_lock;
+    int    gpio_bossac_clk;
+    int    gpio_bossac_dat;
+    int    gpio_ard_erase;
+    int    gpio_ard_reset;
+    unsigned long    last_int_time_in_ns;
+    unsigned long    last_int_time_in_sec;
+} erase_reset_work_t;
+
+erase_reset_work_t *work;
+static u32 origTX, origRX; // original UART4 TX/RX pad control registers
+static int major; // for /dev/udoo_ard
+static struct class *udoo_class;
+
+static struct platform_device_id udoo_ard_devtype[] = {
+    {
+        /* keep it for coldfire */
+        .name = DRIVER_NAME,
+        .driver_data = 0,
+    }, {
+        /* sentinel */
+    }
+};
+MODULE_DEVICE_TABLE(platform, udoo_ard_devtype);
+
+static const struct of_device_id udoo_ard_dt_ids[] = {
+    { .compatible = "udoo,imx6q-udoo-ard", .data = &udoo_ard_devtype[0], },
+    { /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, udoo_ard_dt_ids);
+
+static void disable_serial(void)
+{
+    u32 addrTX;
+    void __iomem *_addrTX;
+
+    printk("[bossac] Disable UART4 serial port.\n");
+
+    addrTX = 0x20E01F8;
+    _addrTX = ioremap(addrTX, 8);
+
+    origTX = __raw_readl(_addrTX);
+    origRX = __raw_readl(_addrTX + 0x4);
+
+    __raw_writel(0x15, _addrTX);
+    __raw_writel(0x15, _addrTX + 0x4);
+
+    iounmap(_addrTX);
+}
+
+static void enable_serial(void)
+{
+    u32 addrTX;
+    void __iomem *_addrTX;
+
+    printk("[bossac] Enable UART4 serial port.\n");
+
+    addrTX = 0x20E01F8;
+    _addrTX = ioremap(addrTX, 8);
+
+    __raw_writel(origTX, _addrTX);
+    __raw_writel(origRX, _addrTX + 0x4);
+
+    iounmap(_addrTX);
+}
+
+static void erase_reset(void)
+{
+    printk("[bossac] UDOO ERASE and RESET on Sam3x started.\n");
+
+    gpio_direction_input(work->gpio_ard_erase);
+    gpio_set_value(work->gpio_ard_reset, 1);
+    msleep(1);
+
+    gpio_direction_output(work->gpio_ard_erase, 1);
+    msleep(300);
+    gpio_direction_input(work->gpio_ard_erase);
+
+    msleep(10);
+    gpio_set_value(work->gpio_ard_reset, 0);
+
+    msleep(80);
+    gpio_set_value(work->gpio_ard_reset, 1);
+
+    printk("[bossac] UDOO ERASE and RESET on Sam3x EXECUTED.\n");
+}
+
+static void shutdown_sam3x(void)
+{
+    printk("[bossac] RESET on Sam3x.\n");
+
+    gpio_set_value(work->gpio_ard_reset, 0);
+}
+
+static void erase_reset_wq_function( struct work_struct *work2)
+{
+    disable_serial();
+    erase_reset();
+    msleep(GRAY_TIME_BETWEEN_RESET);
+
+    work->erase_reset_lock = 0;
+}
+
+/*
+ * Called everytime the gpio_bossac_clk signal toggles.
+ * If the auth token (16 bit) is found, we look for the command code (4 bit).
+ * The code 0x0F is sent by Bossac to trigger an erase/reset (to achieve this,
+ * erase_reset_wq is scheduled). Before starting to program the flash, we disable
+ * the UART4 serial port, otherwise there is too noise on the serial lines (the
+ * programming port and UART4 port are connected together, see hw schematics).
+ * When Bossac finishes to flash/verify, the code 0x00 is sent which re-enables
+ * the UART4 port.
+ */
+static irqreturn_t udoo_bossac_req(int irq, void *dev_id)
+{
+    int retval, auth_bit, expected_bit, msec_since_last_irq;
+    u64 nowsec;
+    unsigned long rem_nsec;
+    erase_reset_work_t *erase_reset_work;
+
+    auth_bit = 0;
+    if (gpio_get_value(work->gpio_bossac_dat) != 0x0) {
+        auth_bit = 1;
+    }
+
+    erase_reset_work = (erase_reset_work_t *)work;
+
+    nowsec = local_clock();
+    rem_nsec = do_div(nowsec, 1000000000) ;
+    msec_since_last_irq = (((unsigned long)nowsec * 1000) + rem_nsec/1000000 ) - (((unsigned long)erase_reset_work->last_int_time_in_sec * 1000) + erase_reset_work->last_int_time_in_ns/1000000);
+
+    if (msec_since_last_irq > MAX_MSEC_SINCE_LAST_IRQ) {
+        erase_reset_work->step = 0;
+#ifdef DEBUG
+        printk("[bossac] Reset authentication timeout!\n");
+#endif
+    }
+
+#ifdef DEBUG
+    printk("[bossac] STEP %d -> 0x%d \n", erase_reset_work->step, auth_bit);
+#endif
+    erase_reset_work->last_int_time_in_ns = rem_nsec;
+    erase_reset_work->last_int_time_in_sec = nowsec;
+
+    if ( erase_reset_work->step < 16 ) {  // Authenticating received token bit.
+        expected_bit = (( AUTH_TOKEN >> erase_reset_work->step ) & 0x01 );
+        if ( auth_bit == expected_bit ) {
+            erase_reset_work->step = erase_reset_work->step + 1;
+        } else {
+            erase_reset_work->step = 0;
+        }
+    } else { // Passed all authentication step. Receiving command code.
+        erase_reset_work->cmdcode = erase_reset_work->cmdcode | (auth_bit << (erase_reset_work->step - 16));
+        erase_reset_work->step = erase_reset_work->step + 1;
+    }
+
+#ifdef DEBUG
+    printk("erase_reset_work->erase_reset_lock = %d \n", erase_reset_work->erase_reset_lock);
+#endif
+    if ( erase_reset_work->step == 20 ) {  // Passed authentication and code acquiring step.
+#ifdef DEBUG
+        printk("[bossac] Received code = 0x%04x \n", erase_reset_work->cmdcode);
+#endif
+        if (erase_reset_work->cmdcode == 0xF) {
+            if (erase_reset_work->erase_reset_lock == 0) {
+		erase_reset_work->erase_reset_lock = 1;
+		retval = queue_work( erase_reset_wq, (struct work_struct *)work );
+            } else {
+#ifdef DEBUG
+                printk("Erase and reset operation already in progress. Do nothing.\n");
+#endif
+            }
+        } else {
+            enable_serial();
+        }
+        erase_reset_work->step = 0;
+        erase_reset_work->cmdcode = 0;
+    }
+
+    return IRQ_HANDLED;
+}
+
+/*
+ * Takes control of clock, data, erase, reset GPIOs.
+ */
+static int gpio_setup(void)
+{
+    int ret;
+
+    ret = gpio_request(work->gpio_bossac_clk, "BOSSA_CLK");
+    if (ret) {
+        printk(KERN_ERR "request BOSSA_CLK IRQ\n");
+        return -1;
+    } else {
+        gpio_direction_input(work->gpio_bossac_clk);
+    }
+
+    ret = gpio_request(work->gpio_bossac_dat, "BOSSA_DAT");
+    if (ret) {
+        printk(KERN_ERR "request BOSSA_DAT IRQ\n");
+        return -1;
+    } else {
+        gpio_direction_input(work->gpio_bossac_dat);
+    }
+
+    ret = gpio_request(work->gpio_ard_erase, "BOSSAC");
+    if (ret) {
+        printk(KERN_ERR "request GPIO FOR ARDUINO ERASE\n");
+        return -1;
+    } else {
+        gpio_direction_input(work->gpio_ard_erase);
+    }
+
+    ret = gpio_request(work->gpio_ard_reset, "BOSSAC");
+    if (ret) {
+        printk(KERN_ERR "request GPIO FOR ARDUINO RESET\n");
+        return -1;
+    } else {
+        gpio_direction_output(work->gpio_ard_reset, 1);
+    }
+
+    return 0;
+}
+
+static ssize_t device_write(struct file *filp, const char *buff, size_t len, loff_t *off)
+{
+    char msg[10];
+    long res;
+
+    if (len > 10)
+		return -EINVAL;
+
+
+	res = copy_from_user(msg, buff, len);
+    if (res) {
+        return -EFAULT;
+    }
+	msg[len] = '\0';
+
+    if (strcmp(msg, "erase")==0) {
+        erase_reset();
+    } else if (strcmp(msg, "shutdown")==0) {
+        shutdown_sam3x();
+    } else if (strcmp(msg, "uartoff")==0) {
+        disable_serial();
+    } else if (strcmp(msg, "uarton")==0) {
+        enable_serial();
+    } else {
+        printk("[bossac] udoo_ard invalid operation! %s", msg);
+    }
+
+	return len;
+}
+
+static struct file_operations fops = {
+    .write = device_write,
+};
+
+/*
+ * If a fdt udoo_ard entry is found, we register an IRQ on bossac clock line
+ * and we create /dev/udoo_ard
+ */
+static int udoo_ard_probe(struct platform_device *pdev)
+{
+    int retval;
+    struct device *temp_class;
+    struct platform_device *bdev;
+    struct device_node *np;
+
+    bdev = kzalloc(sizeof(*bdev), GFP_KERNEL);
+    np = pdev->dev.of_node;
+
+    if (!np)
+            return -ENODEV;
+
+    work = (erase_reset_work_t *)kmalloc(sizeof(erase_reset_work_t), GFP_KERNEL);
+    if (work) {
+	    work->gpio_ard_reset = of_get_named_gpio(np, "bossac-reset-gpio", 0);
+	    work->gpio_ard_erase = of_get_named_gpio(np, "bossac-erase-gpio", 0);
+	    work->gpio_bossac_clk = of_get_named_gpio(np, "bossac-clk-gpio", 0);
+	    work->gpio_bossac_dat = of_get_named_gpio(np, "bossac-dat-gpio", 0);
+	    work->pinctrl = devm_pinctrl_get(&pdev->dev);
+        work->pins_default = pinctrl_lookup_state(work->pinctrl, PINCTRL_DEFAULT);
+    } else {
+	    printk("[bossac] Failed to allocate data structure.");
+	    return -ENOMEM;
+    }
+
+    pinctrl_select_state(work->pinctrl, work->pins_default);
+    gpio_setup();
+
+    printk("[bossac] Registering IRQ %d for BOSSAC Arduino erase/reset operation\n", gpio_to_irq(work->gpio_bossac_clk));
+    retval = request_irq(gpio_to_irq(work->gpio_bossac_clk), udoo_bossac_req, IRQF_TRIGGER_FALLING, "UDOO", bdev);
+
+    major = register_chrdev(major, "udoo_ard", &fops);
+    if (major < 0) {
+		printk(KERN_ERR "[bossac] Cannot get major for UDOO Ard\n");
+		return -EBUSY;
+	}
+
+    udoo_class = class_create(THIS_MODULE, "udoo_ard");
+	if (IS_ERR(udoo_class)) {
+		return PTR_ERR(udoo_class);
+	}
+
+	temp_class = device_create(udoo_class, NULL, MKDEV(major, 0), NULL, "udoo_ard");
+	if (IS_ERR(temp_class)) {
+		return PTR_ERR(temp_class);
+	}
+
+    printk("[bossac] Created device file /dev/udoo_ard\n");
+
+    erase_reset_wq = create_workqueue("erase_reset_queue");
+    if (erase_reset_wq) {
+
+        /* Queue some work (item 1) */
+        if (work) {
+            INIT_WORK( (struct work_struct *)work, erase_reset_wq_function );
+            work->step = 1;
+            work->cmdcode = 0;
+            work->last_int_time_in_ns = 0;
+            work->last_int_time_in_sec = 0;
+            work->erase_reset_lock = 0;
+            //  retval = queue_work( erase_reset_wq, (struct work_struct *)work );
+        }
+    }
+    return  0;
+}
+
+static int udoo_ard_remove(struct platform_device *pdev)
+{
+    printk("[bossac] Unloading UDOO ard driver.\n");
+    free_irq(gpio_to_irq(work->gpio_bossac_clk), NULL);
+
+    gpio_free(work->gpio_ard_reset);
+    gpio_free(work->gpio_ard_erase);
+    gpio_free(work->gpio_bossac_clk);
+    gpio_free(work->gpio_bossac_dat);
+
+    device_destroy(udoo_class, MKDEV(major, 0));
+    class_destroy(udoo_class);
+    unregister_chrdev(major, "udoo_ard");
+
+    return 0;
+}
+
+static struct platform_driver udoo_ard_driver = {
+    .driver = {
+        .name   = DRIVER_NAME,
+        .owner  = THIS_MODULE,
+        .of_match_table = udoo_ard_dt_ids,
+    },
+    .id_table = udoo_ard_devtype,
+    .probe  = udoo_ard_probe,
+    .remove = udoo_ard_remove,
+};
+
+module_platform_driver(udoo_ard_driver);
+
+MODULE_ALIAS("platform:"DRIVER_NAME);
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/ti/davinci_mdio.c b/drivers/net/ethernet/ti/davinci_mdio.c
index 702fdc393da0..e201a20e2e11 100644
--- a/drivers/net/ethernet/ti/davinci_mdio.c
+++ b/drivers/net/ethernet/ti/davinci_mdio.c
@@ -92,6 +92,10 @@ struct davinci_mdio_data {
 	u32		clk_div;
 };
 
+#if IS_ENABLED(CONFIG_OF)
+static void davinci_mdio_update_dt_from_phymask(u32 phy_mask);
+#endif
+
 static void davinci_mdio_init_clk(struct davinci_mdio_data *data)
 {
 	u32 mdio_in, div, mdio_out_khz, access_time;
@@ -159,6 +163,12 @@ static int davinci_mdio_reset(struct mii_bus *bus)
 		/* restrict mdio bus to live phys only */
 		dev_info(data->dev, "detected phy mask %x\n", ~phy_mask);
 		phy_mask = ~phy_mask;
+
+		#if IS_ENABLED(CONFIG_OF)
+		if (of_machine_is_compatible("ti,am335x-bone"))
+			davinci_mdio_update_dt_from_phymask(phy_mask);
+		#endif
+
 	} else {
 		/* desperately scan all phys */
 		dev_warn(data->dev, "no live phy, scanning all\n");
@@ -474,6 +484,93 @@ static int davinci_mdio_runtime_resume(struct device *dev)
 	davinci_mdio_enable(data);
 	return 0;
 }
+static void davinci_mdio_update_dt_from_phymask(u32 phy_mask)
+{
+	int i, len, skip;
+	u32 addr;
+	__be32 *old_phy_p, *phy_id_p;
+	struct property *phy_id_property = NULL;
+	struct device_node *node_p, *slave_p;
+
+	addr = 0;
+
+	for (i = 0; i < PHY_MAX_ADDR; i++) {
+		if ((phy_mask & (1 << i)) == 0) {
+			addr = (u32) i;
+		break;
+		}
+	}
+
+	for_each_compatible_node(node_p, NULL, "ti,cpsw") {
+		for_each_node_by_name(slave_p, "slave") {
+
+#if IS_ENABLED(CONFIG_OF_OVERLAY)
+			skip = 1;
+			// Hack, the overlay fixup "slave" doesn't have phy-mode...
+			old_phy_p = (__be32 *) of_get_property(slave_p, "phy-mode", &len);
+
+			if (len != (sizeof(__be32 *) * 1))
+			{
+				skip = 0;
+			}
+
+			if (skip) {
+#endif
+
+			old_phy_p = (__be32 *) of_get_property(slave_p, "phy_id", &len);
+
+			if (len != (sizeof(__be32 *) * 2))
+				goto err_out;
+
+			if (old_phy_p) {
+
+				phy_id_property = kzalloc(sizeof(*phy_id_property), GFP_KERNEL);
+
+				if (! phy_id_property)
+					goto err_out;
+
+				phy_id_property->length = len;
+				phy_id_property->name = kstrdup("phy_id", GFP_KERNEL);
+				phy_id_property->value = kzalloc(len, GFP_KERNEL);
+
+				if (! phy_id_property->name)
+					goto err_out;
+
+				if (! phy_id_property->value)
+					goto err_out;
+
+				memcpy(phy_id_property->value, old_phy_p, len);
+
+				phy_id_p = (__be32 *) phy_id_property->value + 1;
+
+				*phy_id_p = cpu_to_be32(addr);
+
+				of_update_property(slave_p, phy_id_property);
+				pr_info("davinci_mdio: dt: updated phy_id[%d] from phy_mask[%x]\n", addr, phy_mask);
+
+				++addr;
+			}
+#if IS_ENABLED(CONFIG_OF_OVERLAY)
+		}
+#endif
+		}
+	}
+
+	return;
+
+err_out:
+
+	if (phy_id_property) {
+		if (phy_id_property->name)
+			kfree(phy_id_property->name);
+
+	if (phy_id_property->value)
+		kfree(phy_id_property->value);
+
+	if (phy_id_property)
+		kfree(phy_id_property);
+	}
+}
 #endif
 
 #ifdef CONFIG_PM_SLEEP
diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
index ff0350ca3b74..78b6fa270cf9 100644
--- a/drivers/power/Kconfig
+++ b/drivers/power/Kconfig
@@ -2,3 +2,4 @@
 source "drivers/power/avs/Kconfig"
 source "drivers/power/reset/Kconfig"
 source "drivers/power/supply/Kconfig"
+source "drivers/power/pwrseq/Kconfig"
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
index b7c2e372186b..13046c7fb499 100644
--- a/drivers/power/Makefile
+++ b/drivers/power/Makefile
@@ -2,3 +2,4 @@
 obj-$(CONFIG_POWER_AVS)		+= avs/
 obj-$(CONFIG_POWER_RESET)	+= reset/
 obj-$(CONFIG_POWER_SUPPLY)	+= supply/
+obj-$(CONFIG_POWER_SEQUENCE)	+= pwrseq/
diff --git a/drivers/power/pwrseq/Kconfig b/drivers/power/pwrseq/Kconfig
new file mode 100644
index 000000000000..c6b356926cca
--- /dev/null
+++ b/drivers/power/pwrseq/Kconfig
@@ -0,0 +1,20 @@
+#
+# Power Sequence library
+#
+
+menuconfig POWER_SEQUENCE
+	bool "Power sequence control"
+	help
+	   It is used for drivers which needs to do power sequence
+	   (eg, turn on clock, toggle reset gpio) before the related
+	   devices can be found by hardware, eg, USB bus.
+
+if POWER_SEQUENCE
+
+config PWRSEQ_GENERIC
+	bool "Generic power sequence control"
+	depends on OF
+	help
+	   This is the generic power sequence control library, and is
+	   supposed to support common power sequence usage.
+endif
diff --git a/drivers/power/pwrseq/Makefile b/drivers/power/pwrseq/Makefile
new file mode 100644
index 000000000000..ad82389028c2
--- /dev/null
+++ b/drivers/power/pwrseq/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_POWER_SEQUENCE) += core.o
+obj-$(CONFIG_PWRSEQ_GENERIC) += pwrseq_generic.o
diff --git a/drivers/power/pwrseq/core.c b/drivers/power/pwrseq/core.c
new file mode 100644
index 000000000000..3d19e62a2e76
--- /dev/null
+++ b/drivers/power/pwrseq/core.c
@@ -0,0 +1,335 @@
+/*
+ * core.c	power sequence core file
+ *
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Author: Peter Chen <peter.chen@nxp.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2  of
+ * the License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.
+ */
+
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/power/pwrseq.h>
+
+static DEFINE_MUTEX(pwrseq_list_mutex);
+static LIST_HEAD(pwrseq_list);
+
+static int pwrseq_get(struct device_node *np, struct pwrseq *p)
+{
+	if (p && p->get)
+		return p->get(np, p);
+
+	return -ENOTSUPP;
+}
+
+static int pwrseq_on(struct pwrseq *p)
+{
+	if (p && p->on)
+		return p->on(p);
+
+	return -ENOTSUPP;
+}
+
+static void pwrseq_off(struct pwrseq *p)
+{
+	if (p && p->off)
+		p->off(p);
+}
+
+static void pwrseq_put(struct pwrseq *p)
+{
+	if (p && p->put)
+		p->put(p);
+}
+
+/**
+ * pwrseq_register - Add pwrseq instance to global pwrseq list
+ *
+ * @pwrseq: the pwrseq instance
+ */
+void pwrseq_register(struct pwrseq *pwrseq)
+{
+	mutex_lock(&pwrseq_list_mutex);
+	list_add(&pwrseq->node, &pwrseq_list);
+	mutex_unlock(&pwrseq_list_mutex);
+}
+EXPORT_SYMBOL_GPL(pwrseq_register);
+
+/**
+ * pwrseq_unregister - Remove pwrseq instance from global pwrseq list
+ *
+ * @pwrseq: the pwrseq instance
+ */
+void pwrseq_unregister(struct pwrseq *pwrseq)
+{
+	mutex_lock(&pwrseq_list_mutex);
+	list_del(&pwrseq->node);
+	mutex_unlock(&pwrseq_list_mutex);
+}
+EXPORT_SYMBOL_GPL(pwrseq_unregister);
+
+static struct pwrseq *pwrseq_find_available_instance(struct device_node *np)
+{
+	struct pwrseq *pwrseq;
+
+	mutex_lock(&pwrseq_list_mutex);
+	list_for_each_entry(pwrseq, &pwrseq_list, node) {
+		if (pwrseq->used)
+			continue;
+
+		/* compare compatible string for pwrseq node */
+		if (of_match_node(pwrseq->pwrseq_of_match_table, np)) {
+			pwrseq->used = true;
+			mutex_unlock(&pwrseq_list_mutex);
+			return pwrseq;
+		}
+
+		/* return generic pwrseq instance */
+		if (!strcmp(pwrseq->pwrseq_of_match_table->compatible,
+				"generic")) {
+			pr_debug("using generic pwrseq instance for %s\n",
+				np->full_name);
+			pwrseq->used = true;
+			mutex_unlock(&pwrseq_list_mutex);
+			return pwrseq;
+		}
+	}
+	mutex_unlock(&pwrseq_list_mutex);
+	pr_debug("Can't find any pwrseq instances for %s\n", np->full_name);
+
+	return NULL;
+}
+
+/**
+ * of_pwrseq_on - Carry out power sequence on for device node
+ *
+ * @np: the device node would like to power on
+ *
+ * Carry out a single device power on.  If multiple devices
+ * need to be handled, use of_pwrseq_on_list() instead.
+ *
+ * Return a pointer to the power sequence instance on success,
+ * or an error code otherwise.
+ */
+struct pwrseq *of_pwrseq_on(struct device_node *np)
+{
+	struct pwrseq *pwrseq;
+	int ret;
+
+	pwrseq = pwrseq_find_available_instance(np);
+	if (!pwrseq)
+		return ERR_PTR(-ENOENT);
+
+	ret = pwrseq_get(np, pwrseq);
+	if (ret) {
+		/* Mark current pwrseq as unused */
+		pwrseq->used = false;
+		return ERR_PTR(ret);
+	}
+
+	ret = pwrseq_on(pwrseq);
+	if (ret)
+		goto pwr_put;
+
+	return pwrseq;
+
+pwr_put:
+	pwrseq_put(pwrseq);
+	return ERR_PTR(ret);
+}
+EXPORT_SYMBOL_GPL(of_pwrseq_on);
+
+/**
+ * of_pwrseq_off - Carry out power sequence off for this pwrseq instance
+ *
+ * @pwrseq: the pwrseq instance which related device would like to be off
+ *
+ * This API is used to power off single device, it is the opposite
+ * operation for of_pwrseq_on.
+ */
+void of_pwrseq_off(struct pwrseq *pwrseq)
+{
+	pwrseq_off(pwrseq);
+	pwrseq_put(pwrseq);
+}
+EXPORT_SYMBOL_GPL(of_pwrseq_off);
+
+/**
+ * of_pwrseq_on_list - Carry out power sequence on for list
+ *
+ * @np: the device node would like to power on
+ * @head: the list head for pwrseq list on this bus
+ *
+ * This API is used to power on multiple devices at single bus.
+ * If there are several devices on bus (eg, USB bus), uses this
+ * this API. Otherwise, use of_pwrseq_on instead. After the device
+ * is powered on successfully, it will be added to pwrseq list for
+ * this bus. The caller needs to use mutex_lock for concurrent.
+ *
+ * Return 0 on success, or an error value otherwise.
+ */
+int of_pwrseq_on_list(struct device_node *np, struct list_head *head)
+{
+	struct pwrseq *pwrseq;
+	struct pwrseq_list_per_dev *pwrseq_list_node;
+
+	pwrseq_list_node = kzalloc(sizeof(*pwrseq_list_node), GFP_KERNEL);
+	if (!pwrseq_list_node)
+		return -ENOMEM;
+
+	pwrseq = of_pwrseq_on(np);
+	if (IS_ERR(pwrseq)) {
+		kfree(pwrseq_list_node);
+		return PTR_ERR(pwrseq);
+	}
+
+	pwrseq_list_node->pwrseq = pwrseq;
+	list_add(&pwrseq_list_node->list, head);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(of_pwrseq_on_list);
+
+/**
+ * of_pwrseq_off_list - Carry out power sequence off for the list
+ *
+ * @head: the list head for pwrseq instance list on this bus
+ *
+ * This API is used to power off all devices on this bus, it is
+ * the opposite operation for of_pwrseq_on_list.
+ * The caller needs to use mutex_lock for concurrent.
+ */
+void of_pwrseq_off_list(struct list_head *head)
+{
+	struct pwrseq *pwrseq;
+	struct pwrseq_list_per_dev *pwrseq_list_node, *tmp_node;
+
+	list_for_each_entry_safe(pwrseq_list_node, tmp_node, head, list) {
+		pwrseq = pwrseq_list_node->pwrseq;
+		of_pwrseq_off(pwrseq);
+		list_del(&pwrseq_list_node->list);
+		kfree(pwrseq_list_node);
+	}
+}
+EXPORT_SYMBOL_GPL(of_pwrseq_off_list);
+
+/**
+ * pwrseq_suspend - Carry out power sequence suspend for this pwrseq instance
+ *
+ * @pwrseq: the pwrseq instance
+ *
+ * This API is used to do suspend operation on pwrseq instance.
+ *
+ * Return 0 on success, or an error value otherwise.
+ */
+int pwrseq_suspend(struct pwrseq *p)
+{
+	int ret = 0;
+
+	if (p && p->suspend)
+		ret = p->suspend(p);
+	else
+		return ret;
+
+	if (!ret)
+		p->suspended = true;
+	else
+		pr_err("%s failed\n", __func__);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pwrseq_suspend);
+
+/**
+ * pwrseq_resume - Carry out power sequence resume for this pwrseq instance
+ *
+ * @pwrseq: the pwrseq instance
+ *
+ * This API is used to do resume operation on pwrseq instance.
+ *
+ * Return 0 on success, or an error value otherwise.
+ */
+int pwrseq_resume(struct pwrseq *p)
+{
+	int ret = 0;
+
+	if (p && p->resume)
+		ret = p->resume(p);
+	else
+		return ret;
+
+	if (!ret)
+		p->suspended = false;
+	else
+		pr_err("%s failed\n", __func__);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pwrseq_resume);
+
+/**
+ * pwrseq_suspend_list - Carry out power sequence suspend for list
+ *
+ * @head: the list head for pwrseq instance list on this bus
+ *
+ * This API is used to do suspend on all power sequence instances on this bus.
+ * The caller needs to use mutex_lock for concurrent.
+ */
+int pwrseq_suspend_list(struct list_head *head)
+{
+	struct pwrseq *pwrseq;
+	struct pwrseq_list_per_dev *pwrseq_list_node;
+	int ret = 0;
+
+	list_for_each_entry(pwrseq_list_node, head, list) {
+		ret = pwrseq_suspend(pwrseq_list_node->pwrseq);
+		if (ret)
+			break;
+	}
+
+	if (ret) {
+		list_for_each_entry(pwrseq_list_node, head, list) {
+			pwrseq = pwrseq_list_node->pwrseq;
+			if (pwrseq->suspended)
+				pwrseq_resume(pwrseq);
+		}
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pwrseq_suspend_list);
+
+/**
+ * pwrseq_resume_list - Carry out power sequence resume for the list
+ *
+ * @head: the list head for pwrseq instance list on this bus
+ *
+ * This API is used to do resume on all power sequence instances on this bus.
+ * The caller needs to use mutex_lock for concurrent.
+ */
+int pwrseq_resume_list(struct list_head *head)
+{
+	struct pwrseq_list_per_dev *pwrseq_list_node;
+	int ret = 0;
+
+	list_for_each_entry(pwrseq_list_node, head, list) {
+		ret = pwrseq_resume(pwrseq_list_node->pwrseq);
+		if (ret)
+			break;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pwrseq_resume_list);
diff --git a/drivers/power/pwrseq/pwrseq_generic.c b/drivers/power/pwrseq/pwrseq_generic.c
new file mode 100644
index 000000000000..4e7c09086cfb
--- /dev/null
+++ b/drivers/power/pwrseq/pwrseq_generic.c
@@ -0,0 +1,234 @@
+/*
+ * pwrseq_generic.c	Generic power sequence handling
+ *
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Author: Peter Chen <peter.chen@nxp.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2  of
+ * the License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/slab.h>
+
+#include <linux/power/pwrseq.h>
+
+struct pwrseq_generic {
+	struct pwrseq pwrseq;
+	struct gpio_desc *gpiod_reset;
+	struct clk *clks[PWRSEQ_MAX_CLKS];
+	u32 duration_us;
+	bool suspended;
+};
+
+#define to_generic_pwrseq(p) container_of(p, struct pwrseq_generic, pwrseq)
+
+static int pwrseq_generic_alloc_instance(void);
+static const struct of_device_id generic_id_table[] = {
+	{ .compatible = "generic",},
+	{ /* sentinel */ }
+};
+
+static int pwrseq_generic_suspend(struct pwrseq *pwrseq)
+{
+	struct pwrseq_generic *pwrseq_gen = to_generic_pwrseq(pwrseq);
+	int clk;
+
+	for (clk = PWRSEQ_MAX_CLKS - 1; clk >= 0; clk--)
+		clk_disable_unprepare(pwrseq_gen->clks[clk]);
+
+	pwrseq_gen->suspended = true;
+	return 0;
+}
+
+static int pwrseq_generic_resume(struct pwrseq *pwrseq)
+{
+	struct pwrseq_generic *pwrseq_gen = to_generic_pwrseq(pwrseq);
+	int clk, ret = 0;
+
+	for (clk = 0; clk < PWRSEQ_MAX_CLKS && pwrseq_gen->clks[clk]; clk++) {
+		ret = clk_prepare_enable(pwrseq_gen->clks[clk]);
+		if (ret) {
+			pr_err("Can't enable clock, ret=%d\n", ret);
+			goto err_disable_clks;
+		}
+	}
+
+	pwrseq_gen->suspended = false;
+	return ret;
+
+err_disable_clks:
+	while (--clk >= 0)
+		clk_disable_unprepare(pwrseq_gen->clks[clk]);
+
+	return ret;
+}
+
+static void pwrseq_generic_put(struct pwrseq *pwrseq)
+{
+	struct pwrseq_generic *pwrseq_gen = to_generic_pwrseq(pwrseq);
+	int clk;
+
+	if (pwrseq_gen->gpiod_reset)
+		gpiod_put(pwrseq_gen->gpiod_reset);
+
+	for (clk = 0; clk < PWRSEQ_MAX_CLKS; clk++)
+		clk_put(pwrseq_gen->clks[clk]);
+
+	pwrseq_unregister(&pwrseq_gen->pwrseq);
+	kfree(pwrseq_gen);
+}
+
+static void pwrseq_generic_off(struct pwrseq *pwrseq)
+{
+	struct pwrseq_generic *pwrseq_gen = to_generic_pwrseq(pwrseq);
+	int clk;
+
+	if (pwrseq_gen->suspended)
+		return;
+
+	for (clk = PWRSEQ_MAX_CLKS - 1; clk >= 0; clk--)
+		clk_disable_unprepare(pwrseq_gen->clks[clk]);
+}
+
+static int pwrseq_generic_on(struct pwrseq *pwrseq)
+{
+	struct pwrseq_generic *pwrseq_gen = to_generic_pwrseq(pwrseq);
+	int clk, ret = 0;
+	struct gpio_desc *gpiod_reset = pwrseq_gen->gpiod_reset;
+
+	for (clk = 0; clk < PWRSEQ_MAX_CLKS && pwrseq_gen->clks[clk]; clk++) {
+		ret = clk_prepare_enable(pwrseq_gen->clks[clk]);
+		if (ret) {
+			pr_err("Can't enable clock, ret=%d\n", ret);
+			goto err_disable_clks;
+		}
+	}
+
+	if (gpiod_reset) {
+		u32 duration_us = pwrseq_gen->duration_us;
+
+		if (duration_us <= 10)
+			udelay(10);
+		else
+			usleep_range(duration_us, duration_us + 100);
+		gpiod_set_value(gpiod_reset, 0);
+	}
+
+	return ret;
+
+err_disable_clks:
+	while (--clk >= 0)
+		clk_disable_unprepare(pwrseq_gen->clks[clk]);
+
+	return ret;
+}
+
+static int pwrseq_generic_get(struct device_node *np, struct pwrseq *pwrseq)
+{
+	struct pwrseq_generic *pwrseq_gen = to_generic_pwrseq(pwrseq);
+	enum of_gpio_flags flags;
+	int reset_gpio, clk, ret = 0;
+
+	for (clk = 0; clk < PWRSEQ_MAX_CLKS; clk++) {
+		pwrseq_gen->clks[clk] = of_clk_get(np, clk);
+		if (IS_ERR(pwrseq_gen->clks[clk])) {
+			ret = PTR_ERR(pwrseq_gen->clks[clk]);
+			if (ret != -ENOENT)
+				goto err_put_clks;
+			pwrseq_gen->clks[clk] = NULL;
+			break;
+		}
+	}
+
+	reset_gpio = of_get_named_gpio_flags(np, "reset-gpios", 0, &flags);
+	if (gpio_is_valid(reset_gpio)) {
+		unsigned long gpio_flags;
+
+		if (flags & OF_GPIO_ACTIVE_LOW)
+			gpio_flags = GPIOF_ACTIVE_LOW | GPIOF_OUT_INIT_LOW;
+		else
+			gpio_flags = GPIOF_OUT_INIT_HIGH;
+
+		ret = gpio_request_one(reset_gpio, gpio_flags,
+				"pwrseq-reset-gpios");
+		if (ret)
+			goto err_put_clks;
+
+		pwrseq_gen->gpiod_reset = gpio_to_desc(reset_gpio);
+		of_property_read_u32(np, "reset-duration-us",
+				&pwrseq_gen->duration_us);
+	} else if (reset_gpio == -ENOENT) {
+		; /* no such gpio */
+	} else {
+		ret = reset_gpio;
+		pr_err("Failed to get reset gpio on %s, err = %d\n",
+				np->full_name, reset_gpio);
+		goto err_put_clks;
+	}
+
+	/* allocate new one for later pwrseq instance request */
+	ret = pwrseq_generic_alloc_instance();
+	if (ret)
+		goto err_put_gpio;
+
+	return 0;
+
+err_put_gpio:
+	if (pwrseq_gen->gpiod_reset)
+		gpiod_put(pwrseq_gen->gpiod_reset);
+err_put_clks:
+	while (--clk >= 0)
+		clk_put(pwrseq_gen->clks[clk]);
+	return ret;
+}
+
+/**
+ * pwrseq_generic_alloc_instance - power sequence instance allocation
+ *
+ * This function is used to allocate one generic power sequence instance,
+ * it is called when the system boots up and after one power sequence
+ * instance is got successfully.
+ *
+ * Return zero on success or an error code otherwise.
+ */
+static int pwrseq_generic_alloc_instance(void)
+{
+	struct pwrseq_generic *pwrseq_gen;
+
+	pwrseq_gen = kzalloc(sizeof(*pwrseq_gen), GFP_KERNEL);
+	if (!pwrseq_gen)
+		return -ENOMEM;
+
+	pwrseq_gen->pwrseq.pwrseq_of_match_table = generic_id_table;
+	pwrseq_gen->pwrseq.get = pwrseq_generic_get;
+	pwrseq_gen->pwrseq.on = pwrseq_generic_on;
+	pwrseq_gen->pwrseq.off = pwrseq_generic_off;
+	pwrseq_gen->pwrseq.put = pwrseq_generic_put;
+	pwrseq_gen->pwrseq.suspend = pwrseq_generic_suspend;
+	pwrseq_gen->pwrseq.resume = pwrseq_generic_resume;
+
+	pwrseq_register(&pwrseq_gen->pwrseq);
+	return 0;
+}
+
+/* Allocate one pwrseq instance during boots up */
+static int __init pwrseq_generic_register(void)
+{
+	return pwrseq_generic_alloc_instance();
+}
+postcore_initcall(pwrseq_generic_register)
diff --git a/drivers/regulator/twl6030-regulator.c b/drivers/regulator/twl6030-regulator.c
index 430265c404d6..99f7eb8dbf25 100644
--- a/drivers/regulator/twl6030-regulator.c
+++ b/drivers/regulator/twl6030-regulator.c
@@ -299,6 +299,13 @@ static const struct regulator_ops twl6030fixed_ops = {
 	.get_status	= twl6030reg_get_status,
 };
 
+static struct regulator_ops twl6030_fixed_resource = {
+	.enable	= twl6030reg_enable,
+	.disable	= twl6030reg_disable,
+	.is_enabled	= twl6030reg_is_enabled,
+	.get_status	= twl6030reg_get_status,
+};
+
 /*
  * SMPS status and control
  */
@@ -572,6 +579,19 @@ static const struct twlreg_info TWLSMPS_INFO_##label = { \
 		}, \
 	}
 
+#define TWL6030_FIXED_RESOURCE(label, offset, turnon_delay) \
+static struct twlreg_info TWLRES_INFO_##label = { \
+	.base = offset, \
+	.desc = { \
+	.name = #label, \
+	.id = TWL6030_REG_##label, \
+	.ops = &twl6030_fixed_resource, \
+	.type = REGULATOR_VOLTAGE, \
+	.owner = THIS_MODULE, \
+	.enable_time = turnon_delay, \
+	}, \
+	}
+
 /* VUSBCP is managed *only* by the USB subchip */
 /* 6030 REG with base as PMC Slave Misc : 0x0030 */
 /* Turnon-delay and remap configuration values for 6030 are not
@@ -601,6 +621,7 @@ TWL6030_FIXED_LDO(VDAC, 0x64, 1800, 0);
 TWL6030_FIXED_LDO(VUSB, 0x70, 3300, 0);
 TWL6030_FIXED_LDO(V1V8, 0x16, 1800, 0);
 TWL6030_FIXED_LDO(V2V1, 0x1c, 2100, 0);
+TWL6030_FIXED_RESOURCE(CLK32KG, 0x8C, 0);
 TWL6032_ADJUSTABLE_SMPS(SMPS3, 0x34);
 TWL6032_ADJUSTABLE_SMPS(SMPS4, 0x10);
 TWL6032_ADJUSTABLE_SMPS(VIO, 0x16);
@@ -632,6 +653,7 @@ static u8 twl_get_smps_mult(void)
 #define TWL6030_OF_MATCH(comp, label) TWL_OF_MATCH(comp, TWL6030, label)
 #define TWL6032_OF_MATCH(comp, label) TWL_OF_MATCH(comp, TWL6032, label)
 #define TWLFIXED_OF_MATCH(comp, label) TWL_OF_MATCH(comp, TWLFIXED, label)
+#define TWLRES_OF_MATCH(comp, label) TWL_OF_MATCH(comp, TWLRES, label)
 #define TWLSMPS_OF_MATCH(comp, label) TWL_OF_MATCH(comp, TWLSMPS, label)
 
 static const struct of_device_id twl_of_match[] = {
@@ -659,6 +681,7 @@ static const struct of_device_id twl_of_match[] = {
 	TWLFIXED_OF_MATCH("ti,twl6030-vusb", VUSB),
 	TWLFIXED_OF_MATCH("ti,twl6030-v1v8", V1V8),
 	TWLFIXED_OF_MATCH("ti,twl6030-v2v1", V2V1),
+	TWLRES_OF_MATCH("ti,twl6030-clk32kg", CLK32KG),
 	TWLSMPS_OF_MATCH("ti,twl6032-smps3", SMPS3),
 	TWLSMPS_OF_MATCH("ti,twl6032-smps4", SMPS4),
 	TWLSMPS_OF_MATCH("ti,twl6032-vio", VIO),
diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c
index 455e99c4958e..4997ada0ba9d 100644
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -737,9 +737,9 @@ static int spidev_probe(struct spi_device *spi)
 	 * compatible string, it is a Linux implementation thing
 	 * rather than a description of the hardware.
 	 */
-	WARN(spi->dev.of_node &&
-	     of_device_is_compatible(spi->dev.of_node, "spidev"),
-	     "%pOF: buggy DT: spidev listed directly in DT\n", spi->dev.of_node);
+//	WARN(spi->dev.of_node &&
+//	     of_device_is_compatible(spi->dev.of_node, "spidev"),
+//	     "%pOF: buggy DT: spidev listed directly in DT\n", spi->dev.of_node);
 
 	spidev_probe_acpi(spi);
 
diff --git a/drivers/staging/fbtft/fb_ssd1306.c b/drivers/staging/fbtft/fb_ssd1306.c
index 6cf9df579e88..4cd61617154d 100644
--- a/drivers/staging/fbtft/fb_ssd1306.c
+++ b/drivers/staging/fbtft/fb_ssd1306.c
@@ -55,6 +55,9 @@ static int init_display(struct fbtft_par *par)
 		write_reg(par, 0x3F);
 	else if (par->info->var.yres == 48)
 		write_reg(par, 0x2F);
+	else if (par->info->var.yres == 39)
+		/* https://libstock.mikroe.com/projects/download/1111/2577/1411057038_oled_b_click___e_mikroc_arm.zip */
+		write_reg(par, 0x27);
 	else
 		write_reg(par, 0x1F);
 
@@ -76,19 +79,27 @@ static int init_display(struct fbtft_par *par)
 	write_reg(par, 0x01);
 
 	/* Set Segment Re-map */
-	/* column address 127 is mapped to SEG0 */
-	write_reg(par, 0xA0 | 0x1);
+	if (par->info->var.yres == 39)
+		/* no segment re-map */
+		write_reg(par, 0xA0 | 0x0);
+	else
+		/* column address 127 is mapped to SEG0 */
+		write_reg(par, 0xA0 | 0x1);
 
 	/* Set COM Output Scan Direction */
-	/* remapped mode. Scan from COM[N-1] to COM0 */
-	write_reg(par, 0xC8);
+	if (par->info->var.yres == 39)
+		/* no columnt re-map mode. Scan from COM0 to COM[N-1] */
+		write_reg(par, 0xC0);
+	else
+		/* remapped mode. Scan from COM[N-1] to COM0 */
+		write_reg(par, 0xC8);
 
 	/* Set COM Pins Hardware Configuration */
 	write_reg(par, 0xDA);
 	if (par->info->var.yres == 64)
 		/* A[4]=1b, Alternative COM pin configuration */
 		write_reg(par, 0x12);
-	else if (par->info->var.yres == 48)
+	else if (par->info->var.yres == 48 || par->info->var.yres == 39)
 		/* A[4]=1b, Alternative COM pin configuration */
 		write_reg(par, 0x12);
 	else
@@ -97,12 +108,18 @@ static int init_display(struct fbtft_par *par)
 
 	/* Set Pre-charge Period */
 	write_reg(par, 0xD9);
-	write_reg(par, 0xF1);
+	if (par->info->var.yres == 39)
+		write_reg(par, 0x25);
+	else
+		write_reg(par, 0xF1);
 
 	/* Set VCOMH Deselect Level */
 	write_reg(par, 0xDB);
-	/* according to the datasheet, this value is out of bounds */
-	write_reg(par, 0x40);
+	if (par->info->var.yres == 39)
+		write_reg(par, 0x20);
+	else
+		/* according to the datasheet, this value is out of bounds */
+		write_reg(par, 0x40);
 
 	/* Entire Display ON */
 	/* Resume to RAM content display. Output follows RAM content */
@@ -133,6 +150,20 @@ static void set_addr_win_64x48(struct fbtft_par *par)
 	write_reg(par, 0x5);
 }
 
+static void set_addr_win_96x39(struct fbtft_par *par)
+{
+	/* Set Page Address */
+	write_reg(par, 0xB0);
+	/* Set Column Address */
+	write_reg(par, 0x21);
+	write_reg(par, 0x00);
+	write_reg(par, 0x5F);
+	/* Set Page Address Range */
+	write_reg(par, 0x22);
+	write_reg(par, 0x0);
+	write_reg(par, 0x4);
+}
+
 static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
 {
 	/* Set Lower Column Start Address for Page Addressing Mode */
@@ -144,6 +175,8 @@ static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
 
 	if (par->info->var.xres == 64 && par->info->var.yres == 48)
 		set_addr_win_64x48(par);
+	else if (par->info->var.xres == 96 && par->info->var.yres == 39)
+		set_addr_win_96x39(par);
 }
 
 static int blank(struct fbtft_par *par, bool on)
@@ -188,11 +221,19 @@ static int write_vmem(struct fbtft_par *par, size_t offset, size_t len)
 					*buf |= BIT(i);
 			buf++;
 		}
+		if (yres % 8) {
+			*buf = 0x00;
+			for (i = 0; i < (yres - (y * 8)); i++)
+				if (vmem16[(y * 8 + i) * xres + x])
+					*buf |= BIT(i);
+			buf++;
+			y++;
+		}
 	}
 
 	/* Write data */
 	gpiod_set_value(par->gpio.dc, 1);
-	ret = par->fbtftops.write(par, par->txbuf.buf, xres * yres / 8);
+	ret = par->fbtftops.write(par, par->txbuf.buf, xres * (yres / 8 + (yres % 8 != 0)));
 	if (ret < 0)
 		dev_err(par->info->device, "write failed and returned: %d\n",
 			ret);
diff --git a/drivers/tty/serdev/core.c b/drivers/tty/serdev/core.c
index c5f0d936b003..85977b36ed7f 100644
--- a/drivers/tty/serdev/core.c
+++ b/drivers/tty/serdev/core.c
@@ -27,12 +27,17 @@ static ssize_t modalias_show(struct device *dev,
 			     struct device_attribute *attr, char *buf)
 {
 	int len;
+	struct serdev_device *serdev = to_serdev_device(dev);
 
 	len = acpi_device_modalias(dev, buf, PAGE_SIZE - 1);
 	if (len != -ENODEV)
 		return len;
 
-	return of_device_modalias(dev, buf, PAGE_SIZE);
+	len = of_device_modalias(dev, buf, PAGE_SIZE);
+	if (len != -ENODEV)
+		return len;
+
+	return sprintf(buf, "%s%s\n", SERDEV_MODULE_PREFIX, serdev->modalias);
 }
 static DEVICE_ATTR_RO(modalias);
 
@@ -45,14 +50,18 @@ ATTRIBUTE_GROUPS(serdev_device);
 static int serdev_device_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	int rc;
-
-	/* TODO: platform modalias */
+	struct serdev_device *serdev = to_serdev_device(dev);
 
 	rc = acpi_device_uevent_modalias(dev, env);
 	if (rc != -ENODEV)
 		return rc;
 
-	return of_device_uevent_modalias(dev, env);
+	rc = of_device_uevent_modalias(dev, env);
+	if (rc != -ENODEV)
+		return rc;
+
+	return add_uevent_var(env, "MODALIAS=%s%s", SERDEV_MODULE_PREFIX,
+							serdev->modalias);
 }
 
 static void serdev_device_release(struct device *dev)
@@ -83,16 +92,36 @@ static const struct device_type serdev_ctrl_type = {
 	.release	= serdev_ctrl_release,
 };
 
+static int serdev_match_id(const struct serdev_device_id *id,
+			   const struct serdev_device *sdev)
+{
+	while (id->name[0]) {
+		if (!strcmp(sdev->modalias, id->name))
+			return 1;
+		id++;
+	}
+
+	return 0;
+}
+
 static int serdev_device_match(struct device *dev, struct device_driver *drv)
 {
+	const struct serdev_device *sdev = to_serdev_device(dev);
+	const struct serdev_device_driver *sdrv = to_serdev_device_driver(drv);
+
 	if (!is_serdev_device(dev))
 		return 0;
 
-	/* TODO: platform matching */
 	if (acpi_driver_match_device(dev, drv))
 		return 1;
 
-	return of_driver_match_device(dev, drv);
+	if (of_driver_match_device(dev, drv))
+		return 1;
+
+	if (sdrv->id_table)
+		return serdev_match_id(sdrv->id_table, sdev);
+
+	return strcmp(sdev->modalias, drv->name) == 0;
 }
 
 /**
@@ -553,6 +582,17 @@ static int of_serdev_register_devices(struct serdev_controller *ctrl)
 	return 0;
 }
 
+struct serdev_controller *of_find_serdev_controller_by_node(struct device_node *node)
+{
+	struct device *dev = bus_find_device_by_of_node(&serdev_bus_type, node);
+
+	if (!dev)
+		return NULL;
+
+	return (dev->type == &serdev_ctrl_type) ? to_serdev_controller(dev) : NULL;
+}
+EXPORT_SYMBOL_GPL(of_find_serdev_controller_by_node);
+
 #ifdef CONFIG_ACPI
 
 #define SERDEV_ACPI_MAX_SCAN_DEPTH 32
@@ -750,6 +790,12 @@ int serdev_controller_add(struct serdev_controller *ctrl)
 
 	pm_runtime_enable(&ctrl->dev);
 
+	/* provide option to not delete a serdev controller without devices
+	 * if property is present
+	 */
+	if (device_property_present(&ctrl->dev, "force-empty-serdev-controller"))
+		return 0;
+
 	ret_of = of_serdev_register_devices(ctrl);
 	ret_acpi = acpi_serdev_register_devices(ctrl);
 	if (ret_of && ret_acpi) {
diff --git a/drivers/tty/serial/8250/8250_omap.c b/drivers/tty/serial/8250/8250_omap.c
index 562087df7d33..e746dab45425 100644
--- a/drivers/tty/serial/8250/8250_omap.c
+++ b/drivers/tty/serial/8250/8250_omap.c
@@ -1609,10 +1609,10 @@ static int __init omap8250_console_fixup(void)
 	}
 
 	add_preferred_console("ttyS", idx, options);
-	pr_err("WARNING: Your 'console=ttyO%d' has been replaced by 'ttyS%d'\n",
+	pr_info("WARNING: Your 'console=ttyO%d' has been replaced by 'ttyS%d'\n",
 	       idx, idx);
-	pr_err("This ensures that you still see kernel messages. Please\n");
-	pr_err("update your kernel commandline.\n");
+	pr_info("This ensures that you still see kernel messages. Please\n");
+	pr_info("update your kernel commandline.\n");
 	return 0;
 }
 console_initcall(omap8250_console_fixup);
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 26475b409b53..994037e56175 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -46,6 +46,7 @@ config USB
 	depends on USB_ARCH_HAS_HCD
 	select GENERIC_ALLOCATOR
 	select USB_COMMON
+	select POWER_SEQUENCE
 	select NLS  # for UTF-8 strings
 	help
 	  Universal Serial Bus (USB) is a specification for a serial bus
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 5b768b80d1ee..aec23924e666 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -30,6 +30,7 @@
 #include <linux/random.h>
 #include <linux/pm_qos.h>
 #include <linux/kobject.h>
+#include <linux/power/pwrseq.h>
 
 #include <linux/uaccess.h>
 #include <asm/byteorder.h>
@@ -1714,6 +1715,7 @@ static void hub_disconnect(struct usb_interface *intf)
 	hub->error = 0;
 	hub_quiesce(hub, HUB_DISCONNECT);
 
+	of_pwrseq_off_list(&hub->pwrseq_on_list);
 	mutex_lock(&usb_port_peer_mutex);
 
 	/* Avoid races with recursively_mark_NOTATTACHED() */
@@ -1764,11 +1766,41 @@ static bool hub_descriptor_is_sane(struct usb_host_interface *desc)
         return true;
 }
 
+#ifdef CONFIG_OF
+static int hub_of_pwrseq_on(struct usb_hub *hub)
+{
+	struct device *parent;
+	struct usb_device *hdev = hub->hdev;
+	struct device_node *np;
+	int ret;
+
+	if (hdev->parent)
+		parent = &hdev->dev;
+	else
+		parent = bus_to_hcd(hdev->bus)->self.sysdev;
+
+	for_each_child_of_node(parent->of_node, np) {
+		ret = of_pwrseq_on_list(np, &hub->pwrseq_on_list);
+		/* Maybe no power sequence library is chosen */
+		if (ret && ret != -ENOENT)
+			return ret;
+	}
+
+	return 0;
+}
+#else
+static int hub_of_pwrseq_on(struct usb_hub *hub)
+{
+	return 0;
+}
+#endif
+
 static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
 {
 	struct usb_host_interface *desc;
 	struct usb_device *hdev;
 	struct usb_hub *hub;
+	int ret = -ENODEV;
 
 	desc = intf->cur_altsetting;
 	hdev = interface_to_usbdev(intf);
@@ -1859,6 +1891,7 @@ static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	INIT_DELAYED_WORK(&hub->leds, led_work);
 	INIT_DELAYED_WORK(&hub->init_work, NULL);
 	INIT_WORK(&hub->events, hub_event);
+	INIT_LIST_HEAD(&hub->pwrseq_on_list);
 	spin_lock_init(&hub->irq_urb_lock);
 	timer_setup(&hub->irq_urb_retry, hub_retry_irq_urb, 0);
 	usb_get_intf(intf);
@@ -1879,11 +1912,14 @@ static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
 		usb_autopm_get_interface_no_resume(intf);
 	}
 
-	if (hub_configure(hub, &desc->endpoint[0].desc) >= 0)
-		return 0;
+	if (hub_configure(hub, &desc->endpoint[0].desc) >= 0) {
+		ret = hub_of_pwrseq_on(hub);
+		if (!ret)
+			return 0;
+	}
 
 	hub_disconnect(intf);
-	return -ENODEV;
+	return ret;
 }
 
 static int
@@ -3745,7 +3781,7 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 
 	/* stop hub_wq and related activity */
 	hub_quiesce(hub, HUB_SUSPEND);
-	return 0;
+	return pwrseq_suspend_list(&hub->pwrseq_on_list);
 }
 
 /* Report wakeup requests from the ports of a resuming root hub */
@@ -3785,8 +3821,13 @@ static void report_wakeup_requests(struct usb_hub *hub)
 static int hub_resume(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata(intf);
+	int ret;
 
 	dev_dbg(&intf->dev, "%s\n", __func__);
+	ret = pwrseq_resume_list(&hub->pwrseq_on_list);
+	if (ret)
+		return ret;
+
 	hub_activate(hub, HUB_RESUME);
 
 	/*
diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 73f4482d833a..dc4fd5908c7e 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -73,6 +73,7 @@ struct usb_hub {
 	spinlock_t		irq_urb_lock;
 	struct timer_list	irq_urb_retry;
 	struct usb_port		**ports;
+	struct list_head	pwrseq_on_list; /* powered pwrseq node list */
 };
 
 /**
diff --git a/firmware/am335x-bone-scale-data.bin b/firmware/am335x-bone-scale-data.bin
new file mode 100644
index 0000000000000000000000000000000000000000..1ce3c1c596d7a7f400b0cc89bda5a41eed2780c5
GIT binary patch
literal 73
pcmd-HXHZUIU{c}EWl|AfLZWk+R0P|Ad@#)bSHb~R0-{lr003gr3L5|b

literal 0
HcmV?d00001

diff --git a/firmware/am335x-evm-scale-data.bin b/firmware/am335x-evm-scale-data.bin
new file mode 100644
index 0000000000000000000000000000000000000000..a222389d233fa8f1c76ef35470b57284999c8df5
GIT binary patch
literal 17
Ucmd-HXJAiZVA55UX8=>$024d{B>(^b

literal 0
HcmV?d00001

diff --git a/firmware/am335x-pm-firmware.bin b/firmware/am335x-pm-firmware.bin
new file mode 100755
index 0000000000000000000000000000000000000000..1fc92e2bc40e9aaec0b3f60e0c2083ff40f22c3e
GIT binary patch
literal 11320
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
AF8}}l

literal 0
HcmV?d00001

diff --git a/firmware/am335x-pm-firmware.elf b/firmware/am335x-pm-firmware.elf
new file mode 100755
index 0000000000000000000000000000000000000000..843fc22ce3484251fc9700f013e13fac20896d67
GIT binary patch
literal 217168
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%0AAft+M_*+;JLCK{U!7WXdgj%>OOU1i
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
C6M#qn

literal 0
HcmV?d00001

diff --git a/firmware/am43x-evm-scale-data.bin b/firmware/am43x-evm-scale-data.bin
new file mode 100644
index 0000000000000000000000000000000000000000..2d71341089816be7989e6dc11b265d9194ac909e
GIT binary patch
literal 41
hcmd-HXAn+dU{VptW>OLB0@CSBDpG9>aG{wnApnMi2I2q!

literal 0
HcmV?d00001

diff --git a/include/linux/greybus/greybus_manifest.h b/include/linux/greybus/greybus_manifest.h
index 6e62fe478712..50d5a5fd3d51 100644
--- a/include/linux/greybus/greybus_manifest.h
+++ b/include/linux/greybus/greybus_manifest.h
@@ -23,6 +23,9 @@ enum greybus_descriptor_type {
 	GREYBUS_TYPE_STRING		= 0x02,
 	GREYBUS_TYPE_BUNDLE		= 0x03,
 	GREYBUS_TYPE_CPORT		= 0x04,
+	GREYBUS_TYPE_MIKROBUS		= 0x05,
+	GREYBUS_TYPE_PROPERTY		= 0x06,
+	GREYBUS_TYPE_DEVICE		= 0x07,
 };
 
 enum greybus_protocol {
@@ -151,6 +154,49 @@ struct greybus_descriptor_cport {
 	__u8	protocol_id;	/* enum greybus_protocol */
 } __packed;
 
+/*
+ * A mikrobus descriptor is used to describe the details
+ * about the bus ocnfiguration for the add-on board
+ * connected to the mikrobus port.
+ */
+struct greybus_descriptor_mikrobus {
+	__u8 pin_state[12];
+} __packed;
+
+/*
+ * A property descriptor is used to pass named properties
+ * to device drivers through the unified device properties
+ * interface under linux/property.h
+ */
+struct greybus_descriptor_property {
+	__u8 length;
+	__u8 id;
+	__u8 propname_stringid;
+	__u8 type;
+	__u8 value[0];
+} __packed;
+
+/*
+ * A device descriptor is used to describe the
+ * details required by a add-on board device
+ * driver.
+ */
+struct greybus_descriptor_device {
+	__u8 id;
+	__u8 driver_stringid;
+	__u8 protocol;
+	__u8 reg;
+	__le32 max_speed_hz;
+	__u8 irq;
+	__u8 irq_type;
+	__u8 mode;
+	__u8 prop_link;
+	__u8 gpio_link;
+	__u8 reg_link;
+	__u8 clock_link;
+	__u8 pad[1];
+} __packed;
+
 struct greybus_descriptor_header {
 	__le16	size;
 	__u8	type;		/* enum greybus_descriptor_type */
@@ -164,6 +210,9 @@ struct greybus_descriptor {
 		struct greybus_descriptor_interface	interface;
 		struct greybus_descriptor_bundle	bundle;
 		struct greybus_descriptor_cport		cport;
+		struct greybus_descriptor_mikrobus	mikrobus;
+		struct greybus_descriptor_property	property;
+		struct greybus_descriptor_device	device;
 	};
 } __packed;
 
diff --git a/include/linux/mod_devicetable.h b/include/linux/mod_devicetable.h
index 5b08a473cdba..656353952da2 100644
--- a/include/linux/mod_devicetable.h
+++ b/include/linux/mod_devicetable.h
@@ -486,6 +486,16 @@ struct i3c_device_id {
 	const void *data;
 };
 
+/* serdev */
+
+#define SERDEV_NAME_SIZE	32
+#define SERDEV_MODULE_PREFIX	"serdev:"
+
+struct serdev_device_id {
+	char name[SERDEV_NAME_SIZE];
+	kernel_ulong_t driver_data;
+};
+
 /* spi */
 
 #define SPI_NAME_SIZE	32
diff --git a/include/linux/power/pwrseq.h b/include/linux/power/pwrseq.h
new file mode 100644
index 000000000000..cbc344cdf9d2
--- /dev/null
+++ b/include/linux/power/pwrseq.h
@@ -0,0 +1,81 @@
+#ifndef __LINUX_PWRSEQ_H
+#define __LINUX_PWRSEQ_H
+
+#include <linux/of.h>
+
+#define PWRSEQ_MAX_CLKS		3
+
+/**
+ * struct pwrseq - the power sequence structure
+ * @pwrseq_of_match_table: the OF device id table this pwrseq library supports
+ * @node: the list pointer to be added to pwrseq list
+ * @get: the API is used to get pwrseq instance from the device node
+ * @on: do power on for this pwrseq instance
+ * @off: do power off for this pwrseq instance
+ * @put: release the resources on this pwrseq instance
+ * @suspend: do suspend operation on this pwrseq instance
+ * @resume: do resume operation on this pwrseq instance
+ * @used: this pwrseq instance is used by device
+ */
+struct pwrseq {
+	const struct of_device_id *pwrseq_of_match_table;
+	struct list_head node;
+	int (*get)(struct device_node *np, struct pwrseq *p);
+	int (*on)(struct pwrseq *p);
+	void (*off)(struct pwrseq *p);
+	void (*put)(struct pwrseq *p);
+	int (*suspend)(struct pwrseq *p);
+	int (*resume)(struct pwrseq *p);
+	bool used;
+	bool suspended;
+};
+
+/* used for power sequence instance list in one driver */
+struct pwrseq_list_per_dev {
+	struct pwrseq *pwrseq;
+	struct list_head list;
+};
+
+#if IS_ENABLED(CONFIG_POWER_SEQUENCE)
+void pwrseq_register(struct pwrseq *pwrseq);
+void pwrseq_unregister(struct pwrseq *pwrseq);
+struct pwrseq *of_pwrseq_on(struct device_node *np);
+void of_pwrseq_off(struct pwrseq *pwrseq);
+int of_pwrseq_on_list(struct device_node *np, struct list_head *head);
+void of_pwrseq_off_list(struct list_head *head);
+int pwrseq_suspend(struct pwrseq *p);
+int pwrseq_resume(struct pwrseq *p);
+int pwrseq_suspend_list(struct list_head *head);
+int pwrseq_resume_list(struct list_head *head);
+#else
+static inline void pwrseq_register(struct pwrseq *pwrseq) {}
+static inline void pwrseq_unregister(struct pwrseq *pwrseq) {}
+static inline struct pwrseq *of_pwrseq_on(struct device_node *np)
+{
+	return NULL;
+}
+static void of_pwrseq_off(struct pwrseq *pwrseq) {}
+static int of_pwrseq_on_list(struct device_node *np, struct list_head *head)
+{
+	return 0;
+}
+static void of_pwrseq_off_list(struct list_head *head) {}
+static int pwrseq_suspend(struct pwrseq *p)
+{
+	return 0;
+}
+static int pwrseq_resume(struct pwrseq *p)
+{
+	return 0;
+}
+static int pwrseq_suspend_list(struct list_head *head)
+{
+	return 0;
+}
+static int pwrseq_resume_list(struct list_head *head)
+{
+	return 0;
+}
+#endif /* CONFIG_POWER_SEQUENCE */
+
+#endif  /* __LINUX_PWRSEQ_H */
diff --git a/include/linux/serdev.h b/include/linux/serdev.h
index 9f14f9c12ec4..2e1eb4d17e1b 100644
--- a/include/linux/serdev.h
+++ b/include/linux/serdev.h
@@ -7,6 +7,7 @@
 
 #include <linux/types.h>
 #include <linux/device.h>
+#include <linux/mod_devicetable.h>
 #include <linux/termios.h>
 #include <linux/delay.h>
 
@@ -45,6 +46,7 @@ struct serdev_device {
 	const struct serdev_device_ops *ops;
 	struct completion write_comp;
 	struct mutex write_lock;
+	char modalias[SERDEV_NAME_SIZE];
 };
 
 static inline struct serdev_device *to_serdev_device(struct device *d)
@@ -63,6 +65,7 @@ struct serdev_device_driver {
 	struct device_driver driver;
 	int	(*probe)(struct serdev_device *);
 	void	(*remove)(struct serdev_device *);
+	const struct serdev_device_id *id_table;
 };
 
 static inline struct serdev_device_driver *to_serdev_device_driver(struct device_driver *d)
@@ -112,6 +115,8 @@ static inline struct serdev_controller *to_serdev_controller(struct device *d)
 	return container_of(d, struct serdev_controller, dev);
 }
 
+struct serdev_controller *of_find_serdev_controller_by_node(struct device_node *node);
+
 static inline void *serdev_device_get_drvdata(const struct serdev_device *serdev)
 {
 	return dev_get_drvdata(&serdev->dev);
diff --git a/include/uapi/linux/can/isotp.h b/include/uapi/linux/can/isotp.h
new file mode 100644
index 000000000000..e6f312e2bb97
--- /dev/null
+++ b/include/uapi/linux/can/isotp.h
@@ -0,0 +1,136 @@
+/* SPDX-License-Identifier: ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause) */
+/*
+ * socketcan/can/isotp.h
+ *
+ * Definitions for isotp CAN sockets
+ *
+ * Author: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ * Copyright (c) 2008 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_ISOTP_H
+#define CAN_ISOTP_H
+
+#include <linux/can.h>
+
+#define SOL_CAN_ISOTP (SOL_CAN_BASE + CAN_ISOTP)
+
+/* for socket options affecting the socket (not the global system) */
+
+#define CAN_ISOTP_OPTS		1	/* pass struct can_isotp_options */
+
+#define CAN_ISOTP_RECV_FC	2	/* pass struct can_isotp_fc_options */
+
+/* sockopts to force stmin timer values for protocol regression tests */
+
+#define CAN_ISOTP_TX_STMIN	3	/* pass __u32 value in nano secs    */
+					/* use this time instead of value   */
+					/* provided in FC from the receiver */
+
+#define CAN_ISOTP_RX_STMIN	4	/* pass __u32 value in nano secs   */
+					/* ignore received CF frames which */
+					/* timestamps differ less than val */
+
+#define CAN_ISOTP_LL_OPTS	5	/* pass struct can_isotp_ll_options */
+
+struct can_isotp_options {
+
+	__u32 flags;		/* set flags for isotp behaviour.	*/
+				/* __u32 value : flags see below	*/
+
+	__u32 frame_txtime;	/* frame transmission time (N_As/N_Ar)	*/
+				/* __u32 value : time in nano secs	*/
+
+	__u8  ext_address;	/* set address for extended addressing	*/
+				/* __u8 value : extended address	*/
+
+	__u8  txpad_content;	/* set content of padding byte (tx)	*/
+				/* __u8 value : content	on tx path	*/
+
+	__u8  rxpad_content;	/* set content of padding byte (rx)	*/
+				/* __u8 value : content	on rx path	*/
+
+	__u8  rx_ext_address;	/* set address for extended addressing	*/
+				/* __u8 value : extended address (rx)	*/
+};
+
+struct can_isotp_fc_options {
+
+	__u8  bs;		/* blocksize provided in FC frame	*/
+				/* __u8 value : blocksize. 0 = off	*/
+
+	__u8  stmin;		/* separation time provided in FC frame	*/
+				/* __u8 value :				*/
+				/* 0x00 - 0x7F : 0 - 127 ms		*/
+				/* 0x80 - 0xF0 : reserved		*/
+				/* 0xF1 - 0xF9 : 100 us - 900 us	*/
+				/* 0xFA - 0xFF : reserved		*/
+
+	__u8  wftmax;		/* max. number of wait frame transmiss.	*/
+				/* __u8 value : 0 = omit FC N_PDU WT	*/
+};
+
+struct can_isotp_ll_options {
+
+	__u8  mtu;		/* generated & accepted CAN frame type	*/
+				/* __u8 value :				*/
+				/* CAN_MTU   (16) -> standard CAN 2.0	*/
+				/* CANFD_MTU (72) -> CAN FD frame	*/
+
+	__u8  tx_dl;		/* tx link layer data length in bytes	*/
+				/* (configured maximum payload length)	*/
+				/* __u8 value : 8,12,16,20,24,32,48,64	*/
+				/* => rx path supports all LL_DL values */
+
+	__u8  tx_flags;		/* set into struct canfd_frame.flags	*/
+				/* at frame creation: e.g. CANFD_BRS	*/
+				/* Obsolete when the BRS flag is fixed	*/
+				/* by the CAN netdriver configuration	*/
+};
+
+/* flags for isotp behaviour */
+
+#define CAN_ISOTP_LISTEN_MODE	0x001	/* listen only (do not send FC) */
+#define CAN_ISOTP_EXTEND_ADDR	0x002	/* enable extended addressing */
+#define CAN_ISOTP_TX_PADDING	0x004	/* enable CAN frame padding tx path */
+#define CAN_ISOTP_RX_PADDING	0x008	/* enable CAN frame padding rx path */
+#define CAN_ISOTP_CHK_PAD_LEN	0x010	/* check received CAN frame padding */
+#define CAN_ISOTP_CHK_PAD_DATA	0x020	/* check received CAN frame padding */
+#define CAN_ISOTP_HALF_DUPLEX	0x040	/* half duplex error state handling */
+#define CAN_ISOTP_FORCE_TXSTMIN	0x080	/* ignore stmin from received FC */
+#define CAN_ISOTP_FORCE_RXSTMIN	0x100	/* ignore CFs depending on rx stmin */
+#define CAN_ISOTP_RX_EXT_ADDR	0x200	/* different rx extended addressing */
+#define CAN_ISOTP_WAIT_TX_DONE	0x400	/* wait for tx completion */
+
+
+/* default values */
+
+#define CAN_ISOTP_DEFAULT_FLAGS		0
+#define CAN_ISOTP_DEFAULT_EXT_ADDRESS	0x00
+#define CAN_ISOTP_DEFAULT_PAD_CONTENT	0xCC /* prevent bit-stuffing */
+#define CAN_ISOTP_DEFAULT_FRAME_TXTIME	0
+#define CAN_ISOTP_DEFAULT_RECV_BS	0
+#define CAN_ISOTP_DEFAULT_RECV_STMIN	0x00
+#define CAN_ISOTP_DEFAULT_RECV_WFTMAX	0
+
+#define CAN_ISOTP_DEFAULT_LL_MTU	CAN_MTU
+#define CAN_ISOTP_DEFAULT_LL_TX_DL	CAN_MAX_DLEN
+#define CAN_ISOTP_DEFAULT_LL_TX_FLAGS	0
+
+/*
+ * Remark on CAN_ISOTP_DEFAULT_RECV_* values:
+ *
+ * We can strongly assume, that the Linux Kernel implementation of
+ * CAN_ISOTP is capable to run with BS=0, STmin=0 and WFTmax=0.
+ * But as we like to be able to behave as a commonly available ECU,
+ * these default settings can be changed via sockopts.
+ * For that reason the STmin value is intentionally _not_ checked for
+ * consistency and copied directly into the flow control (FC) frame.
+ *
+ */
+
+#endif
diff --git a/net/can/Kconfig b/net/can/Kconfig
index 25436a715db3..80a64aac832a 100644
--- a/net/can/Kconfig
+++ b/net/can/Kconfig
@@ -55,6 +55,16 @@ config CAN_GW
 
 source "net/can/j1939/Kconfig"
 
+config CAN_ISOTP
+	tristate "ISO 15765-2:2016 CAN transport protocol"
+	default y
+	help
+	  ISO 15765-2 CAN transport protocol for protocol family CAN
+
+	  This implementation is already widely used in automotive use-cases, e.g.
+	  for UDS based OBD diagnosis. Although some small adaptions may be applied
+	  to make it ready for Linux Mainline. Feedback is welcome.
+
 source "drivers/net/can/Kconfig"
 
 endif
diff --git a/net/can/Makefile b/net/can/Makefile
index 08bd217fc051..cfa1024369cf 100644
--- a/net/can/Makefile
+++ b/net/can/Makefile
@@ -16,4 +16,7 @@ can-bcm-y		:= bcm.o
 obj-$(CONFIG_CAN_GW)	+= can-gw.o
 can-gw-y		:= gw.o
 
+obj-$(CONFIG_CAN_ISOTP)	+= can-isotp.o
+can-isotp-y		:= isotp.o
+
 obj-$(CONFIG_CAN_J1939)	+= j1939/
diff --git a/net/can/isotp.c b/net/can/isotp.c
new file mode 100644
index 000000000000..eb23843fe71f
--- /dev/null
+++ b/net/can/isotp.c
@@ -0,0 +1,1535 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/* isotp.c - ISO 15765-2 CAN transport protocol for protocol family CAN
+ *
+ * WARNING: This is ALPHA code for discussions and first tests that should
+ *          not be used in production environments.
+ *
+ * In the discussion the Socket-API to the userspace or the ISO-TP socket
+ * options or the return values we may change! Current behaviour:
+ *
+ * - no ISO-TP specific return values are provided to the userspace
+ * - when a transfer (tx) is on the run the next write() blocks until it's done
+ * - no support for sending wait frames to the data source in the rx path
+ *
+ * Copyright (c) 2020 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/hrtimer.h>
+#include <linux/wait.h>
+#include <linux/uio.h>
+#include <linux/net.h>
+#include <linux/netdevice.h>
+#include <linux/socket.h>
+#include <linux/if_arp.h>
+#include <linux/skbuff.h>
+#include <linux/can.h>
+#include <linux/can/core.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0)
+#include <linux/can/skb.h>
+#define CAN_SKBRES sizeof(struct can_skb_priv)
+#else
+#define CAN_SKBRES 0
+#endif
+#include <linux/can/isotp.h>
+#include <net/sock.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+#include <net/net_namespace.h>
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+#include "compat.h"
+#endif
+
+#define CAN_ISOTP_VERSION "20201014 - out-of-tree"
+
+MODULE_DESCRIPTION("PF_CAN isotp 15765-2:2016 protocol");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Oliver Hartkopp <socketcan@hartkopp.net>");
+MODULE_ALIAS("can-proto-6");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+#error This modules needs hrtimers (available since Kernel 2.6.22)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,10,0)
+#error No need to compile this out-of-tree driver! ISO-TP is part of Linux Mainline kernel since Linux 5.10.
+#endif
+
+#define DBG(fmt, args...) (printk( KERN_DEBUG "can-isotp: %s: " fmt, \
+				   __func__, ##args))
+#undef DBG
+#define DBG(fmt, args...)
+
+#define SINGLE_MASK(id) (((id) & CAN_EFF_FLAG) ? \
+			 (CAN_EFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG) : \
+			 (CAN_SFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG))
+
+/* ISO 15765-2:2016 supports more than 4095 byte per ISO PDU as the FF_DL can
+ * take full 32 bit values (4 Gbyte). We would need some good concept to handle
+ * this between user space and kernel space. For now increase the static buffer
+ * to something about 8 kbyte to be able to test this new functionality.
+ */
+#define MAX_MSG_LENGTH 8200
+
+/* N_PCI type values in bits 7-4 of N_PCI bytes */
+#define N_PCI_SF 0x00	/* single frame */
+#define N_PCI_FF 0x10	/* first frame */
+#define N_PCI_CF 0x20	/* consecutive frame */
+#define N_PCI_FC 0x30	/* flow control */
+
+#define N_PCI_SZ 1	/* size of the PCI byte #1 */
+#define SF_PCI_SZ4 1	/* size of SingleFrame PCI including 4 bit SF_DL */
+#define SF_PCI_SZ8 2	/* size of SingleFrame PCI including 8 bit SF_DL */
+#define FF_PCI_SZ12 2	/* size of FirstFrame PCI including 12 bit FF_DL */
+#define FF_PCI_SZ32 6	/* size of FirstFrame PCI including 32 bit FF_DL */
+#define FC_CONTENT_SZ 3	/* flow control content size in byte (FS/BS/STmin) */
+
+#define ISOTP_CHECK_PADDING (CAN_ISOTP_CHK_PAD_LEN | CAN_ISOTP_CHK_PAD_DATA)
+
+/* Flow Status given in FC frame */
+#define ISOTP_FC_CTS 0		/* clear to send */
+#define ISOTP_FC_WT 1		/* wait */
+#define ISOTP_FC_OVFLW 2	/* overflow */
+
+enum {
+	ISOTP_IDLE = 0,
+	ISOTP_WAIT_FIRST_FC,
+	ISOTP_WAIT_FC,
+	ISOTP_WAIT_DATA,
+	ISOTP_SENDING
+};
+
+struct tpcon {
+	int idx;
+	int len;
+	u8 state;
+	u8 bs;
+	u8 sn;
+	u8 ll_dl;
+	u8 buf[MAX_MSG_LENGTH + 1];
+};
+
+struct isotp_sock {
+	struct sock sk;
+	int bound;
+	int ifindex;
+	canid_t txid;
+	canid_t rxid;
+	ktime_t tx_gap;
+	ktime_t lastrxcf_tstamp;
+	struct hrtimer rxtimer, txtimer;
+	struct tasklet_struct txtsklet;
+	struct can_isotp_options opt;
+	struct can_isotp_fc_options rxfc, txfc;
+	struct can_isotp_ll_options ll;
+	u32 force_tx_stmin;
+	u32 force_rx_stmin;
+	struct tpcon rx, tx;
+	struct notifier_block notifier;
+	wait_queue_head_t wait;
+};
+
+static inline struct isotp_sock *isotp_sk(const struct sock *sk)
+{
+	return (struct isotp_sock *)sk;
+}
+
+static enum hrtimer_restart isotp_rx_timer_handler(struct hrtimer *hrtimer)
+{
+	struct isotp_sock *so = container_of(hrtimer, struct isotp_sock,
+					     rxtimer);
+	if (so->rx.state == ISOTP_WAIT_DATA) {
+		DBG("we did not get new data frames in time.\n");
+
+		/* reset tx state */
+		so->rx.state = ISOTP_IDLE;
+	}
+
+	return HRTIMER_NORESTART;
+}
+
+static void isotp_skb_reserve(struct sk_buff *skb, struct net_device *dev)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0)
+	can_skb_reserve(skb);
+	can_skb_prv(skb)->ifindex = dev->ifindex;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,5)
+	can_skb_prv(skb)->skbcnt = 0;
+#endif
+}
+
+static void isotp_skb_destructor(struct sk_buff *skb)
+{
+	sock_put(skb->sk);
+}
+
+static inline void isotp_skb_set_owner(struct sk_buff *skb, struct sock *sk)
+{
+	if (sk) {
+		sock_hold(sk);
+		skb->destructor = isotp_skb_destructor;
+		skb->sk = sk;
+	}
+}
+
+static int isotp_send_fc(struct sock *sk, int ae, u8 flowstatus)
+{
+	struct net_device *dev;
+	struct sk_buff *nskb;
+	struct canfd_frame *ncf;
+	struct isotp_sock *so = isotp_sk(sk);
+
+	nskb = alloc_skb(so->ll.mtu + CAN_SKBRES, gfp_any());
+	if (!nskb)
+		return 1;
+
+	dev = dev_get_by_index(sock_net(sk), so->ifindex);
+	if (!dev) {
+		kfree_skb(nskb);
+		return 1;
+	}
+	isotp_skb_reserve(nskb, dev);
+	nskb->dev = dev;
+	isotp_skb_set_owner(nskb, sk);
+	ncf = (struct canfd_frame *) nskb->data;
+	skb_put(nskb, so->ll.mtu);
+
+	/* create & send flow control reply */
+	ncf->can_id = so->txid;
+
+	if (so->opt.flags & CAN_ISOTP_TX_PADDING) {
+		memset(ncf->data, so->opt.txpad_content, CAN_MAX_DLEN);
+		ncf->len = CAN_MAX_DLEN;
+	} else {
+		ncf->len = ae + FC_CONTENT_SZ;
+	}
+
+	ncf->data[ae] = N_PCI_FC | flowstatus;
+	ncf->data[ae + 1] = so->rxfc.bs;
+	ncf->data[ae + 2] = so->rxfc.stmin;
+
+	if (ae)
+		ncf->data[0] = so->opt.ext_address;
+
+	if (so->ll.mtu == CANFD_MTU)
+		ncf->flags = so->ll.tx_flags;
+
+	can_send(nskb, 1);
+	dev_put(dev);
+
+	/* reset blocksize counter */
+	so->rx.bs = 0;
+
+	/* reset last CF frame rx timestamp for rx stmin enforcement */
+	so->lastrxcf_tstamp = ktime_set(0, 0);
+
+	/* start rx timeout watchdog */
+	hrtimer_start(&so->rxtimer, ktime_set(1, 0), HRTIMER_MODE_REL);
+	return 0;
+}
+
+static void isotp_rcv_skb(struct sk_buff *skb, struct sock *sk)
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)skb->cb;
+
+	BUILD_BUG_ON(sizeof(skb->cb) < sizeof(struct sockaddr_can));
+
+	memset(addr, 0, sizeof(*addr));
+	addr->can_family = AF_CAN;
+	addr->can_ifindex = skb->dev->ifindex;
+
+	if (sock_queue_rcv_skb(sk, skb) < 0)
+		kfree_skb(skb);
+}
+
+static u8 padlen(u8 datalen)
+{
+	const u8 plen[] = {8, 8, 8, 8, 8, 8, 8, 8, 8,		/* 0 - 8 */
+			   12, 12, 12, 12,			/* 9 - 12 */
+			   16, 16, 16, 16,			/* 13 - 16 */
+			   20, 20, 20, 20,			/* 17 - 20 */
+			   24, 24, 24, 24,			/* 21 - 24 */
+			   32, 32, 32, 32, 32, 32, 32, 32,	/* 25 - 32 */
+			   48, 48, 48, 48, 48, 48, 48, 48,	/* 33 - 40 */
+			   48, 48, 48, 48, 48, 48, 48, 48};	/* 41 - 48 */
+
+	if (datalen > 48)
+		return 64;
+
+	return plen[datalen];
+}
+
+/* check for length optimization and return 1/true when the check fails */
+static int check_optimized(struct canfd_frame *cf, int start_index)
+{
+	/* for CAN_DL <= 8 the start_index is equal to the CAN_DL as the
+	 * padding would start at this point. E.g. if the padding would
+	 * start at cf.data[7] cf->len has to be 7 to be optimal.
+	 * Note: The data[] index starts with zero.
+	 */
+	if (cf->len <= CAN_MAX_DLEN)
+		return (cf->len != start_index);
+
+	/* This relation is also valid in the non-linear DLC range, where
+	 * we need to take care of the minimal next possible CAN_DL.
+	 * The correct check would be (padlen(cf->len) != padlen(start_index)).
+	 * But as cf->len can only take discrete values from 12, .., 64 at this
+	 * point the padlen(cf->len) is always equal to cf->len.
+	 */
+	return (cf->len != padlen(start_index));
+}
+
+/* check padding and return 1/true when the check fails */
+static int check_pad(struct isotp_sock *so, struct canfd_frame *cf,
+		     int start_index, u8 content)
+{
+	int i;
+
+	/* no RX_PADDING value => check length of optimized frame length */
+	if (!(so->opt.flags & CAN_ISOTP_RX_PADDING)) {
+		if (so->opt.flags & CAN_ISOTP_CHK_PAD_LEN)
+			return check_optimized(cf, start_index);
+
+		/* no valid test against empty value => ignore frame */
+		return 1;
+	}
+
+	/* check datalength of correctly padded CAN frame */
+	if ((so->opt.flags & CAN_ISOTP_CHK_PAD_LEN) &&
+	    cf->len != padlen(cf->len))
+		return 1;
+
+	/* check padding content */
+	if (so->opt.flags & CAN_ISOTP_CHK_PAD_DATA) {
+		for (i = start_index; i < cf->len; i++)
+			if (cf->data[i] != content)
+				return 1;
+	}
+	return 0;
+}
+
+static int isotp_rcv_fc(struct isotp_sock *so, struct canfd_frame *cf, int ae)
+{
+	if (so->tx.state != ISOTP_WAIT_FC &&
+	    so->tx.state != ISOTP_WAIT_FIRST_FC)
+		return 0;
+
+	hrtimer_cancel(&so->txtimer);
+
+	if ((cf->len < ae + FC_CONTENT_SZ) ||
+	    ((so->opt.flags & ISOTP_CHECK_PADDING) &&
+	     check_pad(so, cf, ae + FC_CONTENT_SZ, so->opt.rxpad_content))) {
+		so->tx.state = ISOTP_IDLE;
+		wake_up_interruptible(&so->wait);
+		return 1;
+	}
+
+	/* get communication parameters only from the first FC frame */
+	if (so->tx.state == ISOTP_WAIT_FIRST_FC) {
+		so->txfc.bs = cf->data[ae + 1];
+		so->txfc.stmin = cf->data[ae + 2];
+
+		/* fix wrong STmin values according spec */
+		if (so->txfc.stmin > 0x7F &&
+		    (so->txfc.stmin < 0xF1 || so->txfc.stmin > 0xF9))
+			so->txfc.stmin = 0x7F;
+
+		so->tx_gap = ktime_set(0, 0);
+		/* add transmission time for CAN frame N_As */
+		so->tx_gap = ktime_add_ns(so->tx_gap, so->opt.frame_txtime);
+		/* add waiting time for consecutive frames N_Cs */
+		if (so->opt.flags & CAN_ISOTP_FORCE_TXSTMIN)
+			so->tx_gap = ktime_add_ns(so->tx_gap,
+						  so->force_tx_stmin);
+		else if (so->txfc.stmin < 0x80)
+			so->tx_gap = ktime_add_ns(so->tx_gap,
+						  so->txfc.stmin * 1000000);
+		else
+			so->tx_gap = ktime_add_ns(so->tx_gap,
+						  (so->txfc.stmin - 0xF0)
+						  * 100000);
+		so->tx.state = ISOTP_WAIT_FC;
+	}
+
+	DBG("FC frame: FS %d, BS %d, STmin 0x%02X, tx_gap %lld\n",
+	    cf->data[ae] & 0x0F & 0x0F, so->txfc.bs, so->txfc.stmin,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+	    (long long)so->tx_gap);
+#else
+	    (long long)so->tx_gap.tv64);
+#endif
+
+	switch (cf->data[ae] & 0x0F) {
+	case ISOTP_FC_CTS:
+		so->tx.bs = 0;
+		so->tx.state = ISOTP_SENDING;
+		DBG("starting txtimer for sending\n");
+		/* start cyclic timer for sending CF frame */
+		hrtimer_start(&so->txtimer, so->tx_gap,
+			      HRTIMER_MODE_REL);
+		break;
+
+	case ISOTP_FC_WT:
+		DBG("starting waiting for next FC\n");
+		/* start timer to wait for next FC frame */
+		hrtimer_start(&so->txtimer, ktime_set(1,0),
+			      HRTIMER_MODE_REL);
+		break;
+
+	case ISOTP_FC_OVFLW:
+		DBG("overflow in receiver side\n");
+
+	default:
+		/* stop this tx job */
+		so->tx.state = ISOTP_IDLE;
+		wake_up_interruptible(&so->wait);
+	}
+	return 0;
+}
+
+static int isotp_rcv_sf(struct sock *sk, struct canfd_frame *cf, int pcilen,
+			struct sk_buff *skb, int len)
+{
+	struct isotp_sock *so = isotp_sk(sk);
+	struct sk_buff *nskb;
+
+	hrtimer_cancel(&so->rxtimer);
+	so->rx.state = ISOTP_IDLE;
+
+	if (!len || len > cf->len - pcilen)
+		return 1;
+
+	if ((so->opt.flags & ISOTP_CHECK_PADDING) &&
+	    check_pad(so, cf, pcilen + len, so->opt.rxpad_content)) {
+		return 1;
+	}
+
+	nskb = alloc_skb(len, gfp_any());
+	if (!nskb)
+		return 1;
+
+	memcpy(skb_put(nskb, len), &cf->data[pcilen], len);
+
+	nskb->tstamp = skb->tstamp;
+	nskb->dev = skb->dev;
+	isotp_rcv_skb(nskb, sk);
+	return 0;
+}
+
+static int isotp_rcv_ff(struct sock *sk, struct canfd_frame *cf, int ae)
+{
+	struct isotp_sock *so = isotp_sk(sk);
+	int i;
+	int off;
+	int ff_pci_sz;
+
+	hrtimer_cancel(&so->rxtimer);
+	so->rx.state = ISOTP_IDLE;
+
+	/* get the used sender LL_DL from the (first) CAN frame data length */
+	so->rx.ll_dl = padlen(cf->len);
+
+	/* the first frame has to use the entire frame up to LL_DL length */
+	if (cf->len != so->rx.ll_dl)
+		return 1;
+
+	/* get the FF_DL */
+	so->rx.len = (cf->data[ae] & 0x0F) << 8;
+	so->rx.len += cf->data[ae + 1];
+
+	/* Check for FF_DL escape sequence supporting 32 bit PDU length */
+	if (so->rx.len) {
+		ff_pci_sz = FF_PCI_SZ12;
+	} else {
+		/* FF_DL = 0 => get real length from next 4 bytes */
+		so->rx.len = cf->data[ae + 2] << 24;
+		so->rx.len += cf->data[ae + 3] << 16;
+		so->rx.len += cf->data[ae + 4] << 8;
+		so->rx.len += cf->data[ae + 5];
+		ff_pci_sz = FF_PCI_SZ32;
+	}
+
+	/* take care of a potential SF_DL ESC offset for TX_DL > 8 */
+	off = (so->rx.ll_dl > CAN_MAX_DLEN) ? 1 : 0;
+
+	if (so->rx.len + ae + off + ff_pci_sz < so->rx.ll_dl)
+		return 1;
+
+	if (so->rx.len > MAX_MSG_LENGTH) {
+		/* send FC frame with overflow status */
+		isotp_send_fc(sk, ae, ISOTP_FC_OVFLW);
+		return 1;
+	}
+
+	/* copy the first received data bytes */
+	so->rx.idx = 0;
+	for (i = ae + ff_pci_sz; i < so->rx.ll_dl; i++)
+		so->rx.buf[so->rx.idx++] = cf->data[i];
+
+	/* initial setup for this pdu reception */
+	so->rx.sn = 1;
+	so->rx.state = ISOTP_WAIT_DATA;
+
+	/* no creation of flow control frames */
+	if (so->opt.flags & CAN_ISOTP_LISTEN_MODE)
+		return 0;
+
+	/* send our first FC frame */
+	isotp_send_fc(sk, ae, ISOTP_FC_CTS);
+	return 0;
+}
+
+static int isotp_rcv_cf(struct sock *sk, struct canfd_frame *cf, int ae,
+			struct sk_buff *skb)
+{
+	struct isotp_sock *so = isotp_sk(sk);
+	struct sk_buff *nskb;
+	int i;
+
+	if (so->rx.state != ISOTP_WAIT_DATA)
+		return 0;
+
+	/* drop if timestamp gap is less than force_rx_stmin nano secs */
+	if (so->opt.flags & CAN_ISOTP_FORCE_RXSTMIN) {
+		if (ktime_to_ns(ktime_sub(skb->tstamp, so->lastrxcf_tstamp)) <
+		    so->force_rx_stmin)
+			return 0;
+
+		so->lastrxcf_tstamp = skb->tstamp;
+	}
+
+	hrtimer_cancel(&so->rxtimer);
+
+	/* CFs are never longer than the FF */
+	if (cf->len > so->rx.ll_dl)
+		return 1;
+
+	/* CFs have usually the LL_DL length */
+	if (cf->len < so->rx.ll_dl) {
+		/* this is only allowed for the last CF */
+		if (so->rx.len - so->rx.idx > so->rx.ll_dl - ae - N_PCI_SZ)
+			return 1;
+	}
+
+	if ((cf->data[ae] & 0x0F) != so->rx.sn) {
+		DBG("wrong sn %d. expected %d.\n",
+		    cf->data[ae] & 0x0F, so->rx.sn);
+		/* some error reporting? */
+		so->rx.state = ISOTP_IDLE;
+		return 1;
+	}
+	so->rx.sn++;
+	so->rx.sn %= 16;
+
+	for (i = ae + N_PCI_SZ; i < cf->len; i++) {
+		so->rx.buf[so->rx.idx++] = cf->data[i];
+		if (so->rx.idx >= so->rx.len)
+			break;
+	}
+
+	if (so->rx.idx >= so->rx.len) {
+		/* we are done */
+		so->rx.state = ISOTP_IDLE;
+
+		if ((so->opt.flags & ISOTP_CHECK_PADDING) &&
+		    check_pad(so, cf, i + 1, so->opt.rxpad_content)) {
+			return 1;
+		}
+
+		nskb = alloc_skb(so->rx.len, gfp_any());
+		if (!nskb)
+			return 1;
+
+		memcpy(skb_put(nskb, so->rx.len), so->rx.buf,
+		       so->rx.len);
+
+		nskb->tstamp = skb->tstamp;
+		nskb->dev = skb->dev;
+		isotp_rcv_skb(nskb, sk);
+		return 0;
+	}
+
+	/* perform blocksize handling, if enabled */
+	if (!so->rxfc.bs || ++so->rx.bs < so->rxfc.bs) {
+		/* start rx timeout watchdog */
+		hrtimer_start(&so->rxtimer, ktime_set(1, 0),
+			      HRTIMER_MODE_REL);
+		return 0;
+	}
+
+	/* no creation of flow control frames */
+	if (so->opt.flags & CAN_ISOTP_LISTEN_MODE)
+		return 0;
+
+	/* we reached the specified blocksize so->rxfc.bs */
+	isotp_send_fc(sk, ae, ISOTP_FC_CTS);
+	return 0;
+}
+
+static void isotp_rcv(struct sk_buff *skb, void *data)
+{
+	struct sock *sk = (struct sock *)data;
+	struct isotp_sock *so = isotp_sk(sk);
+	struct canfd_frame *cf;
+	int ae = (so->opt.flags & CAN_ISOTP_EXTEND_ADDR) ? 1 : 0;
+	u8 n_pci_type, sf_dl;
+
+	/* Strictly receive only frames with the configured MTU size
+	 * => clear separation of CAN2.0 / CAN FD transport channels
+	 */
+	if (skb->len != so->ll.mtu)
+		return;
+
+	cf = (struct canfd_frame *)skb->data;
+
+	/* if enabled: check reception of my configured extended address */
+	if (ae && cf->data[0] != so->opt.rx_ext_address)
+		return;
+
+	n_pci_type = cf->data[ae] & 0xF0;
+
+	if (so->opt.flags & CAN_ISOTP_HALF_DUPLEX) {
+		/* check rx/tx path half duplex expectations */
+		if ((so->tx.state != ISOTP_IDLE && n_pci_type != N_PCI_FC) ||
+		    (so->rx.state != ISOTP_IDLE && n_pci_type == N_PCI_FC))
+			return;
+	}
+
+	switch (n_pci_type) {
+	case N_PCI_FC:
+		/* tx path: flow control frame containing the FC parameters */
+		isotp_rcv_fc(so, cf, ae);
+		break;
+
+	case N_PCI_SF:
+		/* rx path: single frame
+		 *
+		 * As we do not have a rx.ll_dl configuration, we can only test
+		 * if the CAN frames payload length matches the LL_DL == 8
+		 * requirements - no matter if it's CAN 2.0 or CAN FD
+		 */
+
+		/* get the SF_DL from the N_PCI byte */
+		sf_dl = cf->data[ae] & 0x0F;
+
+		if (cf->len <= CAN_MAX_DLEN) {
+			isotp_rcv_sf(sk, cf, SF_PCI_SZ4 + ae, skb, sf_dl);
+		} else {
+			if (skb->len == CANFD_MTU) {
+				/* We have a CAN FD frame and CAN_DL is greater than 8:
+				 * Only frames with the SF_DL == 0 ESC value are valid.
+				 *
+				 * If so take care of the increased SF PCI size
+				 * (SF_PCI_SZ8) to point to the message content behind
+				 * the extended SF PCI info and get the real SF_DL
+				 * length value from the formerly first data byte.
+				 */
+				if (sf_dl == 0)
+					isotp_rcv_sf(sk, cf, SF_PCI_SZ8 + ae, skb,
+						     cf->data[SF_PCI_SZ4 + ae]);
+			}
+		}
+		break;
+
+	case N_PCI_FF:
+		/* rx path: first frame */
+		isotp_rcv_ff(sk, cf, ae);
+		break;
+
+	case N_PCI_CF:
+		/* rx path: consecutive frame */
+		isotp_rcv_cf(sk, cf, ae, skb);
+		break;
+	}
+}
+
+static void isotp_fill_dataframe(struct canfd_frame *cf, struct isotp_sock *so,
+				 int ae, int off)
+{
+	int pcilen = N_PCI_SZ + ae + off;
+	int space = so->tx.ll_dl - pcilen;
+	int num = min_t(int, so->tx.len - so->tx.idx, space);
+	int i;
+
+	cf->can_id = so->txid;
+	cf->len = num + pcilen;
+
+	if (num < space) {
+		if (so->opt.flags & CAN_ISOTP_TX_PADDING) {
+			/* user requested padding */
+			cf->len = padlen(cf->len);
+			memset(cf->data, so->opt.txpad_content, cf->len);
+		} else if (cf->len > CAN_MAX_DLEN) {
+			/* mandatory padding for CAN FD frames */
+			cf->len = padlen(cf->len);
+			memset(cf->data, CAN_ISOTP_DEFAULT_PAD_CONTENT,
+			       cf->len);
+		}
+	}
+
+	for (i = 0; i < num; i++)
+		cf->data[pcilen + i] = so->tx.buf[so->tx.idx++];
+
+	if (ae)
+		cf->data[0] = so->opt.ext_address;
+}
+
+static void isotp_create_fframe(struct canfd_frame *cf, struct isotp_sock *so,
+				int ae)
+{
+	int i;
+	int ff_pci_sz;
+
+	cf->can_id = so->txid;
+	cf->len = so->tx.ll_dl;
+	if (ae)
+		cf->data[0] = so->opt.ext_address;
+
+	/* create N_PCI bytes with 12/32 bit FF_DL data length */
+	if (so->tx.len > 4095) {
+		/* use 32 bit FF_DL notation */
+		cf->data[ae] = N_PCI_FF;
+		cf->data[ae + 1] = 0;
+		cf->data[ae + 2] = (u8)(so->tx.len >> 24) & 0xFFU;
+		cf->data[ae + 3] = (u8)(so->tx.len >> 16) & 0xFFU;
+		cf->data[ae + 4] = (u8)(so->tx.len >> 8) & 0xFFU;
+		cf->data[ae + 5] = (u8)so->tx.len & 0xFFU;
+		ff_pci_sz = FF_PCI_SZ32;
+	} else {
+		/* use 12 bit FF_DL notation */
+		cf->data[ae] = (u8)(so->tx.len >> 8) | N_PCI_FF;
+		cf->data[ae + 1] = (u8)so->tx.len & 0xFFU;
+		ff_pci_sz = FF_PCI_SZ12;
+	}
+
+	/* add first data bytes depending on ae */
+	for (i = ae + ff_pci_sz; i < so->tx.ll_dl; i++)
+		cf->data[i] = so->tx.buf[so->tx.idx++];
+
+	so->tx.sn = 1;
+	so->tx.state = ISOTP_WAIT_FIRST_FC;
+}
+
+static void isotp_tx_timer_tsklet(unsigned long data)
+{
+	struct isotp_sock *so = (struct isotp_sock *)data;
+	struct sock *sk = &so->sk;
+	struct sk_buff *skb;
+	struct net_device *dev;
+	struct canfd_frame *cf;
+	int ae = (so->opt.flags & CAN_ISOTP_EXTEND_ADDR) ? 1 : 0;
+
+	switch (so->tx.state) {
+	case ISOTP_WAIT_FC:
+	case ISOTP_WAIT_FIRST_FC:
+
+		/* we did not get any flow control frame in time */
+
+		DBG("we did not get FC frame in time.\n");
+
+		/* reset tx state */
+		so->tx.state = ISOTP_IDLE;
+		wake_up_interruptible(&so->wait);
+		break;
+
+	case ISOTP_SENDING:
+
+		/* push out the next segmented pdu */
+
+		DBG("next pdu to send.\n");
+
+		dev = dev_get_by_index(sock_net(sk), so->ifindex);
+		if (!dev)
+			break;
+
+isotp_tx_burst:
+		skb = alloc_skb(so->ll.mtu + CAN_SKBRES, GFP_ATOMIC);
+		if (!skb) {
+			dev_put(dev);
+			break;
+		}
+
+		isotp_skb_reserve(skb, dev);
+		cf = (struct canfd_frame *)skb->data;
+		skb_put(skb, so->ll.mtu);
+
+		/* create consecutive frame */
+		isotp_fill_dataframe(cf, so, ae, 0);
+
+		/* place consecutive frame N_PCI in appropriate index */
+		cf->data[ae] = N_PCI_CF | so->tx.sn++;
+		so->tx.sn %= 16;
+		so->tx.bs++;
+
+		if (so->ll.mtu == CANFD_MTU)
+			cf->flags = so->ll.tx_flags;
+
+		skb->dev = dev;
+		isotp_skb_set_owner(skb, sk);
+		can_send(skb, 1);
+
+		if (so->tx.idx >= so->tx.len) {
+			/* we are done */
+			DBG("we are done\n");
+			so->tx.state = ISOTP_IDLE;
+			dev_put(dev);
+			wake_up_interruptible(&so->wait);
+			break;
+		}
+
+		if (so->txfc.bs && so->tx.bs >= so->txfc.bs) {
+			/* stop and wait for FC */
+			DBG("BS stop and wait for FC\n");
+			so->tx.state = ISOTP_WAIT_FC;
+			dev_put(dev);
+			hrtimer_start(&so->txtimer,
+				      ktime_add(ktime_get(), ktime_set(1,0)),
+				      HRTIMER_MODE_ABS);
+			break;
+		}
+
+		/* no gap between data frames needed => use burst mode */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+		if (!so->tx_gap)
+			goto isotp_tx_burst;
+#else
+		if (!so->tx_gap.tv64)
+			goto isotp_tx_burst;
+#endif
+
+		/* start timer to send next data frame with correct delay */
+		dev_put(dev);
+		hrtimer_start(&so->txtimer,
+			      ktime_add(ktime_get(), so->tx_gap),
+			      HRTIMER_MODE_ABS);
+		break;
+
+	default:
+		WARN_ON_ONCE(1);
+	}
+}
+
+static enum hrtimer_restart isotp_tx_timer_handler(struct hrtimer *hrtimer)
+{
+	struct isotp_sock *so = container_of(hrtimer, struct isotp_sock,
+					     txtimer);
+	tasklet_schedule(&so->txtsklet);
+
+	return HRTIMER_NORESTART;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+static int isotp_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
+#else
+static int isotp_sendmsg(struct kiocb *iocb, struct socket *sock,
+		       struct msghdr *msg, size_t size)
+#endif
+{
+	struct sock *sk = sock->sk;
+	struct isotp_sock *so = isotp_sk(sk);
+	struct sk_buff *skb;
+	struct net_device *dev;
+	struct canfd_frame *cf;
+	int ae = (so->opt.flags & CAN_ISOTP_EXTEND_ADDR) ? 1 : 0;
+	int wait_tx_done = (so->opt.flags & CAN_ISOTP_WAIT_TX_DONE) ? 1 : 0;
+	int off;
+	int err;
+
+	if (!so->bound)
+		return -EADDRNOTAVAIL;
+
+	/* we do not support multiple buffers - for now */
+	if (so->tx.state != ISOTP_IDLE) {
+		if (msg->msg_flags & MSG_DONTWAIT)
+			return -EAGAIN;
+
+		/* wait for complete transmission of current pdu */
+		wait_event_interruptible(so->wait, so->tx.state == ISOTP_IDLE);
+	}
+
+	if (!size || size > MAX_MSG_LENGTH)
+		return -EINVAL;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
+	err = memcpy_from_msg(so->tx.buf, msg, size);
+#else
+	err = memcpy_fromiovec(so->tx.buf, msg->msg_iov, size);
+#endif
+	if (err < 0)
+		return err;
+
+	dev = dev_get_by_index(sock_net(sk), so->ifindex);
+	if (!dev)
+		return -ENXIO;
+
+	skb = sock_alloc_send_skb(sk, so->ll.mtu + CAN_SKBRES,
+				  msg->msg_flags & MSG_DONTWAIT, &err);
+	if (!skb) {
+		dev_put(dev);
+		return err;
+	}
+
+	isotp_skb_reserve(skb, dev);
+
+	so->tx.state = ISOTP_SENDING;
+	so->tx.len = size;
+	so->tx.idx = 0;
+
+	cf = (struct canfd_frame *)skb->data;
+	skb_put(skb, so->ll.mtu);
+
+	/* take care of a potential SF_DL ESC offset for TX_DL > 8 */
+	off = (so->tx.ll_dl > CAN_MAX_DLEN) ? 1 : 0;
+
+	/* check for single frame transmission depending on TX_DL */
+	if (size <= so->tx.ll_dl - SF_PCI_SZ4 - ae - off) {
+		/* The message size generally fits into a SingleFrame - good.
+		 *
+		 * SF_DL ESC offset optimization:
+		 *
+		 * When TX_DL is greater 8 but the message would still fit
+		 * into a 8 byte CAN frame, we can omit the offset.
+		 * This prevents a protocol caused length extension from
+		 * CAN_DL = 8 to CAN_DL = 12 due to the SF_SL ESC handling.
+		 */
+		if (size <= CAN_MAX_DLEN - SF_PCI_SZ4 - ae)
+			off = 0;
+
+		isotp_fill_dataframe(cf, so, ae, off);
+
+		/* place single frame N_PCI w/o length in appropriate index */
+		cf->data[ae] = N_PCI_SF;
+
+		/* place SF_DL size value depending on the SF_DL ESC offset */
+		if (off)
+			cf->data[SF_PCI_SZ4 + ae] = size;
+		else
+			cf->data[ae] |= size;
+
+		so->tx.state = ISOTP_IDLE;
+		wake_up_interruptible(&so->wait);
+
+		/* don't enable wait queue for a single frame transmission */
+		wait_tx_done = 0;
+	} else {
+		/* send first frame and wait for FC */
+
+		isotp_create_fframe(cf, so, ae);
+
+		DBG("starting txtimer for fc\n");
+		/* start timeout for FC */
+		hrtimer_start(&so->txtimer, ktime_set(1,0), HRTIMER_MODE_REL);
+	}
+
+	/* send the first or only CAN frame */
+	if (so->ll.mtu == CANFD_MTU)
+		cf->flags = so->ll.tx_flags;
+
+	skb->dev = dev;
+	skb->sk = sk;
+	err = can_send(skb, 1);
+	dev_put(dev);
+	if (err) {
+		printk_once(KERN_NOTICE "can-isotp: %s: can_send_ret %d\n",
+			    __func__, err);
+		return err;
+	}
+
+	if (wait_tx_done) {
+		/* wait for complete transmission of current pdu */
+		wait_event_interruptible(so->wait, so->tx.state == ISOTP_IDLE);
+	}
+
+	return size;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+static int isotp_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,
+			 int flags)
+#else
+static int isotp_recvmsg(struct kiocb *iocb, struct socket *sock,
+			 struct msghdr *msg, size_t size, int flags)
+#endif
+{
+	struct sock *sk = sock->sk;
+	struct sk_buff *skb;
+	int err = 0;
+	int noblock;
+
+	noblock = flags & MSG_DONTWAIT;
+	flags &= ~MSG_DONTWAIT;
+
+	skb = skb_recv_datagram(sk, flags, noblock, &err);
+	if (!skb)
+		return err;
+
+	if (size < skb->len)
+		msg->msg_flags |= MSG_TRUNC;
+	else
+		size = skb->len;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
+	err = memcpy_to_msg(msg, skb->data, size);
+#else
+	err = memcpy_toiovec(msg->msg_iov, skb->data, size);
+#endif
+	if (err < 0) {
+		skb_free_datagram(sk, skb);
+		return err;
+	}
+
+	sock_recv_timestamp(msg, sk, skb);
+
+	if (msg->msg_name) {
+		msg->msg_namelen = sizeof(struct sockaddr_can);
+		memcpy(msg->msg_name, skb->cb, msg->msg_namelen);
+	}
+
+	skb_free_datagram(sk, skb);
+
+	return size;
+}
+
+static int isotp_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	struct isotp_sock *so;
+	struct net *net;
+
+	if (!sk)
+		return 0;
+
+	so = isotp_sk(sk);
+	net = sock_net(sk);
+
+	/* wait for complete transmission of current pdu */
+	wait_event_interruptible(so->wait, so->tx.state == ISOTP_IDLE);
+
+	unregister_netdevice_notifier(&so->notifier);
+
+	lock_sock(sk);
+
+	hrtimer_cancel(&so->txtimer);
+	hrtimer_cancel(&so->rxtimer);
+	tasklet_kill(&so->txtsklet);
+
+	/* remove current filters & unregister */
+	if (so->bound) {
+		if (so->ifindex) {
+			struct net_device *dev;
+
+			dev = dev_get_by_index(net, so->ifindex);
+			if (dev) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+				can_rx_unregister(net, dev, so->rxid,
+#else
+				can_rx_unregister(dev, so->rxid,
+#endif
+						  SINGLE_MASK(so->rxid),
+						  isotp_rcv, sk);
+				dev_put(dev);
+			}
+		}
+	}
+
+	so->ifindex = 0;
+	so->bound = 0;
+
+	sock_orphan(sk);
+	sock->sk = NULL;
+
+	release_sock(sk);
+	sock_put(sk);
+
+	return 0;
+}
+
+static int isotp_bind(struct socket *sock, struct sockaddr *uaddr, int len)
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct sock *sk = sock->sk;
+	struct isotp_sock *so = isotp_sk(sk);
+	struct net *net = sock_net(sk);
+	int ifindex;
+	struct net_device *dev;
+	int err = 0;
+	int notify_enetdown = 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,4,0)
+	if (len < CAN_REQUIRED_SIZE(struct sockaddr_can, can_addr.tp))
+#else
+	if (len < sizeof(*addr))
+#endif
+		return -EINVAL;
+
+	if (addr->can_addr.tp.rx_id == addr->can_addr.tp.tx_id)
+		return -EADDRNOTAVAIL;
+
+	if ((addr->can_addr.tp.rx_id | addr->can_addr.tp.tx_id) &
+	    (CAN_ERR_FLAG | CAN_RTR_FLAG))
+		return -EADDRNOTAVAIL;
+
+	if (!addr->can_ifindex)
+		return -ENODEV;
+
+	lock_sock(sk);
+
+	if (so->bound && addr->can_ifindex == so->ifindex &&
+	    addr->can_addr.tp.rx_id == so->rxid &&
+	    addr->can_addr.tp.tx_id == so->txid)
+		goto out;
+
+	dev = dev_get_by_index(net, addr->can_ifindex);
+	if (!dev) {
+		err = -ENODEV;
+		goto out;
+	}
+	if (dev->type != ARPHRD_CAN) {
+		dev_put(dev);
+		err = -ENODEV;
+		goto out;
+	}
+	if (dev->mtu < so->ll.mtu) {
+		dev_put(dev);
+		err = -EINVAL;
+		goto out;
+	}
+	if (!(dev->flags & IFF_UP))
+		notify_enetdown = 1;
+
+	ifindex = dev->ifindex;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+	can_rx_register(net, dev, addr->can_addr.tp.rx_id,
+#else
+	can_rx_register(dev, addr->can_addr.tp.rx_id,
+#endif
+			SINGLE_MASK(addr->can_addr.tp.rx_id), isotp_rcv, sk,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,9,11)) || \
+	((LINUX_VERSION_CODE >= KERNEL_VERSION(4,4,50)) && (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))) || \
+	((LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,49)) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0))) || \
+	((LINUX_VERSION_CODE >= KERNEL_VERSION(3,16,42)) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)))
+			"isotp", sk);
+#else
+			"isotp");
+#endif
+	dev_put(dev);
+
+	if (so->bound) {
+		/* unregister old filter */
+		if (so->ifindex) {
+			dev = dev_get_by_index(net, so->ifindex);
+			if (dev) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+				can_rx_unregister(net, dev, so->rxid,
+#else
+				can_rx_unregister(dev, so->rxid,
+#endif
+						  SINGLE_MASK(so->rxid),
+						  isotp_rcv, sk);
+				dev_put(dev);
+			}
+		}
+	}
+
+	/* switch to new settings */
+	so->ifindex = ifindex;
+	so->rxid = addr->can_addr.tp.rx_id;
+	so->txid = addr->can_addr.tp.tx_id;
+	so->bound = 1;
+
+out:
+	release_sock(sk);
+
+	if (notify_enetdown) {
+		sk->sk_err = ENETDOWN;
+		if (!sock_flag(sk, SOCK_DEAD))
+			sk->sk_error_report(sk);
+	}
+
+	return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,17,0)
+static int isotp_getname(struct socket *sock, struct sockaddr *uaddr, int peer)
+#else
+static int isotp_getname(struct socket *sock, struct sockaddr *uaddr,
+		       int *len, int peer)
+#endif
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct sock *sk = sock->sk;
+	struct isotp_sock *so = isotp_sk(sk);
+
+	if (peer)
+		return -EOPNOTSUPP;
+
+	addr->can_family = AF_CAN;
+	addr->can_ifindex = so->ifindex;
+	addr->can_addr.tp.rx_id = so->rxid;
+	addr->can_addr.tp.tx_id = so->txid;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,17,0)
+	return sizeof(*addr);
+#else
+	*len = sizeof(*addr);
+
+	return 0;
+#endif
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,9,0)
+#define copy_from_user copy_from_sockptr
+static int isotp_setsockopt(struct socket *sock, int level, int optname,
+			    sockptr_t optval, unsigned int optlen)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+static int isotp_setsockopt(struct socket *sock, int level, int optname,
+			    char __user *optval, unsigned int optlen)
+#else
+static int isotp_setsockopt(struct socket *sock, int level, int optname,
+			    char __user *optval, int optlen)
+#endif
+{
+	struct sock *sk = sock->sk;
+	struct isotp_sock *so = isotp_sk(sk);
+	int ret = 0;
+
+	if (level != SOL_CAN_ISOTP)
+		return -EINVAL;
+
+	switch (optname) {
+	case CAN_ISOTP_OPTS:
+		if (optlen != sizeof(struct can_isotp_options))
+			return -EINVAL;
+
+		if (copy_from_user(&so->opt, optval, optlen))
+			return -EFAULT;
+
+		/* no separate rx_ext_address is given => use ext_address */
+		if (!(so->opt.flags & CAN_ISOTP_RX_EXT_ADDR))
+			so->opt.rx_ext_address = so->opt.ext_address;
+		break;
+
+	case CAN_ISOTP_RECV_FC:
+		if (optlen != sizeof(struct can_isotp_fc_options))
+			return -EINVAL;
+
+		if (copy_from_user(&so->rxfc, optval, optlen))
+			return -EFAULT;
+		break;
+
+	case CAN_ISOTP_TX_STMIN:
+		if (optlen != sizeof(__u32))
+			return -EINVAL;
+
+		if (copy_from_user(&so->force_tx_stmin, optval, optlen))
+			return -EFAULT;
+		break;
+
+	case CAN_ISOTP_RX_STMIN:
+		if (optlen != sizeof(__u32))
+			return -EINVAL;
+
+		if (copy_from_user(&so->force_rx_stmin, optval, optlen))
+			return -EFAULT;
+		break;
+
+	case CAN_ISOTP_LL_OPTS:
+		if (optlen == sizeof(struct can_isotp_ll_options)) {
+			struct can_isotp_ll_options ll;
+
+			if (copy_from_user(&ll, optval, optlen))
+				return -EFAULT;
+
+			/* check for correct ISO 11898-1 DLC data length */
+			if (ll.tx_dl != padlen(ll.tx_dl))
+				return -EINVAL;
+
+			if (ll.mtu != CAN_MTU && ll.mtu != CANFD_MTU)
+				return -EINVAL;
+
+			if (ll.mtu == CAN_MTU && ll.tx_dl > CAN_MAX_DLEN)
+				return -EINVAL;
+
+			memcpy(&so->ll, &ll, sizeof(ll));
+
+			/* set ll_dl for tx path to similar place as for rx */
+			so->tx.ll_dl = ll.tx_dl;
+		} else {
+			return -EINVAL;
+		}
+		break;
+
+	default:
+		ret = -ENOPROTOOPT;
+	}
+
+	return ret;
+}
+
+static int isotp_getsockopt(struct socket *sock, int level, int optname,
+			    char __user *optval, int __user *optlen)
+{
+	struct sock *sk = sock->sk;
+	struct isotp_sock *so = isotp_sk(sk);
+	int len;
+	void *val;
+
+	if (level != SOL_CAN_ISOTP)
+		return -EINVAL;
+	if (get_user(len, optlen))
+		return -EFAULT;
+	if (len < 0)
+		return -EINVAL;
+
+	switch (optname) {
+	case CAN_ISOTP_OPTS:
+		len = min_t(int, len, sizeof(struct can_isotp_options));
+		val = &so->opt;
+		break;
+
+	case CAN_ISOTP_RECV_FC:
+		len = min_t(int, len, sizeof(struct can_isotp_fc_options));
+		val = &so->rxfc;
+		break;
+
+	case CAN_ISOTP_TX_STMIN:
+		len = min_t(int, len, sizeof(u32));
+		val = &so->force_tx_stmin;
+		break;
+
+	case CAN_ISOTP_RX_STMIN:
+		len = min_t(int, len, sizeof(u32));
+		val = &so->force_rx_stmin;
+		break;
+
+	case CAN_ISOTP_LL_OPTS:
+		len = min_t(int, len, sizeof(struct can_isotp_ll_options));
+		val = &so->ll;
+		break;
+
+	default:
+		return -ENOPROTOOPT;
+	}
+
+	if (put_user(len, optlen))
+		return -EFAULT;
+	if (copy_to_user(optval, val, len))
+		return -EFAULT;
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+static int isotp_notifier(struct notifier_block *nb, unsigned long msg,
+			  void *ptr)
+{
+	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+#else
+static int isotp_notifier(struct notifier_block *nb,
+			unsigned long msg, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+#endif
+	struct isotp_sock *so = container_of(nb, struct isotp_sock, notifier);
+	struct sock *sk = &so->sk;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+	if (!net_eq(dev_net(dev), sock_net(sk)))
+		return NOTIFY_DONE;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+	if (dev_net(dev) != &init_net)
+		return NOTIFY_DONE;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+	if (dev->nd_net != &init_net)
+		return NOTIFY_DONE;
+#endif
+
+	if (dev->type != ARPHRD_CAN)
+		return NOTIFY_DONE;
+
+	if (so->ifindex != dev->ifindex)
+		return NOTIFY_DONE;
+
+	switch (msg) {
+
+	case NETDEV_UNREGISTER:
+		lock_sock(sk);
+		/* remove current filters & unregister */
+		if (so->bound)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+			can_rx_unregister(dev_net(dev), dev, so->rxid,
+#else
+			can_rx_unregister(dev, so->rxid,
+#endif
+					  SINGLE_MASK(so->rxid),
+					  isotp_rcv, sk);
+
+		so->ifindex = 0;
+		so->bound  = 0;
+		release_sock(sk);
+
+		sk->sk_err = ENODEV;
+		if (!sock_flag(sk, SOCK_DEAD))
+			sk->sk_error_report(sk);
+		break;
+
+	case NETDEV_DOWN:
+		sk->sk_err = ENETDOWN;
+		if (!sock_flag(sk, SOCK_DEAD))
+			sk->sk_error_report(sk);
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static int isotp_init(struct sock *sk)
+{
+	struct isotp_sock *so = isotp_sk(sk);
+
+	so->ifindex = 0;
+	so->bound = 0;
+
+	so->opt.flags = CAN_ISOTP_DEFAULT_FLAGS;
+	so->opt.ext_address = CAN_ISOTP_DEFAULT_EXT_ADDRESS;
+	so->opt.rx_ext_address = CAN_ISOTP_DEFAULT_EXT_ADDRESS;
+	so->opt.rxpad_content = CAN_ISOTP_DEFAULT_PAD_CONTENT;
+	so->opt.txpad_content = CAN_ISOTP_DEFAULT_PAD_CONTENT;
+	so->opt.frame_txtime = CAN_ISOTP_DEFAULT_FRAME_TXTIME;
+	so->rxfc.bs = CAN_ISOTP_DEFAULT_RECV_BS;
+	so->rxfc.stmin = CAN_ISOTP_DEFAULT_RECV_STMIN;
+	so->rxfc.wftmax = CAN_ISOTP_DEFAULT_RECV_WFTMAX;
+	so->ll.mtu = CAN_ISOTP_DEFAULT_LL_MTU;
+	so->ll.tx_dl = CAN_ISOTP_DEFAULT_LL_TX_DL;
+	so->ll.tx_flags = CAN_ISOTP_DEFAULT_LL_TX_FLAGS;
+
+	/* set ll_dl for tx path to similar place as for rx */
+	so->tx.ll_dl = so->ll.tx_dl;
+
+	so->rx.state = ISOTP_IDLE;
+	so->tx.state = ISOTP_IDLE;
+
+	hrtimer_init(&so->rxtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	so->rxtimer.function = isotp_rx_timer_handler;
+	hrtimer_init(&so->txtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	so->txtimer.function = isotp_tx_timer_handler;
+
+	tasklet_init(&so->txtsklet, isotp_tx_timer_tsklet, (unsigned long)so);
+
+	init_waitqueue_head(&so->wait);
+
+	so->notifier.notifier_call = isotp_notifier;
+	register_netdevice_notifier(&so->notifier);
+
+	return 0;
+}
+
+static int isotp_sock_no_ioctlcmd(struct socket *sock, unsigned int cmd,
+				  unsigned long arg)
+{
+	/* no ioctls for socket layer -> hand it down to NIC layer */
+	return -ENOIOCTLCMD;
+}
+
+static const struct proto_ops isotp_ops = {
+	.family = PF_CAN,
+	.release = isotp_release,
+	.bind = isotp_bind,
+	.connect = sock_no_connect,
+	.socketpair = sock_no_socketpair,
+	.accept = sock_no_accept,
+	.getname = isotp_getname,
+	.poll = datagram_poll,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,2,0)
+	.ioctl = isotp_sock_no_ioctlcmd,
+	.gettstamp = sock_gettstamp,
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)
+	.ioctl = can_ioctl,	/* use can_ioctl() from af_can.c */
+#else
+	.ioctl = NULL,		/* use can_ioctl() from af_can.c */
+#endif
+	.listen = sock_no_listen,
+	.shutdown = sock_no_shutdown,
+	.setsockopt = isotp_setsockopt,
+	.getsockopt = isotp_getsockopt,
+	.sendmsg = isotp_sendmsg,
+	.recvmsg = isotp_recvmsg,
+	.mmap = sock_no_mmap,
+	.sendpage = sock_no_sendpage,
+};
+
+static struct proto isotp_proto __read_mostly = {
+	.name = "CAN_ISOTP",
+	.owner = THIS_MODULE,
+	.obj_size = sizeof(struct isotp_sock),
+	.init = isotp_init,
+};
+
+static const struct can_proto isotp_can_proto = {
+	.type = SOCK_DGRAM,
+	.protocol = CAN_ISOTP,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+	.capability = -1,
+#endif
+	.ops = &isotp_ops,
+	.prot = &isotp_proto,
+};
+
+static __init int isotp_module_init(void)
+{
+	int err;
+
+	printk(KERN_INFO "can: isotp protocol (rev " CAN_ISOTP_VERSION ")\n");
+
+	err = can_proto_register(&isotp_can_proto);
+	if (err < 0)
+		printk(KERN_ERR "can: registration of isotp protocol failed\n");
+
+	return err;
+}
+
+static __exit void isotp_module_exit(void)
+{
+	can_proto_unregister(&isotp_can_proto);
+}
+
+module_init(isotp_module_init);
+module_exit(isotp_module_exit);
diff --git a/scripts/mod/devicetable-offsets.c b/scripts/mod/devicetable-offsets.c
index 27007c18e754..732cd03e911d 100644
--- a/scripts/mod/devicetable-offsets.c
+++ b/scripts/mod/devicetable-offsets.c
@@ -152,6 +152,9 @@ int main(void)
 	DEVID_FIELD(i3c_device_id, part_id);
 	DEVID_FIELD(i3c_device_id, extra_info);
 
+	DEVID(serdev_device_id);
+	DEVID_FIELD(serdev_device_id, name);
+
 	DEVID(spi_device_id);
 	DEVID_FIELD(spi_device_id, name);
 
diff --git a/scripts/mod/file2alias.c b/scripts/mod/file2alias.c
index 2417dd1dee33..540fee036d9d 100644
--- a/scripts/mod/file2alias.c
+++ b/scripts/mod/file2alias.c
@@ -947,6 +947,15 @@ static int do_spi_entry(const char *filename, void *symval,
 	return 1;
 }
 
+static int do_serdev_entry(const char *filename, void *symval,
+			   char *alias)
+{
+	DEF_FIELD_ADDR(symval, serdev_device_id, name);
+	sprintf(alias, SERDEV_MODULE_PREFIX "%s", *name);
+
+	return 1;
+}
+
 static const struct dmifield {
 	const char *prefix;
 	int field;
@@ -1420,6 +1429,7 @@ static const struct devtable devtable[] = {
 	{"rpmsg", SIZE_rpmsg_device_id, do_rpmsg_entry},
 	{"i2c", SIZE_i2c_device_id, do_i2c_entry},
 	{"i3c", SIZE_i3c_device_id, do_i3c_entry},
+	{"serdev", SIZE_serdev_device_id, do_serdev_entry},
 	{"spi", SIZE_spi_device_id, do_spi_entry},
 	{"dmi", SIZE_dmi_system_id, do_dmi_entry},
 	{"platform", SIZE_platform_device_id, do_platform_entry},
diff --git a/scripts/package/builddeb b/scripts/package/builddeb
index 6df3c9f8b2da..3aba0e099aa1 100755
--- a/scripts/package/builddeb
+++ b/scripts/package/builddeb
@@ -146,6 +146,7 @@ if is_enabled CONFIG_OF_EARLY_FLATTREE; then
 	# Only some architectures with OF support have this target
 	if [ -d "${srctree}/arch/$SRCARCH/boot/dts" ]; then
 		$MAKE -f $srctree/Makefile INSTALL_DTBS_PATH="$tmpdir/usr/lib/$packagename" dtbs_install
+		$MAKE -f $srctree/Makefile INSTALL_DTBS_PATH="$tmpdir/boot/dtbs/$version" dtbs_install
 	fi
 fi
 
